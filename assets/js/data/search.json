[ { "title": "관리자 권한, 메뉴 관리 (5)", "url": "/posts/user_menu_authority_spring(4)/", "categories": "Spring", "tags": "spring security, method security", "date": "2024-06-08 21:30:00 +0900", "snippet": "user_menu_authority 이전 포스팅글들에서 구성한 정보를 가지고 어떤 식으로 인가 처리를 하는지에 대해 작성해보려 합니다. 실제 코드에서는 @PreAuthorize, @PostAuthorize를 이용하여 authority에 대한 사용자 제한을 구현했습니다. 테스트 컨트롤러 테스트를 위한 컨트롤러입니다. 코드를 ...", "content": "user_menu_authority 이전 포스팅글들에서 구성한 정보를 가지고 어떤 식으로 인가 처리를 하는지에 대해 작성해보려 합니다. 실제 코드에서는 @PreAuthorize, @PostAuthorize를 이용하여 authority에 대한 사용자 제한을 구현했습니다. 테스트 컨트롤러 테스트를 위한 컨트롤러입니다. 코드를 보면 알겠지만 [메뉴명]_[CRUD]와 같은 식으로 접근 권한을 주었습니다. @Slf4j@RestController@RequiredArgsConstructor@RequestMapping(path = \"/api/menu-access-test\")public class MenuAccessTestController { @GetMapping(path = \"/adspm-create\") @PreAuthorize(\"hasAnyAuthority('ST_ADSPM_CREATE')\") public ResponseEntity&lt;String&gt; stAdspmCreate() { return new ResponseEntity&lt;&gt;(\"success\", HttpStatus.OK); } @GetMapping(path = \"/adspm-read\") @PreAuthorize(\"hasAnyAuthority('ST_ADSPM_READ')\") public ResponseEntity&lt;String&gt; stAdspmRead() { return new ResponseEntity&lt;&gt;(\"success\", HttpStatus.OK); } @GetMapping(path = \"/adspm-update\") @PreAuthorize(\"hasAnyAuthority('ST_ADSPM_UPDATE')\") public ResponseEntity&lt;String&gt; stAdspmUpdate() { return new ResponseEntity&lt;&gt;(\"success\", HttpStatus.OK); } @GetMapping(path = \"/adspm-delete\") @PreAuthorize(\"hasAnyAuthority('ST_ADSPM_DELETE')\") public ResponseEntity&lt;String&gt; stAdspmDelete() { return new ResponseEntity&lt;&gt;(\"success\", HttpStatus.OK); } @GetMapping(path = \"/aspm-create\") @PreAuthorize(\"hasAnyAuthority('ST_ASPM_CREATE')\") public ResponseEntity&lt;String&gt; stAspmCreate() { return new ResponseEntity&lt;&gt;(\"success\", HttpStatus.OK); } @GetMapping(path = \"/aspm-read\") @PreAuthorize(\"hasAnyAuthority('ST_ASPM_READ')\") public ResponseEntity&lt;String&gt; stAspmRead() { return new ResponseEntity&lt;&gt;(\"success\", HttpStatus.OK); } @GetMapping(path = \"/aspm-update\") @PreAuthorize(\"hasAnyAuthority('ST_ASPM_UPDATE')\") public ResponseEntity&lt;String&gt; stAspmUpdate() { return new ResponseEntity&lt;&gt;(\"success\", HttpStatus.OK); } @GetMapping(path = \"/aspm-delete\") @PreAuthorize(\"hasAnyAuthority('ST_ASPM_DELETE')\") public ResponseEntity&lt;String&gt; stAspmDelete() { return new ResponseEntity&lt;&gt;(\"success\", HttpStatus.OK); }} flyway를 이용해 초기에 설정한 메뉴 권한 정보 입니다. INSERT INTO user_type_menu_authority(common_code_id, menu_authority_id, create_id)VALUES ('UT_ADA', 'ST_ADSPM_CREATE', 'site_admin');INSERT INTO user_type_menu_authority(common_code_id, menu_authority_id, create_id)VALUES ('UT_ADA', 'ST_ADSPM_READ', 'site_admin');INSERT INTO user_type_menu_authority(common_code_id, menu_authority_id, create_id)VALUES ('UT_ADA', 'ST_ADSPM_UPDATE', 'site_admin');INSERT INTO user_type_menu_authority(common_code_id, menu_authority_id, create_id)VALUES ('UT_ADA', 'ST_ADSPM_DELETE', 'site_admin');INSERT INTO user_type_menu_authority(common_code_id, menu_authority_id, create_id)VALUES ('UT_ADA', 'ST_ASPM_CREATE', 'site_admin');INSERT INTO user_type_menu_authority(common_code_id, menu_authority_id, create_id)VALUES ('UT_ADA', 'ST_ASPM_READ', 'site_admin');INSERT INTO user_type_menu_authority(common_code_id, menu_authority_id, create_id)VALUES ('UT_ADA', 'ST_ASPM_UPDATE', 'site_admin');INSERT INTO user_type_menu_authority(common_code_id, menu_authority_id, create_id)VALUES ('UT_ADA', 'ST_ASPM_DELETE', 'site_admin');INSERT INTO user_type_menu_authority(common_code_id, menu_authority_id, create_id)VALUES ('UT_ADSA', 'ST_ADSPM_READ', 'site_admin');INSERT INTO user_type_menu_authority(common_code_id, menu_authority_id, create_id)VALUES ('UT_ADSA', 'ST_ASPM_READ', 'site_admin');INSERT INTO user_type_menu_authority(common_code_id, menu_authority_id, create_id)VALUES ('UT_AA', 'ST_ASPM_CREATE', 'site_admin');INSERT INTO user_type_menu_authority(common_code_id, menu_authority_id, create_id)VALUES ('UT_AA', 'ST_ASPM_READ', 'site_admin');INSERT INTO user_type_menu_authority(common_code_id, menu_authority_id, create_id)VALUES ('UT_AA', 'ST_ASPM_UPDATE', 'site_admin');INSERT INTO user_type_menu_authority(common_code_id, menu_authority_id, create_id)VALUES ('UT_AA', 'ST_ASPM_DELETE', 'site_admin');INSERT INTO \"user\"(user_id, password, user_type)VALUES ('admin', '1234', 'UT_ADA');INSERT INTO \"user\"(user_id, password, user_type)VALUES ('sub_admin', '1234', 'UT_ADSA');INSERT INTO \"user\"(user_id, password, user_type)VALUES ('affiliate_admin', '1234', 'UT_AA'); 테스트 코드 설정 클래스 입니다. 설명은 생략하겠습니다. @SpringBootTest@AutoConfigureMockMvc@ActiveProfiles(\"local\")@TestMethodOrder(MethodOrderer.OrderAnnotation.class)public abstract class TestControllerTestBasic { @Autowired protected MockMvc mockMvc; @Autowired protected UserMapper userMapper; @Autowired protected ObjectMapper objectMapper; @MockBean protected BackOfficeMenuMapper backOfficeMenuMapper; protected final String MAIN_LOG_IN_PAGE = \"/auth/loginPage\"; protected final String BACK_OFFICE_MENU_MODEL_KEY = \"_backOfficeMenuRes\"; protected final String ADMIN_USER_ID = \"admin\"; protected final String ADMIN_PASSWORD = \"1234\"; protected final String SUB_ADMIN_USER_ID = \"sub_admin\"; protected final String SUB_ADMIN_PASSWORD = \"1234\"; protected final String AFFILIATE_ADMIN_USER_ID = \"affiliate_admin\"; protected final String AFFILIATE_ADMIN_PASSWORD = \"1234\"; @Autowired protected AuthenticationManagerBuilder authenticationManagerBuilder; @Autowired private PasswordEncoder passwordEncoder; @Autowired private DefaultUserService defaultUserService; @Autowired private BackOfficeMenuService backOfficeMenuService; @Autowired private CacheManager cacheManager; protected void setSecurityContextHolder(String userId, String password) throws Exception { Authentication authentication = authenticationHelper(userId, password); SecurityContext securityContext = SecurityContextHolder.createEmptyContext(); securityContext.setAuthentication(authentication); SecurityContextHolder.setContext(securityContext); } private Authentication authenticationHelper(String userId, String password) { User userDetails = (User) defaultUserService.loadUserByUsername(userId); if (passwordEncoder.matches(password, userDetails.getPassword())) { List&lt;BackOfficeMenuRes&gt; backOfficeMenuRes = backOfficeMenuService.backOfficeMenuToBackOfficeMenuRes(userDetails.getUserId()); userDetails.loginUserMenuList(backOfficeMenuRes); return new UsernamePasswordAuthenticationToken(userDetails, password, userDetails.getAuthorities()); } else { throw new BadCredentialsException(\"Bad credentials\"); } } protected void clearSecurityContextHolder() { SecurityContextHolder.clearContext(); } @BeforeEach void beforeEach(WebApplicationContext wac) { mockMvc = MockMvcBuilders .webAppContextSetup(wac) .apply(springSecurity()).build(); } @AfterEach void afterEach() { // security context holder 초기화 clearSecurityContextHolder(); // ehcache 초기화 Collection&lt;String&gt; cacheNames = cacheManager.getCacheNames(); for (String cacheName : cacheNames) { Cache cache = cacheManager.getCache(cacheName); Objects.requireNonNull(cache).clear(); } }} 실제 테스트 코드를 실행하는 클래스 입니다. 간단하게 메소드에 선언된 권한, setSecurityContextHolder()로 설정된 유저의 권한에 맞게 요청에 대한 응답 상태값을 검증하였습니다.관리자별로 설정한 권한대로 전체 테스트가 잘 통과하는것을 볼 수 있습니다. class TestControllerTest extends TestControllerTestBasic { @Test @Order(1) void adminAuthorityTest() throws Exception { setSecurityContextHolder(ADMIN_USER_ID, SUB_ADMIN_PASSWORD); mockMvc.perform(get(\"/api/menu-access-test/adspm-create\")) .andExpect(status().isOk()); mockMvc.perform(get(\"/api/menu-access-test/adspm-read\")) .andExpect(status().isOk()); mockMvc.perform(get(\"/api/menu-access-test/adspm-update\")) .andExpect(status().isOk()); mockMvc.perform(get(\"/api/menu-access-test/adspm-delete\")) .andExpect(status().isOk()); mockMvc.perform(get(\"/api/menu-access-test/aspm-create\")) .andExpect(status().isOk()); mockMvc.perform(get(\"/api/menu-access-test/aspm-read\")) .andExpect(status().isOk()); mockMvc.perform(get(\"/api/menu-access-test/aspm-update\")) .andExpect(status().isOk()); mockMvc.perform(get(\"/api/menu-access-test/aspm-delete\")) .andExpect(status().isOk()); } @Test @Order(2) void subAdminAuthorityTest() throws Exception { setSecurityContextHolder(SUB_ADMIN_USER_ID, SUB_ADMIN_PASSWORD); mockMvc.perform(get(\"/api/menu-access-test/adspm-create\")) .andExpect(status().isForbidden()); mockMvc.perform(get(\"/api/menu-access-test/adspm-read\")) .andExpect(status().isOk()); mockMvc.perform(get(\"/api/menu-access-test/adspm-update\")) .andExpect(status().isForbidden()); mockMvc.perform(get(\"/api/menu-access-test/adspm-delete\")) .andExpect(status().isForbidden()); mockMvc.perform(get(\"/api/menu-access-test/aspm-create\")) .andExpect(status().isForbidden()); mockMvc.perform(get(\"/api/menu-access-test/aspm-read\")) .andExpect(status().isOk()); mockMvc.perform(get(\"/api/menu-access-test/aspm-update\")) .andExpect(status().isForbidden()); mockMvc.perform(get(\"/api/menu-access-test/aspm-delete\")) .andExpect(status().isForbidden()); } @Test @Order(3) void affiliateAdminAuthorityTest() throws Exception { setSecurityContextHolder(AFFILIATE_ADMIN_USER_ID, AFFILIATE_ADMIN_PASSWORD); mockMvc.perform(get(\"/api/menu-access-test/adspm-create\")) .andExpect(status().isForbidden()); mockMvc.perform(get(\"/api/menu-access-test/adspm-read\")) .andExpect(status().isForbidden()); mockMvc.perform(get(\"/api/menu-access-test/adspm-update\")) .andExpect(status().isForbidden()); mockMvc.perform(get(\"/api/menu-access-test/adspm-delete\")) .andExpect(status().isForbidden()); mockMvc.perform(get(\"/api/menu-access-test/aspm-create\")) .andExpect(status().isOk()); mockMvc.perform(get(\"/api/menu-access-test/aspm-read\")) .andExpect(status().isOk()); mockMvc.perform(get(\"/api/menu-access-test/aspm-update\")) .andExpect(status().isOk()); mockMvc.perform(get(\"/api/menu-access-test/aspm-delete\")) .andExpect(status().isOk()); }} " }, { "title": "관리자 권한, 메뉴 관리 (4)", "url": "/posts/user_menu_authority_spring(3)/", "categories": "Spring", "tags": "spring security, spring security authentication provider", "date": "2024-06-08 20:00:00 +0900", "snippet": "user_menu_authority 이전에 포스팅에서 작성한 UserDetails를 구현한 User엔티티를 AuthenticationProvider에서 어떤 식으로 사용하는지 작성해보려 합니다. AuthenticationProvider에 대한 설명은 생략하겠습니다. 해당 설정으로 기대하는 기능은 로그인한 사용자의 메뉴 권...", "content": "user_menu_authority 이전에 포스팅에서 작성한 UserDetails를 구현한 User엔티티를 AuthenticationProvider에서 어떤 식으로 사용하는지 작성해보려 합니다. AuthenticationProvider에 대한 설명은 생략하겠습니다. 해당 설정으로 기대하는 기능은 로그인한 사용자의 메뉴 권한정보 셋팅과 접근 가능한 메뉴 리스트를 SecurityContextHolder에 포함하여 이를 이용한 권한체크와 화면단에 메뉴 UI를 그려주는 기능입니다. CustomAuthenticationProvider 간단한 인증 공급자 코드 입니다. 포함하고 있는 유저 정보가 있으면 이전에 작성한 메소드들을 이용하여 필요한 데이터를 설정해줍니다. 이전 글에 포스팅한 User엔티티를 매핑해주는 mybatis코드를 보면 알겠지만 유저가 접근 할 수 있는 메뉴 리스트를 따로 매핑해주지 않았습니다.해당 정보는 CustomAuthenticationProvider를 이용하여 서버단에서 구성하여 매퍼 코드를 단순화 하기 위함이었습니다. BackOfficeMenuService backOfficeMenuService에 대한 설명은 해당 다음 포스팅에 하겠습니다. @Slf4j@Component@RequiredArgsConstructorpublic class CustomAuthenticationProvider implements AuthenticationProvider { private final PasswordEncoder passwordEncoder; private final DefaultUserService defaultUserService; private final BackOfficeMenuService backOfficeMenuService; @Override public Authentication authenticate(Authentication authentication) throws AuthenticationException { String email = authentication.getName(); String password = authentication.getCredentials().toString(); User userDetails = (User) defaultUserService.loadUserByUsername(email); if (passwordEncoder.matches(password, userDetails.getPassword())) { List&lt;BackOfficeMenuRes&gt; backOfficeMenuRes = backOfficeMenuService.backOfficeMenuToBackOfficeMenuRes(userDetails.getUserId()); userDetails.loginUserMenuList(backOfficeMenuRes); return new UsernamePasswordAuthenticationToken(userDetails, password, userDetails.getAuthorities()); } else { throw new BadCredentialsException(\"Bad credentials\"); } } @Override public boolean supports(Class&lt;?&gt; authentication) { return UsernamePasswordAuthenticationToken.class.isAssignableFrom(authentication); }} 위의 설정으로 기대하는 결과는 User엔티티의 모든 필드가 채워지는것 입니다. 이전 포스팅에서는 유저가 접근 할 수 있는 메뉴 리스트가 비어있었습니다.해당 설정을 인증 공급자를 통해 설정되는것을 기대했기에 해당 필드가 의도한대로 셋팅이 되었는지 확인하기 위한 테스트 코드를 작성하고 그 결과를 JSON형태로 직관해보겠습니다. setSecurityContextHolder를 구성하는 부분은 작성되어있는 CustomAuthenticationProvider코드와 같게 구성하여 화면단에서 유저가 로그인한 이후의흐름을 모방하기 위해 작성되었습니다. 실제 로그인 앤드포인트를 호출하기가 귀찮아서 작성하게 되었습니다.(어차피 걔도 인증 공급자를 호출할거니까….) 테스트와 관련된 다른 코드 설명은 생략하겠습니다. @Slf4j@SpringBootTest@ActiveProfiles(\"local\")@TestMethodOrder(MethodOrderer.OrderAnnotation.class)class PostingTest { private final String ADMIN_USER_ID = \"ad_sub_admin\"; private final String ADMIN_PASSWORD = \"1234\"; @Autowired private ObjectMapper objectMapper; @Autowired private PasswordEncoder passwordEncoder; @Autowired private DefaultUserService defaultUserService; @Autowired private BackOfficeMenuService backOfficeMenuService; private void setSecurityContextHolder(String userId, String password) { Authentication authentication = authenticationHelper(userId, password); SecurityContext securityContext = SecurityContextHolder.createEmptyContext(); securityContext.setAuthentication(authentication); SecurityContextHolder.setContext(securityContext); } private Authentication authenticationHelper(String userId, String password) { User userDetails = (User) defaultUserService.loadUserByUsername(userId); if (passwordEncoder.matches(password, userDetails.getPassword())) { List&lt;BackOfficeMenuRes&gt; backOfficeMenuRes = backOfficeMenuService.backOfficeMenuToBackOfficeMenuRes(userDetails.getUserId()); userDetails.loginUserMenuList(backOfficeMenuRes); return new UsernamePasswordAuthenticationToken(userDetails, password, userDetails.getAuthorities()); } else { throw new BadCredentialsException(\"Bad credentials\"); } } @AfterEach void afterEach() { clearSecurityContextHolder(); } protected void clearSecurityContextHolder() { SecurityContextHolder.clearContext(); } @Test @Order(1) void securityContextHolderSetUserTest() throws Exception { setSecurityContextHolder(ADMIN_USER_ID, ADMIN_PASSWORD); SecurityContext context = SecurityContextHolder.getContext(); Authentication authentication = context.getAuthentication(); Assertions.assertNotNull(authentication); Object principal = authentication.getPrincipal(); Assertions.assertInstanceOf(User.class, principal); User user = (User) principal; Assertions.assertFalse(user.getUserMenuAuthorityResList().isEmpty()); log.info(\"user = {}\", objectMapper.writeValueAsString(user)); }} 츨력된 결과 입니다. 인증 공급자를 통해 사이트를 구성하는데 필요한 해당 유저에 대한 모든 정보를 설정할 수 있게 된거같습니다.해당 값을 이용하여 화면을 구성하는건 이제 FRONT의 몫입니다. " }, { "title": "관리자 권한, 메뉴 관리 (3)", "url": "/posts/user_menu_authority_spring(2)/", "categories": "Spring", "tags": "spring security, spring security user details, mybatis", "date": "2024-06-08 16:00:00 +0900", "snippet": "user_menu_authority 이전에 작성한 구성 정보를 가지고 spring security적용하여 메뉴별 CRUD권한 체크와 로그인 사용자의 접근 가능한 메뉴정보를 가져오는 기능을 작성해 보려 합니다.이를 통해 가지고 있는 권한에 맞는 메뉴와 CRUD권한별 인가 설정을 할 수 있게 되었습니다. spring security config 설정 ...", "content": "user_menu_authority 이전에 작성한 구성 정보를 가지고 spring security적용하여 메뉴별 CRUD권한 체크와 로그인 사용자의 접근 가능한 메뉴정보를 가져오는 기능을 작성해 보려 합니다.이를 통해 가지고 있는 권한에 맞는 메뉴와 CRUD권한별 인가 설정을 할 수 있게 되었습니다. spring security config 설정 spring security config 설정 정보 입니다. securityFilterChain()메소드 안에 들어가있는 메소드 들은 의존주입 받은 httpSecurity를 이용하여 각 메소드별로 별개의 설정을 하게 하여 메소드명만으로도 구성정보를 쉽게 알아볼 수 있게 하였습니다. 이번 포스팅에서는 securityFilterChain()안에있는 구성 정보중 authenticationProviderConfig()구성만 살펴보겠습니다. @EnableMethodSecurity를 적용하여 컨트롤러(메소드)별로 접근 권한을 설정하게 하였습니다. @Slf4j@Configuration@EnableMethodSecurity@RequiredArgsConstructorpublic class WebSecurityConfig { private final HttpSecurity httpSecurity; @Bean public SecurityFilterChain securityFilterChain() throws Exception { corsConfig(); csrfConfig(); headerConfig(); authorizeHttpRequestsConfig(); formLoginConfig(); oAuth2LoginConfig(); logOutConfig(); exceptionHandlingConfig(); authenticationProviderConfig(); return httpSecurity.build(); }} User User엔티티 클래스 입니다. 로그인한 사용자의 정보를 해당 엔티티로 구성하여 인증 공급자를 거쳐 SecurityContextHodler안에서 관리되게 됩니다.로그인한 유저의 메뉴별 CURD 권한 리스트와, 메뉴 리스트를 포함하고 있습니다. @Getter@ToString@NoArgsConstructorpublic class User implements UserDetails { private String userId; private String password; private String userType; private List&lt;BackOfficeMenu&gt; userMenuAuthorityList; private List&lt;BackOfficeMenuRes&gt; userMenuAuthorityResList; @Override public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() { return userMenuAuthorityList.stream() .map(BackOfficeMenu::getMenuAuthorityId) .map(SimpleGrantedAuthority::new) .toList(); } public void loginUserMenuList(List&lt;BackOfficeMenuRes&gt; backOfficeMenuRes){ this.userMenuAuthorityResList = backOfficeMenuRes; } ...} getAuthorities() 부분에서 가져온 BackOfficeMenu에서 메뉴 권한 부분을 권한 리스트로 설정해줍니다. 작성하다 느낀건데 BackOfficeMenu클래스의 이름이 마음에 안드는군요.todo 목록으로 해당 클래스명을 BackOfficeMenuAuthority로 변경한다. 라고 기록후 넘어가겠습니다. mybatis 코드 입니다. 쿼리된 결과를 User엔티티에 매핑시켜줍니다. &lt;resultMap id=\"user\" type=\"User\"&gt; &lt;result property=\"userId\" column=\"userId\"/&gt; &lt;result property=\"password\" column=\"password\"/&gt; &lt;result property=\"userType\" column=\"userType\"/&gt; &lt;collection property=\"userMenuAuthorityList\" ofType=\"BackOfficeMenu\"&gt; &lt;result property=\"menuAuthorityId\" column=\"menuAuthorityId\"/&gt; &lt;result property=\"menuId\" column=\"menuId\"/&gt; &lt;result property=\"name\" column=\"name\"/&gt; &lt;result property=\"depth\" column=\"depth\"/&gt; &lt;result property=\"reference\" column=\"reference\"/&gt; &lt;result property=\"menuOrder\" column=\"menuOrder\"/&gt; &lt;result property=\"createDate\" column=\"createDate\"/&gt; &lt;result property=\"createId\" column=\"createId\"/&gt; &lt;result property=\"updateDate\" column=\"updateDate\"/&gt; &lt;result property=\"updateId\" column=\"updateId\"/&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;sql id=\"selectUserInfoBasicSql\"&gt; SELECT b.menu_authority_id AS \"menuAuthorityId\", e.user_id AS \"userId\", e.password AS \"password\", e.user_type AS \"userType\", d.menu_id AS \"menuId\", d.name AS \"name\", d.depth AS \"depth\", d.reference AS \"reference\", d.menu_order AS \"menuOrder\", d.create_date AS \"createDate\", d.create_id AS \"createId\", d.update_date AS \"updateDate\", d.update_id AS \"updateId\" FROM common_code a INNER JOIN user_type_menu_authority b ON b.common_code_id = a.common_code_id INNER JOIN menu_authority c ON b.menu_authority_id = c.menu_authority_id INNER JOIN menu d ON d.menu_id = c.menu_id INNER JOIN \"user\" e ON e.user_type = a.common_code_id WHERE 1 = 1 &lt;/sql&gt; &lt;select id=\"selectUserByUserIdAndPassword\" resultMap=\"user\"&gt; &lt;include refid=\"selectUserInfoBasicSql\"/&gt; AND e.user_id = #{userId} AND e.password = #{password} &lt;/select&gt; &lt;select id=\"selectUserByUserId\" resultMap=\"user\"&gt; &lt;include refid=\"selectUserInfoBasicSql\"/&gt; AND e.user_id = #{userId} &lt;/select&gt; mybatis 의 resultMap이 의도한대로 User엔티티에 바인딩이 되는지 간단한 테스트를 통해 직관해 보도록 하겠습니다. @MybatisTest를 이용하여 매퍼 테스트를 진행하였고 나머지 설명은 생략하겠습니다. ObjectMapper의 경우 전체 스프링 Bean을 끌어오는게 아니라 주입이 되지 않아 직접 생성하여 사용하였습니다. 객체를 생성하여 테스트 하던 중에ObjectMapper에서 LocalDateTime의 형변환이 안되어 추가적으로 @BeforeEach에서 형변환이 가능하게 해주는 모듈을 추가 설정 해주었습니다. @Slf4j@MybatisTest@ActiveProfiles(\"local\")@AutoConfigureTestDatabase(replace = AutoConfigureTestDatabase.Replace.NONE)class UserMapperTest { @Autowired private UserMapper userMapper; private final ObjectMapper objectMapper = new ObjectMapper(); @BeforeEach void setup() { objectMapper.registerModule(new JavaTimeModule()); } @Test void selectUserByUser() throws Exception { Optional&lt;User&gt; admin = userMapper.selectUserByUserIdAndPassword(\"ad_sub_admin\", \"1234\"); Assertions.assertTrue(admin.isPresent()); User user = admin.get(); Assertions.assertNotNull(user); log.info(\"user info = {}\", objectMapper.writeValueAsString(user)); }} 유저 정보를 JSON형태로 출력하였고 아래는 그 결과입니다. 다음 포스팅에서는 AuthenticationProvider구성과 그 이후 설정들을 작성해보겠습니다." }, { "title": "관리자 권한, 메뉴 관리 (2)", "url": "/posts/user_menu_authority_spring(1)/", "categories": "Spring", "tags": "flyway, h2 database, mybatis", "date": "2024-06-08 13:00:00 +0900", "snippet": "user_menu_authority 이전에 작성한 ERD를 가지고 실제 스프링 프로젝트에서 어떤 식으로 데이터를 마이그레이션 하고 mapper를 작성하였는지 작성해보려 합니다. mapper 는 mybatis를 사용 데이터 마이그레이션 실제 프로젝트를 진행하다 보면은 개발 환경에 따라 데이터베이스 싱크가 안맞는 경우가 종...", "content": "user_menu_authority 이전에 작성한 ERD를 가지고 실제 스프링 프로젝트에서 어떤 식으로 데이터를 마이그레이션 하고 mapper를 작성하였는지 작성해보려 합니다. mapper 는 mybatis를 사용 데이터 마이그레이션 실제 프로젝트를 진행하다 보면은 개발 환경에 따라 데이터베이스 싱크가 안맞는 경우가 종종 생겨 개발에 차질이 생기는 경우가 빈번하였습니다. 이를 어떻게 해결하면 좋을까고민을 하다가 찾아보게 된게 flyway라이브러리 였습니다. 이를 통해 결과적으로 모든 개발자 및 환경에서 동일한 데이터 베이스 상태를 유지할것을 기대하고 있습니다.라이브러리에 대한 설명은 생략하고 적용 방식만 작성해보려 합니다. build.gradle : 개발 환경을 맞추기 위한 dependencies 목록입니다. h2데이터 베이스를 이용하여 데이터 베이스 서버가 정해지지 않은 상황에서개발자들이 개인의 로컬에 환경을 구성하지 않았으면 하는 생각에 적용하게 되었습니다. implementation 'org.mybatis.spring.boot:mybatis-spring-boot-starter:3.0.3' implementation 'org.flywaydb:flyway-core' implementation 'org.flywaydb:flyway-database-oracle' runtimeOnly 'com.h2database:h2' application-local.yaml : 로컬 단계에서 사용하는 설정 파일로 위의 구성에 필요한 설정값들이 들어가있습니다. 아래와 같이 구성을 하면 로컬에서 스프링 프로젝트가 runtime하는 생명 주기와 같이 실행되는 데이터베이스 서버를 얻을 수 있습니다. spring: datasource: driver-class-name: net.sf.log4jdbc.sql.jdbcapi.DriverSpy url: jdbc:log4jdbc:h2:mem:testdb;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE;MODE=ORACLE;DATABASE_TO_LOWER=TRUE;CASE_INSENSITIVE_IDENTIFIERS=TRUE username: root password: root flyway: user: root password: root clean-disabled: true locations: classpath:/db/migration url: jdbc:h2:mem:testdb;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE;MODE=ORACLE;DATABASE_TO_LOWER=TRUE;CASE_INSENSITIVE_IDENTIFIERS=TRUE h2: console: enabled: true 위의 설정에서 locations: classpath:/db/migration경로에 데이터 베이스 상태 정보를 작성하면 flyway라이브러리를 통해 마치 데이터 베이스를 git을 이용하는것 처럼 버전관리를 할 수 있게됩니다.해당 경로에 저번 포스트에서 작성한 DDL문을 해당 경로에 작성하여 넣고 테스트에 필요한 기초 데이터들을 추가적으로 구성하였습니다. h2-database에 flyway를 이용하여 마이그레이션된 메뉴 정보 데이터 입니다. BackOfficeMenuMapper 메뉴 정보를 가져오기 위한 매퍼 입니다. 사이트의 메뉴 UI를 그려줄 수 있게 전체 메뉴를 가져오는 매퍼와 해당 유저가 접근 권한을 가지고 있는 메뉴만 가져오기 위한 메퍼 2가지 매퍼를 포함하고 있습니다. &lt;sql id=\"selectMenuInfoBasicSql\"&gt; SELECT a.menu_id AS \"menuId\", a.name AS \"name\", a.DEPTH AS \"depth\", a.reference AS \"reference\", a.menu_order AS \"menuOrder\", a.create_date AS \"createDate\", a.create_id AS \"createId\", a.update_date AS \"updateDate\", a.update_id AS \"updateId\" FROM menu a &lt;/sql&gt; &lt;select id=\"selectAllMenuList\" resultType=\"BackOfficeMenu\"&gt; &lt;include refid=\"selectMenuInfoBasicSql\"/&gt; &lt;/select&gt; &lt;select id=\"selectMenuListByUserId\" resultType=\"BackOfficeMenu\"&gt; &lt;include refid=\"selectMenuInfoBasicSql\"/&gt; INNER JOIN menu_authority b ON b.menu_id = a.menu_id INNER JOIN user_type_menu_authority c ON c.menu_authority_id = b.menu_authority_id INNER JOIN common_code d ON d.common_code_id = c.common_code_id INNER JOIN \"user\" e ON e.user_type = d.common_code_id WHERE 1 = 1 AND e.USER_ID = #{userId} UNION ALL &lt;include refid=\"selectMenuInfoBasicSql\"/&gt; WHERE a.menu_id IN (SELECT a.reference AS \"reference\" FROM menu a INNER JOIN menu_authority b ON b.menu_id = a.menu_id INNER JOIN user_type_menu_authority c ON c.menu_authority_id = b.menu_authority_id INNER JOIN common_code d ON d.common_code_id = c.common_code_id INNER JOIN \"user\" e ON e.user_type = d.common_code_id WHERE 1 = 1 AND e.USER_ID = #{userId} GROUP BY a.reference) &lt;/select&gt; " }, { "title": "관리자 권한, 메뉴 관리 (1)", "url": "/posts/user_menu_authority/", "categories": "Database", "tags": "oracle, relationship", "date": "2024-06-08 12:00:00 +0900", "snippet": " 최근에 참여한 프로젝트에서 3DEPTH메뉴에 해당하는 CRUD 작업의 권한을 권한 유형을 통해 관리하고자 하는것이 요구사항이었습니다. 위의 요구사항을 충족시키기 위해 ERD 설계를 진행하면서 데이터 베이스 내에서 메뉴에 접근하는 권한을 어떻게 하면 효율적으로 관리할 수 있을지구조를 고민하는 과정에 대해 작성해 보려 합니다. ...", "content": " 최근에 참여한 프로젝트에서 3DEPTH메뉴에 해당하는 CRUD 작업의 권한을 권한 유형을 통해 관리하고자 하는것이 요구사항이었습니다. 위의 요구사항을 충족시키기 위해 ERD 설계를 진행하면서 데이터 베이스 내에서 메뉴에 접근하는 권한을 어떻게 하면 효율적으로 관리할 수 있을지구조를 고민하는 과정에 대해 작성해 보려 합니다. 결과적으로 이를 통해 전체 메뉴관리, 메뉴별 CRUD권한 관리, 권한 유형 관리 더 나아가 spring security를 이용한인증, 인가 관리 까지 할 수 있는 기본적인 틀을 구성하게 되었습니다. 데이터 베이스 설계 설계의 시작은 user테이블로 시작을 했습니다. 해당 테이블에서는 user_type으로 권한 유형을 가지고 있습니다. 예제를 단순화 시키기 위해해당 기능을 구현하는데 필요 없는 컬럼은 선언하지 않았습니다. user_type은 공통 코드 테이블에서 따로 관리하도록 하였습니다. CREATE TABLE \"user\"( user_id VARCHAR2(50) PRIMARY KEY, password VARCHAR2(255) NOT NULL, user_type VARCHAR2(50) NOT NULL); user테이블의 user_type와 관계를 맺고 있는 common_code테이블 입니다. 권한 그룹을 따로 관리할거 없이 프로젝트 전역에서쓰이는 공통 코드테이블로 관리해도 무방하다 판단되었습니다. CREATE TABLE common_code ( common_code_id VARCHAR2(50) PRIMARY KEY, reference_code VARCHAR2(50), use_yn CHAR(1) DEFAULT 1 NOT NULL, description VARCHAR2(50) ); user_type_menu_authority테이블 입니다 common_code의 user_type코드 그룹과 다대다 관계를 풀어내기 위한 테이블 입니다.해당 테이블 구성 후 menu_authority 테이블을 생성하여 관계를 맺게 됩니다. CREATE TABLE user_type_menu_authority( common_code_id VARCHAR2(50) NOT NULl, menu_authority_id VARCHAR2(50) NOT NULL, create_date DATE DEFAULT SYSDATE, create_id VARCHAR2(50) NOT NULL); menu_authority테이블 입니다. 3DEPTH메뉴의 CURD권한을 가지고 있는 테이블입니다. CREATE TABLE menu_authority( menu_authority_id VARCHAR2(50) PRIMARY KEY, menu_id VARCHAR2(50) NOT NULL, create_date DATE DEFAULT SYSDATE, create_id VARCHAR2(50) NOT NULL, update_date DATE DEFAULT SYSDATE, update_id VARCHAR2(50)); menu 테이블 입니다. DEPTH와 REFERENCE 컬럼을 이용해 메뉴 정보를 구성할 수 있었습니다. CREATE TABLE menu( menu_id VARCHAR2(50) PRIMARY KEY, name VARCHAR2(50) NOT NULL, depth CHAR(1) DEFAULT 1 NOT NULL, reference VARCHAR2(50), menu_order NUMBER(2), create_date DATE DEFAULT SYSDATE, create_id VARCHAR2(50) NOT NULL, update_date DATE DEFAULT SYSDATE, update_id VARCHAR2(50)); 생성된 테이블에 대한 외래키 제약조건을 설정하는 추가 코드입니다. ALTER TABLE \"user\"ADD CONSTRAINT fk_user_type_code_id FOREIGN KEY (user_type)REFERENCES common_code (common_code_id);ALTER TABLE user_type_menu_authorityADD CONSTRAINT pk_user_type_menu_authority PRIMARY KEY (common_code_id, menu_authority_id);ALTER TABLE user_type_menu_authorityADD CONSTRAINT fk_common_code_id FOREIGN KEY (common_code_id)REFERENCES common_code (common_code_id);ALTER TABLE user_type_menu_authorityADD CONSTRAINT fk_menu_authority_id FOREIGN KEY (menu_authority_id)REFERENCES menu_authority (menu_authority_id);ALTER TABLE menu_authorityADD CONSTRAINT fk_menu_id FOREIGN KEY (menu_id)REFERENCES menu (menu_id); ERD 입니다." }, { "title": "3-tier architecture(1)", "url": "/posts/3-tier(1)/", "categories": "Docker", "tags": "docker, docker compose, docker hub", "date": "2024-03-28 10:50:00 +0900", "snippet": " 3-tier architecture 3-tier architecture 표현 계층(FE) 일반 사용자가 직접 엑세스 할 수 있는 계층 논리 계층(BE) 비지니스 로직이 실행되는 계층 데이터 계층(DB) ...", "content": " 3-tier architecture 3-tier architecture 표현 계층(FE) 일반 사용자가 직접 엑세스 할 수 있는 계층 논리 계층(BE) 비지니스 로직이 실행되는 계층 데이터 계층(DB) 응용 프로그램 데이터에 대한 엑세스를 제공하는 계층 Spring Boot, React.js, MySql docker-compose 파일 구성해보기 step 1 ] DB 서버 구성 step 2 ] back-end 서버 구성 업데이트시 docker push step 3 ] front-end 서버 구성 업데이트시 docker push DB 서버 구성 mysql:latest 사용 에플리케이션에서 사용할 database 설정 (three_tier 스키마) root password 설정 port 설정 구성 된 compose 조각 docker-compose.yml 공유시 .env 파일도 함께 전달하여 환경에 맞게 변수설정을 가능하게 설정 mysql-data-base: image: mysql:latest restart: always environment: MYSQL_DATABASE: ${MYSQL_DATABASE} MYSQL_ROOT_PASSWORD: ${MYSQL_ROOT_PASSWORD} ports: - \"${MYSQL_PORT}:3306\" networks: - my_network Spring 서버 구성 구성된 DB 서버를 의존하는 서비스 구현(three_tier 스키마 사용) 백엔드 로컬 개발과 프론트 로컬 개발용으로 배포되는 두가지 환경만을 고려하여 프로퍼티 구성 back-end 개발용 설정 server: port: 8080spring: datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/three_tier username: root password: root jpa: show-sql: true open-in-view: false hibernate: ddl-auto: validate flyway: user: root password: root clean-disabled: true front-end 개발용 설정 docker-compose.yml 공유시 .env 파일도 함께 전달하여 환경에 맞게 변수설정을 가능하게 설정 server: port: ${SPRING_SERVER_PORT}spring: datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: ${SPRING_DATASOURCE_URL} username: ${SPRING_DATASOURCE_USERNAME} password: ${SPRING_DATASOURCE_PASSWORD} jpa: show-sql: true open-in-view: false hibernate: ddl-auto: validate flyway: user: ${SPRING_DATASOURCE_USERNAME} password: ${SPRING_DATASOURCE_PASSWORD} clean-disabled: true 구성된 compose up 조각 back-end: image: shguddnr3/spring:v3 restart: always ports: - \"${SPRING_SERVER_PORT}:${SPRING_SERVER_PORT}\" - \"8080:8080\" depends_on: - mysql-data-base environment: - SPRING_DATASOURCE_URL=jdbc:mysql://mysql-data-base:${MYSQL_PORT}/${MYSQL_DATABASE} - SPRING_DATASOURCE_USERNAME=${SPRING_DATASOURCE_USERNAME} - SPRING_DATASOURCE_PASSWORD=${SPRING_DATASOURCE_PASSWORD} - JAVA_OPTS=-Dserver.port=${SPRING_SERVER_PORT} networks: - my_network React 서버 구성 백엔드에서 데이터를 요청하고 input 리스트 박스로 보여주는 화면 구성 참고 ] React.js, 스프링부트, AWS로 배우는 웹 개발 101 환경 변수는 적용하지 않고 추후 프론트 개발자와 협력시 어떻게 구성할지 상의 구성된 compose up 조각 front-end: image: shguddnr3/react:v3 restart: always ports: - \"3000:3000\" depends_on: - back-end environment: - REACT_APP_BACKEND_API_URL=http://localhost:${SPRING_SERVER_PORT} networks: - my_network 구성된 docker-compose.yml networks 컴포즈업 내의 컨테이너들이 서로 통신할 수 있도록 하나의 네트워크로 묶어준다. version: '3.8'services: mysql-data-base: image: mysql:latest restart: always environment: MYSQL_DATABASE: ${MYSQL_DATABASE} MYSQL_ROOT_PASSWORD: ${MYSQL_ROOT_PASSWORD} ports: - \"${MYSQL_PORT}:3306\" networks: - my_network back-end: image: shguddnr3/spring:v3 restart: always ports: - \"${SPRING_SERVER_PORT}:${SPRING_SERVER_PORT}\" - \"8080:8080\" depends_on: - mysql-data-base environment: - SPRING_DATASOURCE_URL=jdbc:mysql://mysql-data-base:${MYSQL_PORT}/${MYSQL_DATABASE} - SPRING_DATASOURCE_USERNAME=${SPRING_DATASOURCE_USERNAME} - SPRING_DATASOURCE_PASSWORD=${SPRING_DATASOURCE_PASSWORD} - JAVA_OPTS=-Dserver.port=${SPRING_SERVER_PORT} networks: - my_network front-end: image: shguddnr3/react:v3 restart: always ports: - \"3000:3000\" depends_on: - back-end environment: - REACT_APP_BACKEND_API_URL=http://localhost:${SPRING_SERVER_PORT} networks: - my_networknetworks: my_network: driver: bridge compose-up 결과 프론트 확인 컴포즈업으로 올린 front-end 3000 포트가 back-back-end 8080 포트에 데이터를 요청해 리스트를 뿌려줌 개선해야될점 React.js 환경변수 관리 방법 스프링 서버가 첫 실행에 mysql connect 를 못해 restart: always를 여러번 반복하는 문제 nginx서버를 프록시로 두고 구성하는 방법 고려 " }, { "title": "Spring, restful api, security", "url": "/posts/my_blog(2)/", "categories": "Spring", "tags": "back-end, spring", "date": "2024-03-12 12:00:00 +0900", "snippet": " spring security 적용 후 @EnableMethodSecurity를 적용한 컨트롤러 테스트 spring security 구성 기존 작성된 코드에서 security 의존을 분리 시키기 위한 permitAll()처리 이후에 작성되는 코드에 대해서만 security테스트 코드 작성 SecurityFilterChain@Slf4...", "content": " spring security 적용 후 @EnableMethodSecurity를 적용한 컨트롤러 테스트 spring security 구성 기존 작성된 코드에서 security 의존을 분리 시키기 위한 permitAll()처리 이후에 작성되는 코드에 대해서만 security테스트 코드 작성 SecurityFilterChain@Slf4j@Configuration@EnableMethodSecurity@RequiredArgsConstructorpublic class SecurityConfig { @Bean public SecurityFilterChain securityFilterChain(HttpSecurity httpSecurity) throws Exception { httpSecurity .cors(AbstractHttpConfigurer::disable) .csrf(AbstractHttpConfigurer::disable) .authorizeHttpRequests((requests) -&gt; requests .requestMatchers(\"**.ico\", \"/css/**\", \"/js/**\", \"/\").permitAll() .requestMatchers(\"/api/v1/posts/**\").permitAll() .anyRequest().authenticated() ); httpSecurity .formLogin(withDefaults()) .httpBasic(withDefaults()); return httpSecurity.build(); }} InMemoryUserDetailService, PasswordEncoder@Configurationpublic class ProjectConfig { @Bean public PasswordEncoder passwordEncoder() { return new BCryptPasswordEncoder(); } @Bean public UserDetailsService userDetailsService() { UserDetails admin = User.withUsername(\"admin\").password(passwordEncoder().encode(\"admin\")).roles(\"ADMIN\").build(); UserDetails user = User.withUsername(\"user\").password(passwordEncoder().encode(\"user\")).roles(\"USER\").build(); UserDetails guest = User.withUsername(\"guest\").password(passwordEncoder().encode(\"guest\")).roles(\"GUEST\").build(); return new InMemoryUserDetailsManager(admin, user, guest); }} 테스트 컨트롤러 @Slf4j@RestController@RequestMapping(path = \"/api/v1/security-test\")public class SecurityTestController { @PreAuthorize(\"hasAnyRole('ADMIN','USER','GUEST')\") @GetMapping(path = \"/get-all\") public String all() { return \"getAll\"; } @GetMapping(path = \"/get-admin\") @PreAuthorize(\"hasRole('ADMIN')\") public String getAdmin() { return \"getAdmin\"; } @GetMapping(path = \"/get-user\") @PreAuthorize(\"hasRole('USER')\") public String getUser() { return \"getUser\"; } @GetMapping(path = \"/get-guest\") @PreAuthorize(\"hasRole('GUEST')\") public String getGuest() { return \"getGuest\"; }} 테스트 코드 SecuritySetup security가 적용된 통합 테스트를 진행함으로 @SpringBootTest선언. MockMvc 를 이용한 요청 테스트를 진행할 예정임으로 @AutoConfigureMockMvc선언 테스트 코드에서 설정한 security 구성을 가져와야함으로 mockMvc = MockMvcBuilders.webAppContextSetup(wac).apply(springSecurity()).build() 선언@BeforeEach메소드 인자에 WebApplicationContext wac를 선언하면 자동으로 WebApplicationContext주입시켜준다. admin, user, guest 테스트 대상 계정 선언 , UserDetailService 해당 서비에서 설정한 계정 @SpringBootTest@AutoConfigureMockMvcpublic abstract class SecuritySetup { @Autowired protected MockMvc mockMvc; @Autowired protected UserDetailsService userDetailsService; @Autowired protected PasswordEncoder passwordEncoder; protected UserDetails adminDetails; protected UserDetails userDetails; protected UserDetails guestDetails; @BeforeEach void beforeEach(WebApplicationContext wac) { mockMvc = MockMvcBuilders.webAppContextSetup(wac).apply(springSecurity()).build(); adminDetails = userDetailsService.loadUserByUsername(\"admin\"); Assertions.assertNotNull(adminDetails); userDetails = userDetailsService.loadUserByUsername(\"user\"); Assertions.assertNotNull(userDetails); guestDetails = userDetailsService.loadUserByUsername(\"guest\"); Assertions.assertNotNull(guestDetails); }} SecurityTest 테스트 컨트롤러에 맞게 시나리오 작성후 테스트 인증 정보가 없는 사용자가 접근할 때 401 에러를 뱉는지. 리소스에 접근할 권한이 없는 사용자가 접근할 때 403 에러를 뱉는지. ResultActions requestHelper(String url, UserDetails userDetails) 인증 정보를 인자로 받아 ResultActions을 리턴 해주는 도우미 메소드 public class SecurityTest extends SecuritySetup { @Test void authentication_test() throws Exception { UserDetails mockUser = User.withUsername(\"mock_user\").password(\"12345\").roles(\"MOCK_USER\").build(); requestHelper(\"/api/v1/security-test/get-all\", mockUser).andExpect(status().isUnauthorized()); requestHelper(\"/api/v1/security-test/get-admin\", mockUser).andExpect(status().isUnauthorized()); requestHelper(\"/api/v1/security-test/get-user\", mockUser).andExpect(status().isUnauthorized()); requestHelper(\"/api/v1/security-test/get-guest\", mockUser).andExpect(status().isUnauthorized()); } @Test void authorization_test() throws Exception { requestHelper(\"/api/v1/security-test/get-all\", adminDetails).andExpect(status().isOk()); requestHelper(\"/api/v1/security-test/get-all\", userDetails).andExpect(status().isOk()); requestHelper(\"/api/v1/security-test/get-all\", guestDetails).andExpect(status().isOk()); requestHelper(\"/api/v1/security-test/get-admin\", adminDetails).andExpect(status().isOk()); requestHelper(\"/api/v1/security-test/get-admin\", userDetails).andExpect(status().isForbidden()); requestHelper(\"/api/v1/security-test/get-admin\", guestDetails).andExpect(status().isForbidden()); requestHelper(\"/api/v1/security-test/get-user\", adminDetails).andExpect(status().isForbidden()); requestHelper(\"/api/v1/security-test/get-user\", userDetails).andExpect(status().isOk()); requestHelper(\"/api/v1/security-test/get-user\", guestDetails).andExpect(status().isForbidden()); requestHelper(\"/api/v1/security-test/get-guest\", adminDetails).andExpect(status().isForbidden()); requestHelper(\"/api/v1/security-test/get-guest\", userDetails).andExpect(status().isForbidden()); requestHelper(\"/api/v1/security-test/get-guest\", guestDetails).andExpect(status().isOk()); } private ResultActions requestHelper(String url, UserDetails userDetails) throws Exception { return mockMvc.perform( get(url) .with(httpBasic(userDetails.getUsername(), userDetails.getUsername())) ); }} 실행결과 발생 원인 이전에 설정 했던 ExceptionHandler에서 해당 에러를 캐치해서 500코드로 뱉어내서 발생 문제 코드 디버깅으로 확인했을떄 해당 부분에서 상태 코드를 500으로 반환 @Slf4j@RestControllerAdvice@RequiredArgsConstructorpublic class GlobalControllerAdvice extends ResponseEntityExceptionHandler { // ... @ExceptionHandler(Exception.class) public ResponseEntity&lt;ErrorDetails&lt;String&gt;&gt; globalExceptionHandler( Exception exception, WebRequest webRequest ) { ErrorDetails&lt;String&gt; errorDetails = new ErrorDetails&lt;&gt;(exception.getMessage(), webRequest.getDescription(false)); log.info(\"exception controllerAdviceResponse = {}\", errorDetails); return new ResponseEntity&lt;&gt;(errorDetails, HttpStatus.INTERNAL_SERVER_ERROR); } // ...} 해결 방법 Exception에 잡히기 전에 AccessDeniedException를 먼저 처리 하여 반환 AccessDeniedException : 리소스에 대한 접근 권한이 없을 때 발생하는 에러 추가된 ExcptionHandler@Slf4j@RestControllerAdvice@RequiredArgsConstructorpublic class GlobalControllerAdvice extends ResponseEntityExceptionHandler { // ... @ExceptionHandler(AccessDeniedException.class) public ResponseEntity&lt;ErrorDetails&lt;String&gt;&gt; accessDeniedExceptionHandler( AccessDeniedException exception, WebRequest webRequest ) { ErrorDetails&lt;String&gt; errorDetails = new ErrorDetails&lt;&gt;(exception.getMessage(), webRequest.getDescription(false)); log.info(\"accessDeniedException controllerAdviceResponse = {}\", errorDetails); return new ResponseEntity&lt;&gt;(errorDetails, HttpStatus.FORBIDDEN); } // ...} 테스트 재실행 리소스 접근 권한이 없을 때 반환 상태 코드가 403으로 바뀜! " }, { "title": "Spring, restful api", "url": "/posts/my_blog(1)/", "categories": "Spring", "tags": "back-end, spring", "date": "2024-03-11 20:40:00 +0900", "snippet": " udemy 강의를 참고하여 기본 골격을 만들고 학습한 스택들을 적용시켜 가며 구성 참고한 강의 post apis http method url path status code GET /api/v1/posts 200 ...", "content": " udemy 강의를 참고하여 기본 골격을 만들고 학습한 스택들을 적용시켜 가며 구성 참고한 강의 post apis http method url path status code GET /api/v1/posts 200 GET /api/v1/posts/{id} 200 POST /api/v1/posts 201 PUT /api/v1/posts/{id} 200 DELETE /api/v1/posts/{id} 200 GET /api/v1/posts?pageSize=…. 200 rest controller advice GlobalControllerAdvice WebRequest : 예외가 발생한 리소스의 정보를 HttpServletRequest보다 더 쉽게 가져올 수 있게 해주는 메소드 globalExceptionHandler() : 개발자가 잡아내지 못한 에러가 발생했을 때 후 처리를 위한 ExceptionHandler @Slf4j@RestControllerAdvice@RequiredArgsConstructorpublic class GlobalControllerAdvice { @ExceptionHandler(ResourceNotFoundException.class) public ResponseEntity&lt;ErrorDetails&gt; resourceNotFoundExceptionHandler( ResourceNotFoundException resourceNotFoundException, WebRequest webRequest ) { ErrorDetails errorDetails = new ErrorDetails(resourceNotFoundException.getMessage(), webRequest.getDescription(false)); log.info(\"resourceNotFoundExceptionHandler controllerAdviceResponse = {}\", errorDetails); return new ResponseEntity&lt;&gt;(errorDetails, HttpStatus.NOT_FOUND); } @ExceptionHandler(BlogApiException.class) public ResponseEntity&lt;ErrorDetails&gt; blogApiExceptionHandler( BlogApiException blogApiException, WebRequest webRequest ) { ErrorDetails errorDetails = new ErrorDetails(blogApiException.getMessage(), webRequest.getDescription(false)); log.info(\"blogApiExceptionHandler controllerAdviceResponse = {}\", errorDetails); return new ResponseEntity&lt;&gt;(errorDetails, HttpStatus.BAD_REQUEST); } @ExceptionHandler(Exception.class) public ResponseEntity&lt;ErrorDetails&gt; globalExceptionHandler( Exception exception, WebRequest webRequest ) { ErrorDetails errorDetails = new ErrorDetails(exception.getMessage(), webRequest.getDescription(false)); log.info(\"blogApiExceptionHandler controllerAdviceResponse = {}\", errorDetails); return new ResponseEntity&lt;&gt;(errorDetails, HttpStatus.INTERNAL_SERVER_ERROR); } @Setter @Getter @ToString @NoArgsConstructor @AllArgsConstructor public static class ErrorDetails { private String localDateTime; private String message; private String details; public ErrorDetails(String message, String details) { this.localDateTime = LocalDateTime.now().toString(); this.message = message; this.details = details; } }} Exception ResourceNotFoundException id에 해당하는 리소스가 없을 때 @Getter@ResponseStatus(value = HttpStatus.NOT_FOUND)public class ResourceNotFoundException extends RuntimeException { private final String resourceName; private final String fieldName; private final long fieldValue; public ResourceNotFoundException(String resourceName, String fieldName, long fieldValue) { super(String.format(\"%s not found with %s : '%s'\", resourceName, fieldName, fieldValue)); this.resourceName = resourceName; this.fieldName = fieldName; this.fieldValue = fieldValue; }} BlogApiException 블로그에서 댓글과 게시글에 대한 검증이 실패 하였을 때 @Getter@ResponseStatus(value = HttpStatus.BAD_REQUEST)public class BlogApiException extends RuntimeException { private HttpStatus status; private String message; public BlogApiException(HttpStatus status, String message) { this.status = status; this.message = message; } public BlogApiException(String message, HttpStatus status, String message1) { super(message); this.status = status; this.message = message1; }} post controller 페이징 기본 설정 값public class AppConstants { public static final String DEFAULT_PAGE_NUMBER = \"0\"; public static final String DEFAULT_PAGE_SIZE = \"10\"; public static final String DEFAULT_SORT_BY = \"id\"; public static final String DEFAULT_SORT_DIRECTION = \"asc\";} controller@Slf4j@RestController@RequiredArgsConstructor@RequestMapping(path = \"/api/v1/posts\")public class PostController { private final PostService postService; @PostMapping public ResponseEntity&lt;PostDto&gt; createPost(@RequestBody PostDto postDto) { return new ResponseEntity&lt;&gt;(postService.createPost(postDto), HttpStatus.CREATED); } @GetMapping public ResponseEntity&lt;PostResponse&gt; getAllPosts( @RequestParam(value = \"pageNo\", defaultValue = DEFAULT_PAGE_NUMBER, required = false) int pageNo, @RequestParam(value = \"pageSize\", defaultValue = DEFAULT_PAGE_SIZE, required = false) int pageSize, @RequestParam(value = \"sortBy\", defaultValue = DEFAULT_SORT_BY, required = false) String sort, @RequestParam(value = \"sortDir\", defaultValue = DEFAULT_SORT_DIRECTION, required = false) String sortDir ) { return new ResponseEntity&lt;&gt;(postService.getAllPosts(pageNo, pageSize, sort, sortDir), HttpStatus.OK); } @GetMapping(path = \"/{id}\") public ResponseEntity&lt;PostDto&gt; getPostById(@PathVariable(\"id\") Long id) { return new ResponseEntity&lt;&gt;(postService.getPostById(id), HttpStatus.OK); } @PutMapping(path = \"/{id}\") public ResponseEntity&lt;PostDto&gt; updatePost(@RequestBody PostDto postDto, @PathVariable(\"id\") Long id) { return new ResponseEntity&lt;&gt;(postService.updatePost(postDto, id), HttpStatus.OK); } @DeleteMapping(path = \"/{id}\") public ResponseEntity&lt;PostDto&gt; deletePost(@PathVariable(\"id\") Long id) { return new ResponseEntity&lt;&gt;(postService.deletePost(id), HttpStatus.OK); }} spring data jpa에서 페이징 JpaRepository를 상속받아 사용하면 Pageable 객체를 인자로 받아 페이징 및 정렬을 쉽게 할 수 있다. @NoRepositoryBeanpublic interface PagingAndSortingRepository&lt;T, ID&gt; extends Repository&lt;T, ID&gt; { Iterable&lt;T&gt; findAll(Sort sort); Page&lt;T&gt; findAll(Pageable pageable);} post service @Slf4j@Service@RequiredArgsConstructorpublic class PostServiceImpl implements PostService { private final PostRepository postRepository; @Override public PostDto createPost(PostDto postDto) { Post post = new Post(postDto.getTitle(), postDto.getDescription(), postDto.getContent()); Post save = postRepository.save(post); PostDto postResponse = new PostDto(save.getPostId(), save.getTitle(), save.getDescription(), save.getContent()); log.info(\"postResponse = {}\", postResponse); return postResponse; } @Override public PostResponse getAllPosts(int pageNo, int pageSize, String sortBy, String sortDir) { // 솔트 조건이 여러개인 경우 어떻게? 필요 없나? Sort sort = sortDir.equalsIgnoreCase(Sort.Direction.ASC.name()) ? Sort.by(sortBy).ascending() : Sort.by(sortBy).descending(); PageRequest pageRequest = PageRequest.of(pageNo, pageSize, sort); Page&lt;Post&gt; posts = postRepository.findAll(pageRequest); log.info(\"posts = {}\", posts); List&lt;Post&gt; postList = posts.getContent(); log.info(\"postList = {}\", postList); List&lt;PostDto&gt; content = postList.stream().map(Post::toDto).collect(Collectors.toList()); log.info(\"postDtoList = {}\", content); PostResponse postResponse = new PostResponse(); postResponse.setContent(content); postResponse.setPageNo(posts.getNumber()); postResponse.setPageSize(posts.getSize()); postResponse.setTotalElements(posts.getTotalElements()); postResponse.setTotalPages(posts.getTotalPages()); postResponse.setLast(posts.isLast()); return postResponse; } @Override public PostDto getPostById(Long id) { Post post = postRepository.findById(id).orElseThrow(() -&gt; new ResourceNotFoundException(\"Post\", \"id\", id)); PostDto result = post.toDto(); log.info(\"result = {}\", result); return result; } @Override public PostDto updatePost(PostDto postDto, Long id) { PostDto targetPost = getPostById(id); targetPost.setTitle(postDto.getTitle()); targetPost.setDescription(postDto.getDescription()); targetPost.setContent(postDto.getContent()); PostDto result = createPost(targetPost); log.info(\"result = {}\", result); return result; } @Override public PostDto deletePost(Long id) { PostDto findPost = getPostById(id); postRepository.deleteById(findPost.getPostId()); return findPost; }} post repository public interface PostRepository extends JpaRepository&lt;Post, Long&gt; { Post findPostByTitle(String title);} post entity, post dto entity orphanRemoval = true : 엔티티 간의 관계에서 부모 엔티티가 더이상 자식 엔티티를 참조하지 않을 때 자식 엔티티를 자동으로 제거 uniqueConstraints = {@UniqueConstraint(columnNames = {\"title\"})} : unique 제약 조건을 클래스 레밸에서 설정 가시성이 좋다. @Entity@Getter@NoArgsConstructor(access = AccessLevel.PROTECTED)@Table(name = \"posts\", uniqueConstraints = {@UniqueConstraint(columnNames = {\"title\"})})public class Post { @Id @Column(name = \"post_id\") @GeneratedValue(strategy = GenerationType.IDENTITY) private Long postId; @Column(name = \"title\", nullable = false) private String title; @Column(name = \"description\", nullable = false) private String description; @Column(name = \"content\", nullable = false) private String content; @OneToMany(mappedBy = \"post\", cascade = CascadeType.ALL, orphanRemoval = true) // private Set&lt;Comment&gt; comments = new HashSet&lt;&gt;(); public Post(String title, String description, String content) { this.title = title; this.description = description; this.content = content; } public PostDto toDto() { return new PostDto(this.postId, this.title, this.description, this.content); }} dto@Data@ToString@NoArgsConstructor@AllArgsConstructorpublic class PostDto { private Long postId; private String title; private String description; private String content;} 테스트 코드 post test setup post 모듈 테스트에 필요한 의존성 및 의존성 설정 @TestMethodOrder(MethodOrderer.OrderAnnotation.class) : 테스트 메소드에 @Order() 어노테이션을 이용해서 순서를 지정할 수 있음.테스트간에 독립성을 보장하지 못함으로 추후 random하게 진행될 수 있게 수정해야함 protected JdbcTemplate jdbcTemplate : 테스트 종료후 테스트 데이터를 비워내기 위한 설정. @SpringBootTest@AutoConfigureMockMvc@TestMethodOrder(MethodOrderer.OrderAnnotation.class)public abstract class PostSetup { @Autowired protected MockMvc mockMvc; @Autowired protected ObjectMapper objectMapper; @Autowired protected JdbcTemplate jdbcTemplate; @Autowired protected PostRepository postRepository; protected static final Long NOT_FOUND_ID = Long.MAX_VALUE - 2; @BeforeEach void beforeEach() { jdbcTemplate.execute(\"DELETE FROM posts\"); jdbcTemplate.execute(\"DELETE FROM comments\"); } protected String returnResourceNotFoundExceptionMessage(Long id) { return String.format(\"%s not found with %s : '%s'\", \"Post\", \"id\", id); } protected Long createHelper(PostDto postDto) throws Exception { mockMvc.perform( post(\"/api/v1/posts\") .contentType(MediaType.APPLICATION_JSON_VALUE) .content(objectMapper.writeValueAsString(postDto)) ) .andExpect(status().isOk()) .andExpect(jsonPath(\"$.title\").value(postDto.getTitle())) .andExpect(jsonPath(\"$.description\").value(postDto.getDescription())) .andExpect(jsonPath(\"$.content\").value(postDto.getContent())); Post postByTitle = postRepository.findPostByTitle(postDto.getTitle()); return postByTitle.getPostId(); }} post controller test 통합 테스트를 진행하며 http status 값에 따라 응답받는 값들을 검증하는 방식으로 진행 jsonPath() : 응답 받은 Json문자열 값의 검증을 편하게 해주는 기능 @Transactionalclass PostControllerTest extends PostSetup { @Test @Order(1) void createPost() throws Exception { PostDto postDto = new PostDto(0L, \"title\", \"description\", \"content\"); mockMvc.perform( post(\"/api/v1/posts\") .contentType(MediaType.APPLICATION_JSON_VALUE) .content(objectMapper.writeValueAsString(postDto)) ) .andExpect(status().isOk()) .andExpect(jsonPath(\"$.title\").value(\"title\")) .andExpect(jsonPath(\"$.description\").value(\"description\")) .andExpect(jsonPath(\"$.content\").value(\"content\")); } @Test @Order(2) void getAllPosts() throws Exception { PostDto postDto = new PostDto(0L, \"title\", \"description\", \"content\"); createHelper(postDto); mockMvc.perform( get(\"/api/v1/posts?pageNo={pageNo}&amp;pageSize={pageSize}&amp;sortBy={sortBy}&amp;sortDir={sortDir}\", 0, 10, \"title\", \"desc\") ) .andExpect(status().isOk()) .andExpect(jsonPath(\"$.pageNo\").value(0)) .andExpect(jsonPath(\"$.pageSize\").value(10)) .andExpect(jsonPath(\"$.totalElements\").value(1)) .andExpect(jsonPath(\"$.totalPages\").value(1)) .andExpect(jsonPath(\"$.last\").value(true)); postDto.setTitle(\"title2\"); createHelper(postDto); mockMvc.perform( get(\"/api/v1/posts?pageNo={pageNo}&amp;pageSize={pageSize}&amp;sortBy={sortBy}&amp;sortDir={sortDir}\", 0, 10, \"title\", \"desc\") ) .andExpect(status().isOk()) .andExpect(jsonPath(\"$.pageNo\").value(0)) .andExpect(jsonPath(\"$.pageSize\").value(10)) .andExpect(jsonPath(\"$.totalElements\").value(2)) .andExpect(jsonPath(\"$.totalPages\").value(1)) .andExpect(jsonPath(\"$.last\").value(true)) .andDo(print()); } @Test @Order(3) void getPostById() throws Exception { PostDto postDto = new PostDto(0L, \"title\", \"description\", \"content\"); Long createId = createHelper(postDto); mockMvc.perform( get(\"/api/v1/posts/{id}\", createId) ) .andExpect(status().isOk()); mockMvc.perform( get(\"/api/v1/posts/{id}\", NOT_FOUND_ID) ) .andExpect(jsonPath(\"$.message\").value(returnResourceNotFoundExceptionMessage(NOT_FOUND_ID))) .andExpect(status().isNotFound()); } @Test @Order(4) void updatePost() throws Exception { PostDto postDto = new PostDto(0L, \"title\", \"description\", \"content\"); Long createId = createHelper(postDto); PostDto updatePostDto = new PostDto(0L, \"updateTitle\", \"updateDescription\", \"updateContent\"); mockMvc.perform( put(\"/api/v1/posts/{id}\", createId) .contentType(MediaType.APPLICATION_JSON_VALUE) .content(objectMapper.writeValueAsString(updatePostDto)) ) .andExpect(status().isOk()) .andExpect(jsonPath(\"$.title\").value(updatePostDto.getTitle())) .andExpect(jsonPath(\"$.description\").value(updatePostDto.getDescription())) .andExpect(jsonPath(\"$.content\").value(updatePostDto.getContent())); mockMvc.perform( put(\"/api/v1/posts/{id}\", NOT_FOUND_ID) .contentType(MediaType.APPLICATION_JSON_VALUE) .content(objectMapper.writeValueAsString(updatePostDto)) ) .andExpect(jsonPath(\"$.message\").value(returnResourceNotFoundExceptionMessage(NOT_FOUND_ID))) .andExpect(status().isNotFound()); } @Test @Order(5) void deletePost() throws Exception { PostDto postDto = new PostDto(0L, \"title\", \"description\", \"content\"); Long createId = createHelper(postDto); mockMvc.perform( delete(\"/api/v1/posts/{id}\", createId) ) .andExpect(status().isOk()) .andExpect(jsonPath(\"$.title\").value(postDto.getTitle())) .andExpect(jsonPath(\"$.description\").value(postDto.getDescription())) .andExpect(jsonPath(\"$.content\").value(postDto.getContent())); mockMvc.perform( delete(\"/api/v1/posts/{id}\", NOT_FOUND_ID) ) .andExpect(jsonPath(\"$.message\").value(returnResourceNotFoundExceptionMessage(NOT_FOUND_ID))) .andExpect(status().isNotFound()); }}" }, { "title": "Spring, Local Stack S3", "url": "/posts/localstack_s3(1)/", "categories": "Spring", "tags": "back-end, spring, local stack, s3", "date": "2024-03-10 16:40:00 +0900", "snippet": " local stack AWS의 유료 서비스를 이용한 로직을 구성할 때 개발 단계에서 요금을 지불하지 않고 로컬에서 개발이 가능하게 해주는 기술 스택 아래와 같은 AWS 기능들을 제공 참고 API Gateway at http://localhost:4567 Kinesis at http:/...", "content": " local stack AWS의 유료 서비스를 이용한 로직을 구성할 때 개발 단계에서 요금을 지불하지 않고 로컬에서 개발이 가능하게 해주는 기술 스택 아래와 같은 AWS 기능들을 제공 참고 API Gateway at http://localhost:4567 Kinesis at http://localhost:4568 DynamoDB at http://localhost:4569 DynamoDB Streams at http://localhost:4570 S3 at http://localhost:4572 Firehose at http://localhost:4573 Lambda at http://localhost:4574 SNS at http://localhost:4575 SQS at http://localhost:4576 Redshift at http://localhost:4577 Elasticsearch Service at http://localhost:4578 SES at http://localhost:4579 Route53 at http://localhost:4580 CloudFormation at http://localhost:4581 CloudWatch at http://localhost:4582 SSM at http://localhost:4583 SecretsManager at http://localhost:4584 StepFunctions at http://localhost:4585 CloudWatch Logs at http://localhost:4586 EventBridge (CloudWatch Events) at http://localhost:4587 STS at http://localhost:4592 IAM at http://localhost:4593 EC2 at http://localhost:4597 KMS at http://localhost:4599 ACM at http://localhost:4619 localstack s3 파일 업로드, 다운로드의 기능을 기원해주는 Simple Storage Service를 모킹해볼 예정. AWS_ACCESS_KEY_ID : AwsBasicCredentials 설정에 필요한 access key id AWS_SECRET_ACCESS_KEY : AwsBasicCredentials 설정에 필요한 secret access key AwsBasicCredentials : 지역 설정. version: \"3.8\"services: localstack: container_name: \"aws-s3\" image: localstack/localstack ports: - \"127.0.0.1:4566:4566\" # LocalStack Edge Proxy environment: - SERVICES=s3 - DEBUG=1 - DATA_DIR=/tmp/localstack/data - AWS_ACCESS_KEY_ID=foobar - AWS_SECRET_ACCESS_KEY=foobar - AWS_DEFAULT_REGION=us-east-1 volumes: - \"${LOCALSTACK_VOLUME_DIR:-D:/application/localstack}:/var/lib/localstack\" - \"/var/run/docker.sock:/var/run/docker.sock\" 진행하려던 방식은 local stack s3 컨테이너 내부에서 파일을 저장하는 폴더를 호스트 볼륨으로 사용하여 가시적으로 보려 햇으니local stack s3에서는 파일을 메모리에 저장한다고 함으로 volume공유 부분은 나중에 더 알아보기로… spring boot 의존성 추가 implementation \"org.testcontainers:localstack:1.16.3\" 나중에 테스르 컨테이너 설정을 위한 설정 implementation 'software.amazon.awssdk:s3:2.17.14' aws s3 서비스 사용을 가능하게 해주는 자바 라이브러리 sdk 버전에 따라 설정이 많이 다르니 잘 확인해야됨. dependencies { implementation 'org.springframework.boot:spring-boot-starter-web' compileOnly 'org.projectlombok:lombok' annotationProcessor 'org.projectlombok:lombok' testImplementation 'org.springframework.boot:spring-boot-starter-test' // aws s3 implementation \"org.testcontainers:localstack:1.16.3\" implementation 'software.amazon.awssdk:s3:2.17.14'} AwsS3Configuration docker-compose.yaml 에서 설정한 옵션대로 설정 셋팅.@Configurationpublic class AwsS3Configuration { @Bean public S3Client s3Client( ) { return S3Client.builder() .region(Region.of(\"us-east-1\")) .credentialsProvider(() -&gt; AwsBasicCredentials.create(\"foobar\", \"foobar\")) .endpointOverride(URI.create(\"http://localhost:4566\")) .build(); }} bucket 생성 코드 @Slf4j@Service@RequiredArgsConstructorpublic class S3ServiceImpl implements S3Service { private final S3Client s3Client; @Override public void createBucket(String bucketName) { s3Client.createBucket(CreateBucketRequest.builder().bucket(bucketName).build()); }} 테스트 코드 생성된 버킷이 버킷 리스트에 포함되어있는지 확인 포함 안된 버킷을 조회하여 위의 검증이 맞는 검증인지 확인 @SpringBootTest@AutoConfigureMockMvcclass S3ServiceImplTest { @Autowired private S3Service s3Service; @Test void bucket_create() { s3Service.createBucket(\"bucket\"); List&lt;String&gt; bucket = s3Service.bucketNameList().stream().filter(item -&gt; item.equals(\"bucket\")).collect(Collectors.toList()); Assertions.assertNotEquals(new ArrayList&lt;&gt;(), bucket); List&lt;String&gt; notFoundBucket = s3Service.bucketNameList().stream().filter(item -&gt; item.equals(\"notFoundBucket\")).collect(Collectors.toList()); Assertions.assertEquals(new ArrayList&lt;&gt;(), notFoundBucket); }} s3 이미지 업로드 MultipartFile을 s3에 업로드 하는 코드 FileUploadReq @Getter@Setter@NoArgsConstructor@AllArgsConstructorpublic class FileUploadReq { private MultipartFile multipartFile; private String bucketName; private String key;} uploadMultipartFile(FileUploadReq fileUploadReq) log.error() 부분의 코드는 나중에 ExceptionHandler를 통해 관리한다. @Overridepublic boolean uploadMultipartFile(FileUploadReq fileUploadReq) { MultipartFile multipartFile = fileUploadReq.getMultipartFile(); String bucketName = fileUploadReq.getBucketName(); String key = fileUploadReq.getKey(); try (InputStream inputStream = multipartFile.getInputStream()) { PutObjectRequest putObjectRequest = PutObjectRequest.builder() .bucket(bucketName) .key(key) .build(); RequestBody requestBody = RequestBody .fromInputStream(inputStream, multipartFile.getSize()); PutObjectResponse response = s3Client.putObject(putObjectRequest, requestBody); if (response != null) { log.info(\"File uploaded successfully to S3. Bucket: {}, Key: {}\", bucketName, key); return true; } else { log.error(\"Error uploading file to S3. Bucket: {}, Key: {}\", bucketName, key); return false; } } catch (Exception e) { log.error(\"Error uploading file to S3. Bucket: {}, Key: {}\", bucketName, key, e); return false; }} controller@Slf4j@Controller@RequiredArgsConstructor@RequestMapping(path = \"/file-upload\")public class FileController { private final S3Service s3Service; @PostMapping public ResponseEntity&lt;Void&gt; fileUpload( @RequestParam(\"multipartFile\") MultipartFile multipartFile, @RequestParam(\"bucketName\") String bucketName, @RequestParam(\"key\") String key ) { FileUploadReq fileUploadReq = new FileUploadReq(multipartFile, bucketName, key); s3Service.uploadMultipartFile(fileUploadReq); return new ResponseEntity&lt;&gt;(HttpStatus.OK); }} 테스트 코드 MockMultipartFile를 이용해서 파일을 업로드 @SpringBootTest@AutoConfigureMockMvcclass S3ServiceImplTest { @Autowired private MockMvc mockMvc; @Test void file_upload_test() throws Exception { MockMultipartFile file = new MockMultipartFile( \"file\", // 파일 파라미터 이름 \"test.txt\", // 파일 이름 \"text/plain\", // 파일 타입 \"Hello, World!\".getBytes() // 파일 내용 ); mockMvc.perform( multipart(\"/file-upload\") .file(\"multipartFile\", file.getBytes()) .param(\"bucketName\", \"bucket\") .param(\"key\", UUID.randomUUID().toString()) ) .andExpect(status().isOk()); }} aws cli를 통한 파일 업로드 확인 awslocal s3api list-objects --bucket bucket : 버킷 안에있는 파일 리스트를 조회하는 명령어 진행한 테스트 만큼 파일이 쌓여있는걸 볼 수 있다.root@07c58ed02c50:/# awslocal s3api list-objects --bucket bucket{ \"Contents\": [ { \"Key\": \"0d642021-583b-4512-88ce-9a7fbe477e44\", \"LastModified\": \"2024-03-10T09:58:43.000Z\", \"ETag\": \"\\\"65a8e27d8879283831b664bd8b7f0ad4\\\"\", \"Size\": 13, \"StorageClass\": \"STANDARD\", \"Owner\": { \"DisplayName\": \"webfile\", \"ID\": \"75aa57f09aa0c8caeab4f8c24e99d10f8e7faeebf76c078efc7c6caea54ba06a\" } }, { \"Key\": \"4014be25-66b6-4b25-ab7b-6622ad09320f\", \"LastModified\": \"2024-03-10T08:56:32.000Z\", \"ETag\": \"\\\"65a8e27d8879283831b664bd8b7f0ad4\\\"\", \"Size\": 13, \"StorageClass\": \"STANDARD\", \"Owner\": { \"DisplayName\": \"webfile\", \"ID\": \"75aa57f09aa0c8caeab4f8c24e99d10f8e7faeebf76c078efc7c6caea54ba06a\" } }, { \"Key\": \"fb953b16-2cc1-4305-835a-b1f108237fe0\", \"LastModified\": \"2024-03-10T09:58:09.000Z\", \"ETag\": \"\\\"65a8e27d8879283831b664bd8b7f0ad4\\\"\", \"Size\": 13, \"StorageClass\": \"STANDARD\", \"Owner\": { \"DisplayName\": \"webfile\", \"ID\": \"75aa57f09aa0c8caeab4f8c24e99d10f8e7faeebf76c078efc7c6caea54ba06a\" } } ], \"RequestCharged\": null}" }, { "title": "Junit, Mockito (2)", "url": "/posts/junit_mockito_foundation(2)/", "categories": "Spring, Test Code", "tags": "back-end, java, spring, test code, mockito, controller layer", "date": "2024-03-10 13:00:00 +0900", "snippet": " 통합 테스트가 아닌 controller layer만 분리하여 테스트 controller layer에서 처리되는 값을 검증하기 위한 테스트 ex ) http status, model, view, response body 등등…. 테스트 컨트롤러 많이 사용되는 요청과 응답을 케이스별로 정리 요청 파라미터...", "content": " 통합 테스트가 아닌 controller layer만 분리하여 테스트 controller layer에서 처리되는 값을 검증하기 위한 테스트 ex ) http status, model, view, response body 등등…. 테스트 컨트롤러 많이 사용되는 요청과 응답을 케이스별로 정리 요청 파라미터가 없을 때 @RequestParam 으로 값을 받을 때 @PathVariable 로 값을 받을 때 @ModelAttribute로 값을 받을 때 @RequestBody로 값을 받을 때 파일 데이터를 값으로 받을 때 리턴하는 값이 JSON형태일 때 어떻게 값을 검증하는지. @Getter@Setterpublic class TestReq { private String id; private String password; public TestReq() { } public TestReq(String id, String password) { this.id = id; this.password = password; }}@Controller@RequestMapping(path = \"/controller\")public class IntegratedController { private final RandomUtil randomUtil; @Autowired public IntegratedController(RandomUtil randomUtil) { this.randomUtil = randomUtil; } @GetMapping(path = \"/get-no-parameter\") public String getController1(Model model) { model.addAttribute(\"message\", \"hello mockito!\"); randomModelAttributeSet(model); return \"/controller/get\"; } @GetMapping(path = \"/get-request-param\") public String getController2(@RequestParam(\"param\") String param, Model model) { model.addAttribute(\"message\", \"hello mockito!\"); randomModelAttributeSet(model); model.addAttribute(\"param\", param); return \"/controller/get\"; } @GetMapping(path = \"/get-request-param/{id}\") public String getController3(@PathVariable(\"id\") String id, Model model) { model.addAttribute(\"message\", \"hello mockito!\"); randomModelAttributeSet(model); model.addAttribute(\"pathVariable\", id); return \"/controller/get\"; } @PostMapping(path = \"/post-x-www-form-urlencoded\") public String postController1(@ModelAttribute(\"testReq\") TestReq testReq, Model model) { model.addAttribute(\"message\", \"hello mockito!\"); randomModelAttributeSet(model); model.addAttribute(\"testReq\", testReq); return \"/controller/post\"; } @PostMapping(path = \"/post-request-body\") public String postController2(@RequestBody TestReq testReq, Model model) { model.addAttribute(\"message\", \"hello mockito!\"); randomModelAttributeSet(model); model.addAttribute(\"testReq\", testReq); return \"/controller/post\"; } @PostMapping(path = \"/post-multipart-file/{id}\") public String postController2( @PathVariable(\"id\") String id, @RequestParam(\"file\") MultipartFile multipartFile, Model model ) { model.addAttribute(\"message\", \"hello mockito!\"); randomModelAttributeSet(model); model.addAttribute(\"multipartFile\", multipartFile); model.addAttribute(\"id\", id); return \"/controller/post\"; } @ResponseBody @PostMapping(path = \"/rest-api-response_check\") public TestReq postController3( ) { return new TestReq(\"홍길동\", \"12345\"); } private void randomModelAttributeSet(Model model) { model.addAttribute(\"uuid\", randomUtil.randomUUID()); model.addAttribute(\"integer\", randomUtil.randomIntegerNumber()); }} 테스트 기본 설정 코드 @ExtendWith(MockitoExtension.class)@WebMvcTest( controllers = { IntegratedController.class })@AutoConfigureMockMvcpublic class ControllerTestFoundation { @Autowired private MockMvc mockMvc; @MockBean private RandomUtil randomUtil; private static final ObjectMapper objectMapper = new ObjectMapper(); @BeforeEach void beforeEach() { defaultModelValueSetup(); } private void defaultModelValueSetup() { when(randomUtil.randomUUID()).thenReturn(\"random-uuid\"); when(randomUtil.randomIntegerNumber()).thenReturn(10); }} ExtendWith @ExtendWith(MockitoExtension.class) controller layer 가 의존하고 있는 bean을 모킹해주는 어노테이션을 사용 가능하게 해줌. 참고 WebMvcTest @WebMvcTest : 애플리케이션의 controller layer만을 테스트할 때 사용 controllers 에 테스트한 컨트롤러를 설정할 수 있음. 설정하지 않을시 모든 컨트롤러를 대상으로함 excludeAutoConfiguration, excludeFilters해당 설정을 하면 제외하고싶은 필터, 기본 설정을 무시할 수 있다. excludeAutoConfiguration = SecurityAutoConfiguration.class 이런 설정을 추가하면 security를 무시할 수 있음. @SpringBootTest의 차이점 : @SpringBootTest는 전체 레이어를 대상으로 테스르할 때 사용 private MockMvc mockMvc 테스트 코드에서 컨트롤러에 요청을 보내고 리턴받는 값들을 검증할 수 있게 해주는 클래스 MockBean @MockBean 컨트롤러 레이어에서 의존하고있는 bean을 테스트 가능할 수 있도록 가짜 bean을 만들어 주입해주는 어노테이션 해당 테스트 에서는 private final RandomUtil randomUtil &lt;= 이거에 해당 @BeforeEach @BeforeEach 각각의 @Test를 실행전에 실행되는 메소드, 해당 설정을 함으로써 테스트에 필요한 값이나 설정을 테스트마다 동일하게 할 수 있다. defaultModelValueSetup() 테스트 컨트롤러가 의존하고 있는 계층의 값들에 가짜 값을 주입하는 코드 private RandomUtil randomUtil 해당 서비스에서 제공해주는 값들을 stubbing 해주는 코드 controller_get_no_parameter 요청 파라미터가 없는 컨트롤러 테스트@Test@DisplayName(\"view 리턴 컨트롤러 - get no parameter\")void controller_get_no_parameter() throws Exception { MvcResult mvcResult = mockMvc.perform( get(\"/controller/get-no-parameter\") ) .andExpect(status().isOk()) .andReturn(); ModelAndView modelAndView = mvcResult.getModelAndView(); Assertions.assertNotNull(modelAndView); Map&lt;String, Object&gt; model = modelAndView.getModel(); Assertions.assertNotNull(model.get(\"message\")); Assertions.assertNotNull(model.get(\"uuid\")); Assertions.assertNotNull(model.get(\"integer\")); String viewName = modelAndView.getViewName(); Assertions.assertEquals(\"/controller/get\", viewName);} controller_get_request_param() 요청 파라미터를 url query string 으로 받는 컨트롤러 테스트 요청 url 뒤에 url/param={param} 형식으로 값을 바인딩하고 다음 인자에 바인딩될 값을 설정 @Test@DisplayName(\"view 리턴 컨트롤러 - get - request param\")void controller_get_request_param() throws Exception { MvcResult mvcResult = mockMvc.perform( get(\"/controller/get-request-param?param={param}\", \"param\") ) .andExpect(status().isOk()) .andReturn(); ModelAndView modelAndView = mvcResult.getModelAndView(); Assertions.assertNotNull(modelAndView); Map&lt;String, Object&gt; model = modelAndView.getModel(); Assertions.assertNotNull(model.get(\"message\")); Assertions.assertNotNull(model.get(\"uuid\")); Assertions.assertNotNull(model.get(\"integer\")); Assertions.assertNotNull(model.get(\"param\")); String viewName = modelAndView.getViewName(); Assertions.assertEquals(\"/controller/get\", viewName);} controller_get_path_variable() @PathVariable로 값을 받는 컨트롤러 테스트 테스트 형식이 url query string 방식과 거의 동일하다 @Test@DisplayName(\"view 리턴 컨트롤러 - get - path variable\")void controller_get_path_variable() throws Exception { MvcResult mvcResult = mockMvc.perform( get(\"/controller/get-request-param/{id}\", \"pathVariable\") ) .andExpect(status().isOk()) .andReturn(); ModelAndView modelAndView = mvcResult.getModelAndView(); Assertions.assertNotNull(modelAndView); Map&lt;String, Object&gt; model = modelAndView.getModel(); Assertions.assertNotNull(model.get(\"message\")); Assertions.assertNotNull(model.get(\"uuid\")); Assertions.assertNotNull(model.get(\"integer\")); Assertions.assertEquals(\"pathVariable\", model.get(\"pathVariable\")); String viewName = modelAndView.getViewName(); Assertions.assertEquals(\"/controller/get\", viewName);} controller_post_x_www_form_urlencoded() 요청 값을 x-www-form-urlencoded 형태로 받는 컨트롤러 테스트 perform() 메소드 안에서 요청 url을 설정한 다음에 .param()을 이용해서 값 셋팅. .params() 를 이용해서 MultiValueMap&lt;String, String&gt; params 형식으로 보낼 수도 있음. @Test@DisplayName(\"view 리턴 컨트롤러 - post - x-www-form-urlencoded\")void controller_post_x_www_form_urlencoded() throws Exception { MvcResult mvcResult = mockMvc.perform( post(\"/controller/post-x-www-form-urlencoded\") .param(\"id\", \"홍길동\") .param(\"password\", \"12345\") ) .andExpect(status().isOk()) .andReturn(); ModelAndView modelAndView = mvcResult.getModelAndView(); Assertions.assertNotNull(modelAndView); Map&lt;String, Object&gt; model = modelAndView.getModel(); Assertions.assertNotNull(model.get(\"message\")); Assertions.assertNotNull(model.get(\"uuid\")); Assertions.assertNotNull(model.get(\"integer\")); Assertions.assertNotNull(model.get(\"testReq\")); Assertions.assertInstanceOf(TestReq.class, model.get(\"testReq\")); // 타입 체크 TestReq testReq = (TestReq) model.get(\"testReq\"); Assertions.assertEquals(\"홍길동\", testReq.getId()); Assertions.assertEquals(\"12345\", testReq.getPassword()); String viewName = modelAndView.getViewName(); Assertions.assertEquals(\"/controller/post\", viewName);} controller_post_request_body() 요청 파라미터가 Json일 때 컨트롤러 테스트 ObjectMapper를 이용하여 전달할 값을 JSON형태로 만든 후 테스트 이후 전달받은 값이 잘 바인딩 되었는지까지 검증 @Test@DisplayName(\"view 리턴 컨트롤러 - post - request body\")void controller_post_request_body() throws Exception { TestReq req = new TestReq(\"홍길동\", \"12345\"); MvcResult mvcResult = mockMvc.perform( post(\"/controller/post-request-body\") .contentType(MediaType.APPLICATION_JSON_VALUE) .content(objectMapper.writeValueAsString(req)) ) .andExpect(status().isOk()) .andReturn(); ModelAndView modelAndView = mvcResult.getModelAndView(); Assertions.assertNotNull(modelAndView); Map&lt;String, Object&gt; model = modelAndView.getModel(); Assertions.assertNotNull(model.get(\"message\")); Assertions.assertNotNull(model.get(\"uuid\")); Assertions.assertNotNull(model.get(\"integer\")); Assertions.assertNotNull(model.get(\"testReq\")); Assertions.assertInstanceOf(TestReq.class, model.get(\"testReq\")); // 타입 체크 TestReq testReq = (TestReq) model.get(\"testReq\"); Assertions.assertEquals(\"홍길동\", testReq.getId()); Assertions.assertEquals(\"12345\", testReq.getPassword()); String viewName = modelAndView.getViewName(); Assertions.assertEquals(\"/controller/post\", viewName);}controller_post_multipart_file() MultipartFile를 요청값으로 받는 컨트롤러 테스트 MultipartFile을 모킹해주는 객체 MockMultipartFile 선언 후 테스트 파일 데이터와 다른 데이터를 같이 보낼 수 있다. @Test@DisplayName(\"view 리턴 컨트롤러 - post - multipart file form data\")void controller_post_multipart_file() throws Exception { MockMultipartFile file = new MockMultipartFile( \"file\", // 파일 파라미터 이름 \"test.txt\", // 파일 이름 \"text/plain\", // 파일 타입 \"Hello, World!\".getBytes() // 파일 내용 ); MvcResult mvcResult = mockMvc.perform( multipart(\"/controller/post-multipart-file/{id}\", \"id\") .file(file) ) .andExpect(status().isOk()) .andReturn(); ModelAndView modelAndView = mvcResult.getModelAndView(); Assertions.assertNotNull(modelAndView); Map&lt;String, Object&gt; model = modelAndView.getModel(); Assertions.assertNotNull(model.get(\"message\")); Assertions.assertNotNull(model.get(\"uuid\")); Assertions.assertNotNull(model.get(\"integer\")); Assertions.assertNotNull(model.get(\"multipartFile\")); Assertions.assertNotNull(model.get(\"id\")); String viewName = modelAndView.getViewName(); Assertions.assertEquals(\"/controller/post\", viewName);} rest_controller_response_body_value() Json 형태로 반환되는 response값을 검증하는 테스트 jsonPath를 이용하여 검증 가능 @Test @DisplayName(\"rest api 컨트롤러 - response body 값 검증\") void rest_controller_response_body_value() throws Exception { mockMvc.perform( post(\"/controller/rest-api-response_check\") ) .andExpect(jsonPath(\"$.id\").value(\"홍길동\")) .andExpect(jsonPath(\"$.password\").value(\"12345\")); } 테스트 결과 " }, { "title": "Junit, Mockito (1)", "url": "/posts/junit_mockito_foundation(1)/", "categories": "Spring, Test Code", "tags": "back-end, java, spring, test code, mockito", "date": "2024-03-09 21:00:00 +0900", "snippet": " 격리된 service layer 테스트 @SpringBootTest를 이용한 프로젝트를 build하여 테스트를 하는 방식이아닌 특정 service layer만 떼어 내서 테스트 하는 방법 테스트할 서비스 코드 ServiceLayerTestService RandomNumber Component에서 selectNumber() 메소...", "content": " 격리된 service layer 테스트 @SpringBootTest를 이용한 프로젝트를 build하여 테스트를 하는 방식이아닌 특정 service layer만 떼어 내서 테스트 하는 방법 테스트할 서비스 코드 ServiceLayerTestService RandomNumber Component에서 selectNumber() 메소드를 통해 전달받은 값의 짝수일 때 true를 반환하는 서비스 @SpringBootTest 어노테이션을 사용하지 않고 해당 서비스를 테스트 하려면 어떻게 해야 할까? public interface ServiceLayerTestService { boolean checkEvenNumber();}@Service@RequiredArgsConstructorpublic class ServiceLayerTestServiceImpl implements ServiceLayerTestService { private final RandomNumber randomNumber; @Override public boolean checkEvenNumber() { return randomNumber.selectNumber() % 2 == 0; }} RandomNumberpublic interface RandomNumber { int selectNumber();}@Componentpublic class RandomNumberImpl implements RandomNumber { @Override public int selectNumber() { return new Random().nextInt(); }} 테스트 코드 ServiceLayerTest @ExtendWith(MockitoExtension.class) Mock 객체를 생성하고 테스트 할 수 있게 해주는 어노테이션( 참고) @Mock : 테스트 대상이 되는 빈에 설정되어있는 의존성을 가짜로 주입해주는 어노테이션 해당 서비스에서는 RandomNumber 컴포넌트가 서비스를 실행하는데 필요함으로 @Mock으로 설정 @InjectMocks : 실제 테스트 대상이되는 서비스 주입시켜 주는 부분에서 테스트 대상이 되는 객체를 Interface로 설정하면 테스트 진행이 안됨 실제로 구현하고 있는 구현체를 설정 해준다. when(randomNumber.selectNumber()).thenReturn(10) : 가짜로 주입된 RandomNumber 컴포넌트에서 실행될 메소드의 값을 정해준다.테스트 대상이되는 서비스에서 randomNumber.selectNumber()가 실행되면 10을 리턴해주는 설정. verify(randomNumber).selectNumber() : 실제로 randomNumber 컴포넌트에서 selectNumber() 메소드가 서비스 내에서 실행 됐는지검증해주는 메소드 verify(randomNumber, times(1)).selectNumber() : 해당 메소드의 실행 횟수를 검증해주는 메소드 @ExtendWith(MockitoExtension.class)public class ServiceLayerTest { @InjectMocks // interface 는 주입이 안됨! impl 로 테스트 private ServiceLayerTestServiceImpl serviceLayerTestService; @Mock private RandomNumber randomNumber; @Test void even_test() { when(randomNumber.selectNumber()).thenReturn(10); Assertions.assertTrue(serviceLayerTestService.checkEvenNumber()); } @Test void even_verity_test() { when(randomNumber.selectNumber()).thenReturn(10); Assertions.assertTrue(serviceLayerTestService.checkEvenNumber()); verify(randomNumber).selectNumber(); // selectNumber() 메소드가 실행 되었는지 테스트 verify(randomNumber, times(1)).selectNumber(); // times() 호출 횟수 검증. }} 테스트 결과 " }, { "title": "Spring Security, UserDetails active option", "url": "/posts/userdetails_active_option(1)/", "categories": "Spring, Security", "tags": "back-end, spring, security, user details", "date": "2024-03-08 13:00:00 +0900", "snippet": " 사용자 정보 이메일 인증 기능 구현 전 UserDetails 살펴보기 UserDetails : 시큐리티에서 사용자에 대한 디테일 정보를 처리하기 위한 인터페이스 String getPassword(), String getUsername() : 사용자의 자격 증명을 반환하는 메서드 Collection&lt;? extends ...", "content": " 사용자 정보 이메일 인증 기능 구현 전 UserDetails 살펴보기 UserDetails : 시큐리티에서 사용자에 대한 디테일 정보를 처리하기 위한 인터페이스 String getPassword(), String getUsername() : 사용자의 자격 증명을 반환하는 메서드 Collection&lt;? extends GrantedAuthority&gt; getAuthorities() : 사용자의 권한을 컬렉션으로 반환받는 메서드 사용자의 계정을 필요에 따라 활성화 또는 비활성화 하는 메서드 boolean isAccountNonExpired() boolean isAccountNonLocked() boolean isCredentialsNonExpired() boolean isEnabled() public interface UserDetails extends Serializable { String getUsername(); String getPassword(); Collection&lt;? extends GrantedAuthority&gt; getAuthorities(); boolean isAccountNonExpired(); boolean isAccountNonLocked(); boolean isCredentialsNonExpired(); boolean isEnabled();} 인증 단계 구성 Email인증 여부에 따라 사용자의 계정이 활성화. 비활성화 로직 흐름 인증 단계(회원가입 시) 1 ] 해당 이메일이 사용중인지 검증한다. 사용중일 경우 로직 종료 사용중이 아닐경우 단계를 계속 진행. 2 ] 회원 정보를 User테이블에 insert한다 이때 이메일 인증이 완료되기 전에는 활성화 옵션을 풀지 않는다. 3 ] 이메일 인증이 완료되면 User테이블에서 해당 Email에 해당하는 계정을 활성화 시킨다. 4 ] 일정 시간이 지나면 인증되지 않는 회원 데이터를 삭제한다. 위의 절차를 구현하기 위해 Security는 UserDetails 에서 어떻게 메서드를 지원하고 있는지 알아본다. boolean isAccountNonExpired() 사용자의 계정이 완료되었는지 여부를 나타냄, 만료된 사용자 계쩡은 인증할 수 없다. 사용자의 계정이 유효한지(만료되지 않았는지)여부에 따라 true, 유효하지 않는경우 false 반환 boolean isAccountNonLocked() 사용자의 계정이 잠겨있는지 여부를 나타냄 사용자의 계정이 잠겨있지않으면 true 잠겨있으면 false boolean isCredentialsNonExpired() 사용자의 비밀번호가 만료되었는지 여부 사용자의 비밀번호가 만료되지 않았으면 true, 만료되었으면 false 반환 boolean isEnabled() 사용자의 활성화 여부 활성화되었으면 true, 비활성화 되었으면 false 반환. 각 메서드의 목적에 맞게 로직을 구성하면 될거같다. Email 인증은 inEnabled()과 더 가까운거 같아 해당 기능을 사용하여 구현해볼 예정" }, { "title": "Error 로그 기록", "url": "/posts/logging/", "categories": "Spring", "tags": "back-end, spring, logback, logfile", "date": "2024-03-07 16:00:00 +0900", "snippet": " 기존 프로젝트에 로그 설정하기 로그 관리 시스템을 추가. 기능 1 ] 하나의 요청과 응답을 묶어 UUID를 부여하기. 기능 2 ] error 로그 파일로 적재하기 기능 3 ] 로그 추적에 편리함을 주기 위해 요청의 실패 성공 여부를 DB에 적재 기능 4 ] 에러가난 요청의 UUID를 에러 파일에서 찾아서...", "content": " 기존 프로젝트에 로그 설정하기 로그 관리 시스템을 추가. 기능 1 ] 하나의 요청과 응답을 묶어 UUID를 부여하기. 기능 2 ] error 로그 파일로 적재하기 기능 3 ] 로그 추적에 편리함을 주기 위해 요청의 실패 성공 여부를 DB에 적재 기능 4 ] 에러가난 요청의 UUID를 에러 파일에서 찾아서 대응 가능. 요청과 응답 UUID로 묶기 기본 설정된 콘솔에 띄워지는 로그는 해당 로그를 발생시킨 주체를 쓰레드까지밖에 세분화를 못시킴2024-03-07 16:53:10 [ http-nio-8080-exec-3 ] [ DEBUG] [i.s.v.c.c.ModelConverterContextImpl] - resolve int2024-03-07 16:53:10 [ http-nio-8080-exec-3 ] [ DEBUG] [i.s.v.c.c.ModelConverterContextImpl] - resolve java.util.List&lt;org.spring.oauth2.email_validate_register.user.dto.UserDto&gt;2024-03-07 16:53:10 [ http-nio-8080-exec-3 ] [ DEBUG] [i.s.v.c.c.ModelConverterContextImpl] - resolve [simple type, class org.spring.oauth2.email_validate_register.user.dto.UserDto]2024-03-07 16:53:10 [ http-nio-8080-exec-3 ] [ DEBUG] [i.s.v.c.c.ModelConverterContextImpl] - resolve [simple type, class java.lang.String] 장애가 발생하였을때 더욱 디테일한 정보로 로그를 추적해야 하기 때문에 요청과 응답을 UUID로 묶어 사용해야함 이때 필요한게 MDC MDC : 쉽게 말하면 현재 실행중인 쓰레드에 메타정보를 넣고 관리하는 공간. 내부적으로 Map을 관리하고 있어서 key:value 셋팅 가능 해당 메타정보에 UUID를 추가하여 logback-spring.xml설정을 통해 콘솔에 노출. MDC MDC 클래스 내부 정보 결론 : 아무튼 MDCAdapter어뎁터에 key,value를 put 할 수 있다. public class MDC { // .... public static void put(String key, String val) throws IllegalArgumentException { if (key == null) { throw new IllegalArgumentException(\"key parameter cannot be null\"); } if (mdcAdapter == null) { throw new IllegalStateException(MDC_APAPTER_CANNOT_BE_NULL_MESSAGE); } mdcAdapter.put(key, val); } // ....}public interface MDCAdapter { public void put(String key, String val); public String get(String key); public void remove(String key); public void clear(); public Map&lt;String, String&gt; getCopyOfContextMap(); public void setContextMap(Map&lt;String, String&gt; contextMap); public void pushByKey(String key, String value); public String popByKey(String key); public Deque&lt;String&gt; getCopyOfDequeByKey(String key); public void clearDequeByKey(String key);} MDC 메타정보에 UUID 넣기 추후에 spring security를 사용할 예정임으로 config에 filter로 추가 MDCLoggingFilter : 요청과 응답을 UUID로 묶어주고 마지막에 해당 메타정보 삭제 하나의 요청당 한번만 실행되어야 함으로 OncePerRequestFilter 적용 public class MDCLoggingFilter extends OncePerRequestFilter { private static final String TRACE_ID = \"traceId\"; @Override protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException { try { String uuid = UUID.randomUUID().toString(); MDC.put(TRACE_ID, uuid); filterChain.doFilter(request, response); } finally { MDC.remove(TRACE_ID); } }} security config에 추가@Slf4j@Configuration@EnableWebSecurity@RequiredArgsConstructorpublic class WebSecurityConfig { // ... @Bean public SecurityFilterChain defaultSecurityFilterChain(HttpSecurity http) throws Exception { http // ... .addFilterAt(new MDCLoggingFilter(), BasicAuthenticationFilter.class) // ... return http.build(); } // ...} UUID를 콘솔에서 출력되는 정보에 추가하기 logback-spring.xml 사용 패턴을 지정해주는 부분에서 %X{traceId}] 와 같은 형식으로 MDC안에 있는 값을 꺼내올 수 있음 출력 패턴은 아래와 같음 %green(%d{yyyy-MM-dd HH:mm:ss}) %boldWhite([ %thread ]) %green([traceId : %X{traceId}]) %boldCyan([ %-5level]) %boldWhite([%logger{36}]) - %msg%n\" 설정 후 콘솔 로그 출력 결과 아래의 메세지와 같이 쓰레드 오른쪽에 traceId 로 요청이 UUID로 묶여서 나오는걸 볼 수 있음. error 로그 파일에 적재하기 이전 구성이 완료 되었다면 에러 로그에 대한 파일 적재를 해야함 이때 콘솔에 보이는 로그는 INFO레벨 이어야 하고 파일에 쌓이는 데이터는 ERROR레벨이어야함 파일 어펜더를 설정할때 filter를 끼어넣어 ERROR 레벨에서만 파일에 적재하게 설정 변경 LevelFilter : 에러 레벨에 따른 처리를 할 수 있게 해주는 클래스 &lt;appender name=\"FILE_ERROR\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"&gt; &lt;file&gt;...&lt;/file&gt; &lt;filter class=\"ch.qos.logback.classic.filter.LevelFilter\"&gt; &lt;level&gt;error&lt;/level&gt; &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt; &lt;onMismatch&gt;DENY&lt;/onMismatch&gt; &lt;/filter&gt; &lt;encoder class=\"ch.qos.logback.classic.encoder.PatternLayoutEncoder\"&gt;... &lt;/encoder&gt; &lt;rollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\"&gt;... &lt;/rollingPolicy&gt; &lt;/appender&gt;... &lt;root level=\"INFO\"&gt; &lt;appender-ref ref=\"CONSOLE_INFO\"/&gt; &lt;appender-ref ref=\"FILE_ERROR\"/&gt; &lt;/root&gt; 위와같이 설정하면 아래와같이 콜솔에는 INFO 파일에는 ERROR의 로그를 기록하는 기능 구현이 완료된다." }, { "title": "Docker, volume, network", "url": "/posts/docker(8)/", "categories": "Docker", "tags": "docker, volume, network", "date": "2024-03-06 13:50:00 +0900", "snippet": "도커 볼륨 도커 내부에 볼륨을 설정하여 관리 docker volume coreate --name myvolme 볼륨 생성. docker volume ls 볼륨 확인 docker run -d -p 3307:3307 -v my_sql:/var/lib/mysql -e MYSQL_ROOT...", "content": "도커 볼륨 도커 내부에 볼륨을 설정하여 관리 docker volume coreate --name myvolme 볼륨 생성. docker volume ls 볼륨 확인 docker run -d -p 3307:3307 -v my_sql:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=password --name mysql mysql:latest --port=3307 docker -v my_sql:/var/lib/mysql : my_mysql 볼륨에 컨테이너의 /var/lib/mysql 파일이 저장됨 컨테이너가 삭제 되어도 해당 볼륨은 살아남아 영속성 유지. 도커 네트워크 구조 도커 컨테이너 생성시 컨테이너에는 eth0, lo네크워크 인터페이스가 구성됨 eth0 : 리눅스 기반 시스템에서 첫번째 이더넷 네크워크 인터페이스를 가르킴. 공인 IP또는 내부 IP가 할당되어 실제로 외부와 통신할 수 있음. 컨테이너의 eth 는 호스트의 veth와 연결되어 있어 docker브리지와 바인딩 되어 외부와 통신 가능 lo : 컴퓨터 자체와 통실할때 사용되는 인터페이스, 로컬 시스템에만 작동하는 서비스 도커 네트워크 기능 컨테이너 생성시 기본적으로 docker0브리지를 통해 외부와 통신 가능한 환경 사용 가능. docker network ls : 도커에서 사용 가능한 네트워크 확인 NETWORK ID NAME DRIVER SCOPE9181642e15dd bridge bridge local43b3706303d2 host host locala93bb115e19c none null local bridge : 컨테이너를 생성할때 자동으로 연결되는 docker0브리지를 활용 172.17.0.x IP대역을 컨테이너에 순차적으로 할당. PS E:\\docker_project&gt; docker network inspect bridge[ {... \"IPAM\": {... \"Config\": [ { \"Subnet\": \"172.17.0.0/16\", \"Gateway\": \"172.17.0.1\" } ] },... \"Containers\": { \"58abd701dfd6c6c04fdd3a449d4166347453a2dd6fa68f59b6fb3585e7daba8f\": { \"Name\": \"mysql\", \"EndpointID\": \"9d452bcc5044a4ea20abadfed55165cadd638870ee015f084872b3f1f9812577\", \"MacAddress\": \"02:42:ac:11:00:02\", \"IPv4Address\": \"172.17.0.2/16\", \"IPv6Address\": \"\" } },... }] bridge network docker0이 아닌 사용자 정의 브리지를 새로 생성해 각 컨테이너에 연결하는 네트워크 연결된 브리지를 통해 외부와 통신할 수 있다. docker network create --driver bridge mybridge 새로운 브리지 타입의 네트워크 생성 가능. PS E:\\docker_project&gt; docker network create --driver bridge mybridgee9adb35a87260a269e5793b919d9fd90e284ab61e92f89870b96baecb0de7bffPS E:\\docker_project&gt; docker network lse9adb35a8726 mybridge bridge local docker run -it --rm --net mybridge --name bridge ubuntu:14.04 내가 만든 브릿지로 컨테이너 생성 및 연결 ubuntu접속 후 ifconfig 확인eth0 Link encap:Ethernet HWaddr 02:42:ac:12:00:02 inet addr:172.18.0.2 Bcast:172.18.255.255 Mask:255.255.0.0 ....lo Link encap:Local Loopback inet addr:127.0.0.1 Mask:255.0.0.0 ... mybridge확인\"Name\": \"bridge\",\"EndpointID\": \"1a8942c1d5d6ef186f11bd900acd5f5d2d11616307feafdeff48f1317ea98d2c\",\"MacAddress\": \"02:42:ac:12:00:02\",\"IPv4Address\": \"172.18.0.2/16\", 172.18 대역의 내부 ip 생성확인 docker network connect mybridge container_name 컨테이너에 네크워크 연결 docker network disconnect mybridge container_name 컨테이너에 네크워크 연결 해제 호스트 네트워크 호스트의 네트워크 환경을 그대로 사용할 수 있음. --net host 논 네트워크 아무런 네트워크도 사용하지 않음. --net none 컨테이너 네트워크 다른 컨테이너의 네트워크 환경 설정을 그대로 사용함 --net container:container_name 브리지 네트워크 alias mybridge를 사용하는 3개의 컨테이너를 생성할때에 --net-alias설정 docker run -it -d --name network_alias_container1 --net mybridge --net-alias alicek106 ubuntu:14.04 docker run -it -d --name network_alias_container2 --net mybridge --net-alias alicek106 ubuntu:14.04 docker run -it -d --name network_alias_container3 --net mybridge --net-alias alicek106 ubuntu:14.04 이후 ping요청을 보내는 컨테이너 생성후 ping -c 1 alicek106 명령어 실행시켜 ping전송시 응답 메세지 확인 매번 다른 IP로 응답이 오는데 이거 round-robin방식으로 오는것. --link 컨테이너의 IP가 변경되어도 컨테이너를 찾을 수 있게 DNS에 의해 자동으로 관리해주는 옵션." }, { "title": "Docker, volume(1)", "url": "/posts/docker(7)/", "categories": "Docker", "tags": "docker, volume", "date": "2024-03-05 15:40:00 +0900", "snippet": " 기본 명령어 정리 docker run -it ubuntu:14.04 이미지를 받음과 동시에 컨테이너 생성 후 cli진입 docker pull centos:7 이미지를 받는 또다른 방법 docker create -i -t --name mycentos centos:7 컨테이너 ...", "content": " 기본 명령어 정리 docker run -it ubuntu:14.04 이미지를 받음과 동시에 컨테이너 생성 후 cli진입 docker pull centos:7 이미지를 받는 또다른 방법 docker create -i -t --name mycentos centos:7 컨테이너 빌드 docker start name 컨테이너 실행 docker attach name 내부로 들어가기 내부 진입에서 빠져나오는 방법 2가지 exit : 컨테이너 종료 후 빠져나옴 Ctrl+P,Q : 컨테이너를 종료 시키지 않고 내부에서만 빠져나옴 docker ps 실행중인 컨테이너 목록 확인 docker ps -a 전체 컨테이너 목록 확인 docker rename before after 컨테이너 이름 변경 docker rm name 컨테이너 삭제, 실행중인 컨테이너는 중지 후 삭제 docker rm -f name 실행중인 컨테이너 삭제 docker stop name 컨테이너 중지 컨테이너 애플리케이션 구축 docker run -i -t --name mywebserver -p 80:80 ubuntu:14.04 -p : 컨테이너의 포트를 호스트의 포트와 바인딩 [호스트의 포트]:[컨테이너의 포트] wordpress + mysql mysql 설치 docker run -d --name wordpressdb -e MYSQL_ROOT_PASSWORD=password -e MYSQL_DATABASE=wordpress mysql:5.7 wordpress 설치 docker run -d -e WORDPRESS_DB_PASSWORD=password --name wordpress --link wordpressdb:mysql -p 80 wordpress:wq CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESbbe628b7632a wordpress \"docker-entrypoint.s…\" 11 seconds ago Up 10 seconds 0.0.0.0:55318-&gt;80/tcp wordpressaf37fb7c59ea mysql:5.7 \"docker-entrypoint.s…\" About a minute ago Up About a minute 3306/tcp, 33060/tcp wordpressdbb85463cd9339 ubuntu:14.04 \"/bin/bash\" 6 minutes ago Up 6 minutes 0.0.0.0:80-&gt;80/tcp mywebserver docker port name 컨테이너의 연결 포트를 확인 가능 error establishing a database connection 참고 : 해당 도커 예제는 시작하세요! 도커/쿠버네티스 책으로 진행. mysql, wordpress, ubuntu 설치하여 진행중 최종 wordpress 실행시 error establishing a database connection 에러가 발생. wordperss 내부로 진입하여 wp-config.php파일 확인 결과 설정된 db 설정이 잘못되어 수정후 진행(wordpressdb 정보로) docker exec -it wordpress /bin/bash 추후 컨테이너로 올릴때에는 docker run -d -e WORDPRESS_DB_NAME=wordpress -e WORDPRESS_DB_USER=root -e WORDPRESS_DB_PASSWORD=password --name wordpress_hostvolume --link wordpressdb_hostvolume:mysql -p 80 wordpress 해당 설정 사용, DB 설정에 필요한 환경변수를 모두 넣어주어서 실행 docker volume, 호스트 볼륨 공유 방식 위에서 생성된 wordpress와 database의 데이터들은 컨테이너 삭제시 없어진다는 단점이 있음. 어떻게 하면 좋을까? volume 사용. docker run -d --name wordpressdb_hostvolume -e MYSQL_ROOT_PASSWORD=password -e MYSQL_DATABASE=wordpress -v E:\\docker\\volume:/var/lib/mysql mysql:5.7 -v /home/wordpress_db:/var/lib/mysql mysql:5.7 호스트의 /home/wordpress_db 디렉터리와 컨테이너의 /var/lib/mysql 디렉터리를 공유. 책에서는 /home/wordpress_db 폴더를 생성하였지만 실습에서는 E:\\docker\\volume 경로에 볼륨을 지정. 파일 확인 동기화 되는 개념이 아니라 완전 같은 디렉토리를 바라보게 된다! -v옵션을 통한 호스트 볼륨 공유는 호스트의 디렉터리를 컨테이너의 디렉터리에 마운트하는 개념." }, { "title": "Spring Boot, Dockerfile", "url": "/posts/docker(6)/", "categories": "Docker", "tags": "docker, spring boot build, gradle, docker image", "date": "2024-03-05 09:40:00 +0900", "snippet": " 스프링 부트 프로젝트 도커화 시키기 간단한 log 메세지를 출력하는 스프링부트 프로젝트 생성 gradlew 기능 사용하여 프로젝트 jar로 묶기 Dockerfile 작성 및 테스트 다양한 환경 변수를 설정할 수 있게 Dockerfile 수정 프로젝트 설정 간단한 로그 출력 프로젝트 구성 ...", "content": " 스프링 부트 프로젝트 도커화 시키기 간단한 log 메세지를 출력하는 스프링부트 프로젝트 생성 gradlew 기능 사용하여 프로젝트 jar로 묶기 Dockerfile 작성 및 테스트 다양한 환경 변수를 설정할 수 있게 Dockerfile 수정 프로젝트 설정 간단한 로그 출력 프로젝트 구성 자바 버전 : java17 빌드 도구 : groovy-gradle 운영체제 : WINDOW10 build.gradleplugins {\tid 'java'\tid 'org.springframework.boot' version '3.2.3'\tid 'io.spring.dependency-management' version '1.1.4'}group = 'com.example'version = '0.0.1-SNAPSHOT'java {\tsourceCompatibility = JavaVersion.VERSION_17\ttargetCompatibility = JavaVersion.VERSION_17}configurations {\tcompileOnly {\t\textendsFrom annotationProcessor\t}}repositories {\tmavenCentral()}dependencies {\timplementation 'org.springframework.boot:spring-boot-starter-web'\tcompileOnly 'org.projectlombok:lombok'\tdevelopmentOnly 'org.springframework.boot:spring-boot-devtools'\tannotationProcessor 'org.projectlombok:lombok'\ttestImplementation 'org.springframework.boot:spring-boot-starter-test'}tasks.named('test') {\tuseJUnitPlatform()} HelloController@Slf4j@RestControllerpublic class HelloController { @GetMapping public ResponseEntity&lt;String&gt; helloDocker() { log.info(\"hello docker!!!\"); return new ResponseEntity&lt;&gt;(\"hello! docker!\", HttpStatus.OK); }} 프로젝트 jar로 묶기 ./gradlew명령어를 사용하여 프로젝트를 jar파일로 내보내야 하는데 해당과정에서 자바 버전이랑 gradle 버전이 안맞으면 빌드가 안됨 윈도우를 사용함으로 시스템 환경설정에서 환경변수 셋팅후 java -version해서 나오는 버전이 gradle 버전과 맞게 성정 이번 경우에는 기존에 사용하던 jdk가 예상외로 작동해서 oracle jdk를 직접 받아서환경변수 설정 후 intellij를 관리자 모드로 실행, IDE내에서 터미널을 띄워서 진행 자바 버전 셋팅 후 gradlew 명령어 실행 프로젝트 루트에서 ./gradlew clean build 실행 후 build/libs 폴더 안에 jar 생성 확인 jar파일이 확인 되었다면 Dockerfile 작성Dockerfile FROM : 자바17을 사용함으로 17버전을 땡겨옴. VOLUME : 도커 컨테이너 내에서 생성된 데이터를 영속화 시킬 수 있게 해주는 Docker기능. 나중에 더 자세히 알아볼 예정 COPY : 이미지화 시킬 jar 파일을 app.jar로 카피한다 그런데 ./gradlew build 를 하면 jar파일이 2개가 생긴다 SNAPSHOT.jar : 실행 가능한 jar SNAPSHOT-plain.jar : 읽기 전용 jar 도커가 알아서 실행 가능한 jar를 묶어주는거 같긴하지만 build.gradle에서 읽기 전용 jar 생성 옵션을 설정할 수 있다 jar {enabled = false} ENTRYPOINT : 컨테이너로 올릴때에 어플리케이션이 실행될 포트 번호를 설정해주는 옵션을 추가하기 위한 설정이 더해진 옵션 참고 : https://spring.io/guides/topicals/spring-boot-docker FROM eclipse-temurin:17-jdk-alpineVOLUME /tmpCOPY build/libs/*.jar app.jarENTRYPOINT [\"sh\", \"-c\", \"java ${JAVA_OPTS} -jar /app.jar ${0} ${@}\"] docker build docker build -t spring-docker:v1 . 으로 빌드 후 이미지 확인 이미지 컨테이너화 시키기 docker run -d -p 9000:9000 spring-docker:v1 --server.port=9000 이미지에서 컨테이너를 생성할때 detached 모드로 실행하고 포트를 9000번 포트로 설정한다 실행 후 로그를 출력 확인 여러 프로젝트 띄워보기 docker stop $(docker stop -qa) : 명령어로 모든 컨테이너 종료 후 새로운 컨테이너 셋팅 spring1, spring2 컨테이너를 각각 다른 포트로 설정하여 띄워볼 예정 spring1 : server.port=8081 spring2 : server.port=8082 각각 다른 화면에 띄워 놓고 각 port에서 잘 동작 하는지 확인. 더 알아볼것 프로젝트 기능이 복잡해졌을때에는 어떤식으로 동작할지 volume을 사용해 어떤식으로 영속성 데이터를 얻을것인지, 로그 관리는 어떤 식으로 하는지 " }, { "title": "Spring, 이메일 인증 회원가입(4).", "url": "/posts/email_validate(4)/", "categories": "Spring", "tags": "back-end, spring, email sender", "date": "2024-03-03 19:00:00 +0900", "snippet": "이메일_인증_회원가입(3) 이번에 할것 토큰 인증 화면 구성(사용자에게 보내지는 메일을 꾸며주는 템플릿) 역할_권한 중간 테이블에 데이터 넣는 API추가 JavaMailSender 수정 템플릿에 포함된 내용을 UTF-8 형식으로 인코딩 하기 위한 설정 해당 설정을 안할시 한글이 깨져서 보인다 m...", "content": "이메일_인증_회원가입(3) 이번에 할것 토큰 인증 화면 구성(사용자에게 보내지는 메일을 꾸며주는 템플릿) 역할_권한 중간 테이블에 데이터 넣는 API추가 JavaMailSender 수정 템플릿에 포함된 내용을 UTF-8 형식으로 인코딩 하기 위한 설정 해당 설정을 안할시 한글이 깨져서 보인다 mailSender.setDefaultEncoding(\"UTF-8\") @Beanpublic JavaMailSender javaMailSender() { JavaMailSenderImpl mailSender = new JavaMailSenderImpl(); mailSender.setDefaultEncoding(\"UTF-8\"); mailSender.setHost(\"smtp.gmail.com\"); mailSender.setPort(587); mailSender.setUsername(USER_NAME); mailSender.setPassword(PASSWORD); mailSender.getJavaMailProperties().put(\"mail.smtp.starttls.enable\", \"true\"); return mailSender;} thymeleaf template engine 파싱할 thymeleaf 파일을 생성후 직접 값을 바인딩하여 해당 html을 내용으로하는 메일을 보내는 설정 private final TemplateEngine templateEngine 템플릿 엔진을 사용할 수 있도록 해주는 의존성 MimeMessage : 이메일에 텍스트, HTML, 첨부 파일 등 다양한 형식의 콘텐츠를 포함할 수 있도록 표준을 정의 new MimeMessageHelper(message, false) : 해당 생성자의 두번째 인자는 multipart사용을 명시한다. Context context = new Context() : thymeleaf에 바인딩할 값을 설정할 수 있게 해주는 클래스 ${title}과 같은 표현으로 타임리프에서 값을 바인딩 할 수 있게 해준다. templateEngine.process(\"/email/greeting\", context) /email/greeting 경로의 템플릿에 context를 넘겨서 반환할 html에 바인딩한다. @Slf4j@Service@RequiredArgsConstructorpublic class EmailSenderServiceImpl implements EmailSenderService { private final JavaMailSender javaMailSender; private final TemplateEngine templateEngine; @Override public boolean sendEmailTest(EmailSendDto emailSendDto) { MimeMessage message = javaMailSender.createMimeMessage(); try { MimeMessageHelper helper = new MimeMessageHelper(message, false); helper.setTo(emailSendDto.getToEmailAddress()); helper.setSubject(emailSendDto.getEmailTitle()); Context context = new Context(); context.setVariable(\"title\", emailSendDto.getEmailTitle()); context.setVariable(\"email\", emailSendDto.getToEmailAddress()); String htmlContent = templateEngine.process(\"/email/greeting\", context); helper.setText(htmlContent, true); javaMailSender.send(message); return true; } catch (MessagingException messagingException) { return false; } }} html&lt;!DOCTYPE html&gt;&lt;html lang=\"ko\" xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"/&gt; &lt;title&gt;Email Template&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"container\"&gt; &lt;h1 class=\"email-title\"&gt;이메일 타이틀 표시: &lt;span th:text=\"${title}\"&gt;기본 타이틀&lt;/span&gt;&lt;/h1&gt; &lt;p&gt;인증에 관련된 안내 ..... ToDO 토큰 부분을 확인하고 다시 체크한다.&lt;/p&gt; &lt;p&gt;수신자 : &lt;span class=\"email-address\" th:text=\"${email}\"&gt;example@google.com&lt;/span&gt;&lt;/p&gt; &lt;hr&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 테스트 컨트롤러@Slf4j@RestController@RequiredArgsConstructor@RequestMapping(path = \"/api/v1/email\")public class EmailController { private final EmailSenderService emailSenderService; @PostMapping(path = \"/test\") public ResponseEntity&lt;Boolean&gt; emailSendTest( @RequestBody EmailSendDto emailSendDto ) { boolean b = emailSenderService.sendEmailTest(emailSendDto); return new ResponseEntity&lt;&gt;(b, HttpStatus.OK); }} Role Authority 중간 테이블에 값 넣기 요청시 role_id와 authority_id를 Dto 형태의 리스트로 받아 insert하는 컨트롤러 생성 controller @Slf4j@RestController@RequiredArgsConstructor@RequestMapping(path = \"/api/v1/role-authority\")public class RoleAuthorityController { private final RoleAuthorityService roleAuthorityService; @PostMapping(path = \"/establish\") public ResponseEntity&lt;List&lt;RoleAuthorityDto&gt;&gt; givePermissionToAUser( @RequestBody List&lt;RoleAuthorityDto&gt; roleAuthorityDtoList ) { List&lt;RoleAuthorityDto&gt; roleAuthorityDtos = roleAuthorityService.insertRoleAuthority(roleAuthorityDtoList); log.info(\"roleAuthorityDtos = {}\", roleAuthorityDtos); return new ResponseEntity&lt;&gt;(roleAuthorityDtos, HttpStatus.OK); }} service 전달받은 Dto의 값을 검증하고 entity로 반환 후 실제 존재하는 값들에 대해 insert 진행 ToDO 원래 이렇게 코드가 길어지는지 알아보자 @Slf4j@Service@Transactional@RequiredArgsConstructorpublic class RoleAuthorityServiceImpl implements RoleAuthorityService { private final RolesRepository rolesRepository; private final AuthorityRepository authorityRepository; private final RoleAuthorityRepository roleAuthorityRepository; @Override public List&lt;RoleAuthorityDto&gt; insertRoleAuthority(List&lt;RoleAuthorityDto&gt; roleAuthorityDtoList) { List&lt;RoleAuthorityId&gt; roleAuthorityIds = roleAuthorityDtoList.stream().map(RoleAuthorityDto::toRoleAuthorityId).toList(); List&lt;RoleAuthority&gt; roleAuthorities = roleAuthorityIds.stream() .map(item -&gt; { Optional&lt;Authority&gt; findAuthority = authorityRepository.findById(item.getAuthorityId()); Optional&lt;Roles&gt; findRoles = rolesRepository.findById(item.getRoleId()); if (findAuthority.isPresent() &amp;&amp; findRoles.isPresent()) { Authority authority = findAuthority.get(); Roles roles = findRoles.get(); RoleAuthorityId id = new RoleAuthorityId(roles.getRoleId(), authority.getAuthorityId()); return new RoleAuthority(id, roles, authority); } return null; }) .filter(Objects::nonNull) .toList(); List&lt;RoleAuthority&gt; resultList = roleAuthorityRepository.saveAll(roleAuthorities); return resultList.stream().map(RoleAuthority::toDto).toList(); }} 전체 데이터 생성 후 역할 권한이 연결된 데이터 확인 SELECT\t*from users uinner join roles r ON r.role_id = u.role_idinner join role_auth ra ON ra.role_id = r.role_idinner join authorities a ON a.authority_id = ra.authority_idwhere user_id = 41; api 목록 확인 다음에 할 것 이메일 검증시 사용할 토큰 설계 이메일 검증 방식 세우기 이메일 검증 API 만들기 이메일 검증 플로우 문서화 시키기 " }, { "title": "Docker(5)", "url": "/posts/docker(5)/", "categories": "Docker", "tags": "docker, docker cp, naming", "date": "2024-03-03 16:40:00 +0900", "snippet": "Docker(4) docker cp 로컬 데이터를 컨테이너 내부로 옮기기, 컨테이너의 데이터 로컬로 옮기기 docker cp dummy/. container:/foldername 명령줄이 실행중인 경로에서 dummy/. 파일들을 container이름의컨테이너의/foldername으로 옮긴다 이때 컨테이너 내부에 해당 폴더가...", "content": "Docker(4) docker cp 로컬 데이터를 컨테이너 내부로 옮기기, 컨테이너의 데이터 로컬로 옮기기 docker cp dummy/. container:/foldername 명령줄이 실행중인 경로에서 dummy/. 파일들을 container이름의컨테이너의/foldername으로 옮긴다 이때 컨테이너 내부에 해당 폴더가 없으면 자동으로 생성된다 반대로 컨테이너의 데이터를 옮기고 싶으면 docker cp sweet_chatelet:/test dummy 명령어 사용 docker cp 명령어는 2개의 인자를 받는다 생각하자 그러나 해당 명령을 사용해 프로그램에 변경을 주려는 작업은 리스크가 큼으로 컨테이너 내부의 로그 파일을 옮기는 용도 외에는 사용하지 말자 images, container naming container docker run -p 3000:80 -d --rm --name node_app 156606f9262a --name 명령어 뒤에 사용할 컨테이너 이름과 이미지 아이디를 넣는다. --rm 이미지를 컨테이너에 올리고 바로 실행 시킨다. images 이미지의 레포지토리 이름과 버전을 명시해야 함으로 name과 tag를 갖는 name:tag와 같은 구성을 갖는다. docker build -t note_app:latest . " }, { "title": "Spring, 이메일 인증 회원가입(3).", "url": "/posts/email_validate(3)/", "categories": "Spring", "tags": "back-end, spring, email sender", "date": "2024-03-03 15:01:00 +0900", "snippet": "이메일_인증_회원가입(2) 이번에 할것 Email 서비스 연동 데이터 생성 API 만들기 유저 권한 부여 API 만들기 POST MAN 문서 작성 틀 잡기 spring doc 설정 Email 서비스 연동 회원가입시 이메일로 특정 키값을 보내고 해당 키를 인증하면 회원가입이 최종적으로 ...", "content": "이메일_인증_회원가입(2) 이번에 할것 Email 서비스 연동 데이터 생성 API 만들기 유저 권한 부여 API 만들기 POST MAN 문서 작성 틀 잡기 spring doc 설정 Email 서비스 연동 회원가입시 이메일로 특정 키값을 보내고 해당 키를 인증하면 회원가입이 최종적으로 완료 되게 하는 서비스 구성 발신_주체_설정_참고_포스팅 google-email 설정 부분만 참고하고 나머지 기능설정은 다르게 진행 application.properties 를 이용한 구성을 분리하여 직접 @Bean으로 등록 @Slf4j@Configuration@RequiredArgsConstructorpublic class ProjectConfig { @Value(\"${spring.mail.service.username}\") private String USER_NAME; @Value(\"${spring.mail.service.password}\") private String PASSWORD; @Bean public JavaMailSender javaMailSender() { JavaMailSenderImpl mailSender = new JavaMailSenderImpl(); mailSender.setHost(\"smtp.gmail.com\"); mailSender.setPort(587); mailSender.setUsername(USER_NAME); mailSender.setPassword(PASSWORD); mailSender.getJavaMailProperties().put(\"mail.smtp.starttls.enable\", \"true\"); return mailSender; }} 작업시 필요한 데이터를 생성하기 위한 엔드 포인트 생성 유저 생성 API 역할 생성 API 권한 생성 API 유저에게 역할을 부여하는 API 역할에 권한들을 부여하는 API 데이터 생성 API 단순 데이터 생성 insertUser(@RequestParam(\"size\") int size) 입력받은 사이즈만큼 User 데이터를 생성하고 생성된 User 리스트를 UserDto로 반환해서 리턴 insertRoles(@RequestBody RequestBodyContainer&lt;List&lt;String&gt;&gt; roleNameList) 역할 이름을 문자열 형태의 리스트로 입력받고 생성된 Roles 리스트를 그대로 리턴 ToDo 추후 RolesDto를 반환하는것으로 수정 insertAuthority(@RequestBody List&lt;AuthorityDto&gt; authorityList) 권한 목록을 입력받고 생성된 Authority 리스트를 그대로 리턴 ToDo 추후 AuthorityDto를 반환하는것으로 수정 @Slf4j@RestController@RequiredArgsConstructor@RequestMapping(path = \"/api/v1/init-data\")public class InitDataController { private final CommonUtilService commonUtilService; @GetMapping(path = \"/insert-users\") public List&lt;UserDto&gt; insertUser(@RequestParam(\"size\") int size) { List&lt;User&gt; userList = commonUtilService.insertRandomUser(size); log.info(\"init-data controller user list = {}\", userList); return userList.stream().map(User::toDto).collect(Collectors.toList()); } @PostMapping(path = \"/insert-roles\") public List&lt;Roles&gt; insertRoles(@RequestBody RequestBodyContainer&lt;List&lt;String&gt;&gt; roleNameList) { List&lt;Roles&gt; roles = commonUtilService.insertRole(roleNameList.getData()); log.info(\"init-data controller roles list = {}\", roles); return roles; } @PostMapping(path = \"/insert-authorities\") public List&lt;Authority&gt; insertAuthority(@RequestBody List&lt;AuthorityDto&gt; authorityList) { List&lt;Authority&gt; authorities = commonUtilService.insertAuthority(authorityList); log.info(\"init-data controller authorities = {}\", authorities); return authorities; } @Getter @Setter @NoArgsConstructor @AllArgsConstructor public static class RequestBodyContainer&lt;T&gt; { private T data; }} 유저 역할 부여 API 해당 API 는 추후 서비스에 필요한 로직이라 따로 분리 givePermissionToAUser(@RequestBody UserDto.GivePermission givePermission) 유저의 이메일과 권한의 이름을 입력받아 유저와 권한이 둘다 존재하면 유저에 역할 연결 @Slf4j@RestController@RequiredArgsConstructor@RequestMapping(path = \"/api/v1/user\")public class UserController { private final UserService userService; @PostMapping(path = \"/give-permission\") public ResponseEntity&lt;UserDto&gt; givePermissionToAUser(@RequestBody UserDto.GivePermission givePermission) { UserDto userDto = userService.givePermissionToAUser(givePermission); return new ResponseEntity&lt;&gt;(userDto, HttpStatus.OK); }} givePermissionToAUser() 구현체 User를 직접 반환 하려고 하면 no-session에러 발생 서비스단에서 리턴할 때에는 Dto로 변환하여 넘겨주자! @Overridepublic UserDto givePermissionToAUser(UserDto.GivePermission givePermission) { String userEmail = givePermission.getUserEmail(); String roleName = givePermission.getRoleName(); Optional&lt;User&gt; findUser = userRepository.findUserByUserEmail(userEmail); Optional&lt;Roles&gt; findRoles = rolesRepository.findRolesByRoleName(roleName); if (findUser.isPresent() &amp;&amp; findRoles.isPresent()) { User user = findUser.get(); Roles role = findRoles.get(); user.setRoles(role); User result = userRepository.save(user); log.info(\"result = {}\", result); return result.toDto(); } else { return null; // ToDO 예외 처리 부분을 구체화 한다. }} POST MAN 문서 구성 ToDO : happy, sad 케이스에 대한 폴더를 구분하여 문서화한다. spring docs 설정 implementation 'org.springdoc:springdoc-openapi-starter-webmvc-ui:2.0.2' 해당 의존성 추가 스프링 시큐리티를 활성화했음으로 spring docs에서 지원하는 리소스를 permitAll()해야함. 추가적으로 ignoreing()에도 추가 ToDO : swagger를 통해 API에 디테일한 설정을 추가해보자 SecurityConfig 코드@Slf4j@Configuration@EnableWebSecurity@RequiredArgsConstructorpublic class WebSecurityConfig { private final CustomAuthenticationProvider customAuthenticationProvider; private static final String[] AUTH_WHITELIST = { \"/api/**\", \"/swagger-ui/**\", \"/api-docs\", \"/swagger-ui-custom.html\", \"/v3/api-docs/**\", \"/api-docs/**\", \"/swagger-ui.html\" }; @Bean public SecurityFilterChain defaultSecurityFilterChain(HttpSecurity http) throws Exception { http .cors(AbstractHttpConfigurer::disable) .csrf(AbstractHttpConfigurer::disable) .authenticationProvider(customAuthenticationProvider) .authorizeHttpRequests( (requests) -&gt; requests .requestMatchers(AUTH_WHITELIST).permitAll() .requestMatchers(\"/api/v*/**\").permitAll() .anyRequest().permitAll() ) .formLogin(withDefaults()) .httpBasic(withDefaults()); return http.build(); } @Bean public WebSecurityCustomizer webSecurityCustomizer() { return (web) -&gt; web.ignoring().requestMatchers(AUTH_WHITELIST); }} 다음에 할것 역할_권한 중간 테이블에 데이터 넣는 API추가 토큰 인증 화면 구성(사용자에게 보내지는 메일을 꾸며주는 템플릿) email-token관련 Entity추가 및 security 인증 로직 수정 " }, { "title": "Spring, 이메일 인증 회원가입(2).", "url": "/posts/email_validate(2)/", "categories": "Spring", "tags": "back-end, spring, email sender", "date": "2024-03-02 19:10:00 +0900", "snippet": "이메일_인증_회원가입(1) 이번에 할것 기초 데이터 셋팅을 위한 유틸 서비스 구성 기초 데이터 셋팅을 위한 유틸 서비스 구성 프로젝트를 할때마다 기초 데이터를 셋팅하는것에 고민이 많아서 구성하게됨 랜덤하게 유저를 생성해주는 API가 있어서 openfeign으로 호출 후 필요한 부분만 파싱해서 사용할 예정 ...", "content": "이메일_인증_회원가입(1) 이번에 할것 기초 데이터 셋팅을 위한 유틸 서비스 구성 기초 데이터 셋팅을 위한 유틸 서비스 구성 프로젝트를 할때마다 기초 데이터를 셋팅하는것에 고민이 많아서 구성하게됨 랜덤하게 유저를 생성해주는 API가 있어서 openfeign으로 호출 후 필요한 부분만 파싱해서 사용할 예정 랜덤 유저 생성 api : https://randomuser.me/api/ 리스폰스 되는 데이터 확인 아래와 같은 데이터 형태로 옴 다음과 같이 여러 데이터를 제공해 주는데 주목해야할 부분은 results 부분이 List로 되어있다는 것해당 부분을 유의해서 필요한 데이터를 파싱할 수 있도록 DTO 작성 json 데이터{\"results\":[{ \"gender\":\"female\", \"name\":{ \"title\":\"Miss\", \"first\":\"Kylie\", \"last\":\"Scott\" }, \"location\":{ \"street\":{ \"number\":5964, \"name\":\"Dogwood Ave\" }, \"city\":\"Bunbury\", \"state\":\"Victoria\", \"country\":\"Australia\", \"postcode\":8739, \"coordinates\":{ \"latitude\":\"-83.5762\", \"longitude\":\"53.2443\" }, \"timezone\":{ \"offset\":\"+4:00\", \"description\":\"Abu Dhabi, Muscat, Baku, Tbilisi\" } }, \"email\":\"kylie.scott@example.com\", \"login\":{ \"uuid\":\"8d09923d-ffea-443a-ac90-3c8271b2a2af\", \"username\":\"angryelephant778\", \"password\":\"marjorie\", \"salt\":\"95PqnQiV\", \"md5\":\"12e6713e3800d265d0c0c2e4c33a1cee\", \"sha1\":\"9c0d12afd1b0fd10adf27ccfe9d1be63a5f52ab8\", \"sha256\":\"b3c6c90c745dc4a5fd14de8a4c7eb9a5a1e5dba88e1d3e2b2d5cd2bcda7a45d4\" }, \"dob\":{ \"date\":\"1974-05-06T08:34:53.563Z\", \"age\":49 }, \"registered\":{ \"date\":\"2005-09-02T15:42:51.922Z\", \"age\":18 }, \"phone\":\"00-7161-6910\", \"cell\":\"0401-794-305\", \"id\":{ \"name\":\"TFN\", \"value\":\"390761861\" }, \"picture\":{ \"large\":\"https://randomuser.me/api/portraits/women/42.jpg\", \"medium\":\"https://randomuser.me/api/portraits/med/women/42.jpg\", \"thumbnail\":\"https://randomuser.me/api/portraits/thumb/women/42.jpg\" }, \"nat\":\"AU\" }], \"info\":{ \"seed\":\"294d6bf7956e1b52\", \"results\":1, \"page\":1, \"version\":\"1.4\" }} 파싱할 Dto 당장 필요하지 않아도 추후에 필요할거같은 필드들을 담아서 파싱. @Getter@ToString@NoArgsConstructor@AllArgsConstructorpublic class RandomUserMe { private List&lt;Result&gt; results; @Getter @ToString @NoArgsConstructor @AllArgsConstructor public static class Result { private String gender; private String email; private Name name; private Login login; private Picture picture; public UserDto toUserDto() { return UserDto.builder() .userEmail(email) .password(login.password) .build(); } @Getter @ToString @NoArgsConstructor @AllArgsConstructor static class Name { private String title; private String first; private String last; } @Getter @ToString @NoArgsConstructor @AllArgsConstructor static class Login { private String uuid; private String username; private String password; } @Getter @ToString @NoArgsConstructor @AllArgsConstructor static class Picture { private String large; private String medium; private String thumbnail; } }} gateway openfeign_사용해보기 openfeign 구성 RandomUserMe makeRandomUser(@RequestParam(\"results\") int result) 파라미터에 제공받을 리스트 사이즈를 명시하면 해당 사이즈만큼 리스트를 리턴해준다 @FeignClient(name = \"random-user-gateway\", url = \"https://randomuser.me/api/\")public interface RandomUserGateway { @GetMapping RandomUserMe makeRandomUser(); @GetMapping RandomUserMe makeRandomUser(@RequestParam(\"results\") int result);} 해당 서비스를 공통 서비스로 빼기public interface CommonUtilService { RandomUserMe getRandomUser();}@Slf4j@Component@RequiredArgsConstructorpublic class CommonUtilServiceImpl implements CommonUtilService { private final RandomUserGateway randomUserGateway; @Override public RandomUserMe getRandomUser() { RandomUserMe randomUserMe = randomUserGateway.makeRandomUser(10); log.info(\"randomUserMe = {}\", randomUserMe); log.info(\"random user me size = {}\", randomUserMe.getResults().size()); return randomUserMe; }} 프로젝트 실행시 자동으로 insert 되게 설정 spring 프로젝트를 빌드할때 모든 의존성이 설정된 후 초기 설정을 통해 유저 정도를 넣기 위한 작업 해당 작업에는 크게 2가지 방법으로 할 수 있음 @PostConstruct를 활용한 방법 CommandLineRunner인터페이스를 구현하여 사용하는 방법 클래스 레밸에서 관리하기가더 수월하게 하기 위해 두번째 방법으로 구성. @Slf4j@Component@RequiredArgsConstructorpublic class CustomRunnable implements CommandLineRunner { private final CommonUtilService commonUtilService; private final UserRepository userRepository; @Override public void run(String... args) throws Exception { List&lt;RandomUserMe.Result&gt; randomUserList = getRandomUserList(); List&lt;User&gt; userList = randomUserList.stream() .map(RandomUserMe.Result::toUserDto) .map(UserDto::toEntity) .collect(Collectors.toList()); userRepository.saveAll(userList); } private List&lt;RandomUserMe.Result&gt; getRandomUserList() { return commonUtilService.getRandomUser().getResults(); }} 설정하고 프로젝트를 실행하면 데이터가 적재되는걸 볼 수 있다. 알아볼것 1. @LastModifiedBy, @CreatedBy 설정 알아볼것 2. jpa로 bulk insert하는 방식 다음에 할것 Email 서비스 연동 " }, { "title": "Spring, 이메일 인증 회원가입(1).", "url": "/posts/email_validate(1)/", "categories": "Spring, Jpa", "tags": "back-end, spring, jpa, entity mapping", "date": "2024-03-02 14:30:00 +0900", "snippet": " 회원 가입시 이메일을 인증받아 회원가입시키는 흐름 구성 프로젝트 셋팅 user, role, role_authority, role 테이블 구성 기초 데이터 셋팅을 위한 유틸 서비스 구성 Email 서비스 연동 security 인증 단계에서 이메일 인증이 진행 중인 상태에 따라 회원가입 플로우 진행 ...", "content": " 회원 가입시 이메일을 인증받아 회원가입시키는 흐름 구성 프로젝트 셋팅 user, role, role_authority, role 테이블 구성 기초 데이터 셋팅을 위한 유틸 서비스 구성 Email 서비스 연동 security 인증 단계에서 이메일 인증이 진행 중인 상태에 따라 회원가입 플로우 진행 프로젝트 셋팅 및 테이블과 Entity 구성 프로젝트 환경 java17, spring boot 3.2.3 build.gradle : 주요 설정 DAO : spring-boot-starter-data-jpa DB 접근 기술 Email : spring-boot-starter-mail 이메일 서비스 Security : spring-boot-starter-security 보안 설정 tamplate-engine : spring-boot-starter-thymeleaf 템플릿 설정 gateway : spring-cloud-starter-openfeign 외부 서버와 통신을 위한 설정 database : com.mysql:mysql-connector-j mysql 사용 plugins { id 'java' id 'org.springframework.boot' version '3.2.3' id 'io.spring.dependency-management' version '1.1.4'}group = 'org.spring.oauth2'version = '0.0.1-SNAPSHOT'java { sourceCompatibility = '17'}configurations { compileOnly { extendsFrom annotationProcessor }}repositories { mavenCentral()}ext { set('springCloudVersion', \"2023.0.0\")}dependencies { implementation 'org.springframework.boot:spring-boot-starter-data-jpa' implementation 'org.springframework.boot:spring-boot-starter-mail' implementation 'org.springframework.boot:spring-boot-starter-security' implementation 'org.springframework.boot:spring-boot-starter-thymeleaf' implementation 'org.springframework.boot:spring-boot-starter-web' implementation 'org.thymeleaf.extras:thymeleaf-extras-springsecurity6' implementation 'org.springframework.cloud:spring-cloud-starter-openfeign' compileOnly 'org.projectlombok:lombok' runtimeOnly 'com.mysql:mysql-connector-j' annotationProcessor 'org.projectlombok:lombok' testAnnotationProcessor 'org.projectlombok:lombok' testImplementation 'org.projectlombok:lombok' testImplementation 'org.springframework.boot:spring-boot-starter-test' testImplementation 'org.springframework.security:spring-security-test'}dependencyManagement { imports { mavenBom \"org.springframework.cloud:spring-cloud-dependencies:${springCloudVersion}\" }}tasks.named('test') { useJUnitPlatform()} 유저, 역할, 역활_권한, 권한 테이블 설계 MappedSuperclass, BaseEntity 공통 테이블 컬럼 정의 @MappedSuperclass : 부모 클래스 정의 @EntityListeners(AuditingEntityListener.class) : @CreatedDate, @LastModifiedDate : 다음과 같은 어노테이션이 동작할수 있도록 하는 어노테이션 @Getter@Setter@MappedSuperclass@EntityListeners(AuditingEntityListener.class)public abstract class BaseEntity { @Column(name = \"created_by\") private String createdBy; @CreatedDate @Column(name = \"created_date\") private LocalDateTime createdDate; @Column(name = \"last_modified_by\") private String lastModifiedBy; @LastModifiedDate @Column(name = \"last_modified_date\") private LocalDateTime lastModifiedDate; @Column(name = \"used\") private boolean used;}User UserDetails를 구현하여 실제 검증할때 해당 Entity를 사용할 수 있게 설정. Security를 통한 인증, 인가 부분을 구현하면서 바뀌는 부분이 많아질 예정, 딱히 설명할부분은 없다. @Getter@Entity@Table(name = \"users\")@NoArgsConstructor(access = AccessLevel.PROTECTED)public class User extends BaseEntity implements UserDetails { @Id @Column(name = \"user_id\") @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @Column(name = \"password\", nullable = false) private String password; @Column(name = \"user_email\", nullable = false, unique = true) private String userEmail; @ColumnDefault(\"1\") @Column(name = \"account_non_expired\", nullable = false) private boolean accountNonExpired; @ColumnDefault(\"1\") @Column(name = \"account_non_locked\", nullable = false) private boolean accountNonLocked; @ColumnDefault(\"1\") @Column(name = \"credentials_non_expired\", nullable = false) private boolean credentialsNonExpired; @ColumnDefault(\"1\") @Column(name = \"enabled\", nullable = false) private boolean enabled; @ManyToOne(fetch = LAZY) @JoinColumn(name = \"role_id\") private Roles roles; public User(String userEmail, String password) { this.userEmail = userEmail; this.password = password; this.accountNonExpired = true; this.accountNonLocked = true; this.credentialsNonExpired = true; this.enabled = true; } @Override public String toString() { return \"User{\" + \"password='\" + password + '\\'' + \", userEmail='\" + userEmail + '\\'' + '}'; } @Override public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() { return roles.getRoleAuthorities().stream() .map(a -&gt; new SimpleGrantedAuthority( a.getAuthorityId().getAuthorityName() )).collect(Collectors.toList()); } @Override public String getPassword() { return this.password; } @Override public String getUsername() { return this.userEmail; } @Override public boolean isAccountNonExpired() { return this.accountNonExpired; } @Override public boolean isAccountNonLocked() { return this.accountNonLocked; } @Override public boolean isCredentialsNonExpired() { return this.credentialsNonExpired; } @Override public boolean isEnabled() { return this.enabled; }}Roles 역할 테이블, 유저의 역할을 매핑하기 위함@Entity@Getter@Table(name = \"roles\")@NoArgsConstructor(access = AccessLevel.PROTECTED)public class Roles extends BaseEntity { @Id @Column(name = \"role_id\") @GeneratedValue(strategy = GenerationType.IDENTITY) private Long roleId; @Column(name = \"role_name\", unique = true, nullable = false) private String roleName; @OneToMany(mappedBy = \"roles\", fetch = LAZY) private List&lt;User&gt; users = new ArrayList&lt;&gt;(); @OneToMany(mappedBy = \"roleId\", fetch = LAZY) private List&lt;RoleAuthority&gt; roleAuthorities = new ArrayList&lt;&gt;();}RoleAuthority 역할과 권한을 중간에서 연결해주는 중간 테이블, 외래키를 복합키로 갖게되는 구조가 된다. @EmbeddedId 복합키를 사용할 때 쓰이는 어노테이션 자매품으로 @IdClass가 있지만 여기서는 @EmbeddedId 사용 @Entity@Getter@Table(name = \"role_auth\")@NoArgsConstructor(access = AccessLevel.PROTECTED)public class RoleAuthority extends BaseEntity { @EmbeddedId private RoleAuthorityId id; @MapsId(\"roleId\") @ManyToOne(fetch = LAZY) @JoinColumn(name = \"role_id\") private Roles roleId; @MapsId(\"authorityId\") @ManyToOne(fetch = LAZY) @JoinColumn(name = \"authority_id\") private Authority authorityId;} EmbeddedId@Getter@Embeddable@NoArgsConstructor@AllArgsConstructorpublic class RoleAuthorityId implements Serializable { private Long roleId; private Long authorityId;}Authority 권한들이 들어가게 되는 테이블 딱히 설명할게 없다.@Entity@Getter@Table(name = \"authorities\")@NoArgsConstructor(access = AccessLevel.PROTECTED)public class Authority extends BaseEntity { @Id @Column(name = \"authority_id\") @GeneratedValue(strategy = GenerationType.IDENTITY) private Long authorityId; @Column(name = \"authority_name\", nullable = false, unique = true) private String authorityName; @Column(name = \"end_point\", nullable = false) private String endPoint; @OneToMany(mappedBy = \"authorityId\", fetch = LAZY) private List&lt;RoleAuthority&gt; roleAuthorities = new ArrayList&lt;&gt;();} 다음에 할것 기초 데이터 셋팅을 위한 유틸 서비스 구성 " }, { "title": "Docker(4)", "url": "/posts/docker(4)/", "categories": "Docker", "tags": "docker, Dockerfile, attached, detached", "date": "2024-03-02 12:20:00 +0900", "snippet": "Docker(3) 간단한 파이썬 파일 이미지화 시키기 사용자의 입력을 받고 상호 작용하는 프로그램 이미지화 시키기 테스트를 위한 간단한 파이썬 프로그램 작성, 사용자의 입력을 받아 최소~최대 범위에서 랜덤한 숫자를 뽑아주는 프로그램 Python 코드from random import randint_min = int(inp...", "content": "Docker(3) 간단한 파이썬 파일 이미지화 시키기 사용자의 입력을 받고 상호 작용하는 프로그램 이미지화 시키기 테스트를 위한 간단한 파이썬 프로그램 작성, 사용자의 입력을 받아 최소~최대 범위에서 랜덤한 숫자를 뽑아주는 프로그램 Python 코드from random import randint_min = int(input('최소값을 입력 하세요 : '))_max = int(input('최대값을 입력 하세요 : '))if (_max &lt; _min): print('최대값은 최소값보다 작은 수 없습니다.')else: _random = randint(_min, _max) print(_random) Dockerfile 코드 python 이미지를 가져오고 간단한 설정이후 rng.py를 실행하게 구성후 docker build . 으로 이미지 빌드 FROM pythonWORKDIR /appCOPY . /appCMD [\"python\",\"rng.py\"]&lt;none&gt; &lt;none&gt; 39544f4abf90 26 seconds ago 1.02GB docker run images_name, attached 모드로 실행 실행 결과 사용자와 상호 작용을 할 수 있게 설정해주는 부분이 없어서 해당 에러 발생 사용자의 입력을 받게 하려면 -i,-t 명령어를 docker run 할때 붙여줘야한다. docker start detached 모드로 실행 그렇다면 docker start를 이용해서 컨테이너를 실행시킬때에는 어떤식으로 동작하게 될까 detached모드로 실행되면서 상호작요을 할 수 없게 실행됨, docker attach [container_name]로 접속 해보면 프로세스의 일부분이 생략된체 상호작용을 할수 있게 동작 최소값을 입력 하세요 : 문구 출력 부분이 사라져있음. 근본적인 해결책이 아님 이런식으로 상호작용을 할때에는 docker start [container_name] 으로 실행할때 start 뒤에 -i 명령어를붙여주면됨docker start -t [container_name]«««&lt; HEAD 이런식으로 상호작용을 할때에는 docker start [container_name] 으로 실행할때 start 뒤에 -i 명령어를 붙여주면됨docker start -t [container_name]" }, { "title": "Docker(3)", "url": "/posts/docker(3)/", "categories": "Docker", "tags": "docker, Dockerfile, attached, detached", "date": "2024-03-02 10:50:00 +0900", "snippet": "Docker(2) Dockerfile, Cache? FROM node:14.9.0 # 1WORKDIR /app # 2 COPY . /app # 3RUN npm install # 4EXPOSE 80 # 5CMD [\"node\",\"server.js\"] # 6 코드상의 사소한 변경사형을 image로 build하려면 npm install과 같이 시간...", "content": "Docker(2) Dockerfile, Cache? FROM node:14.9.0 # 1WORKDIR /app # 2 COPY . /app # 3RUN npm install # 4EXPOSE 80 # 5CMD [\"node\",\"server.js\"] # 6 코드상의 사소한 변경사형을 image로 build하려면 npm install과 같이 시간이 오래 걸리는 프로세스를 실행시켜 작업자를 까다롭게 만들 수 있음. 이러한 문제를 해결하기 위해 Docker에서는 파일들을 비교하여 변경 사항이 있는 layer에 대해서만 다시 작업 예를 들어 위의 Dockerfile 에서 EXPOSE 부분의 변경 사항만 적용한 새로운 이미지 레이어를 생성. 이를 통해 Dockerfile의 최적화 진행 가능 변경된 Dockerfile 기존에 설정되었던 COPY . /app 부분은 폴더의 전체 범위의 변경사항을 캐쉬함으로 레이어를 분리하여 최적화 가능. package.json파일에 변경 사항이 있다면 그 아래에 있는 RUN npm install을 실행하겠다는 의미로 해석됨. COPY package.json /appFROM node:14.9.0WORKDIR /appCOPY package.json /appRUN npm installCOPY . /appEXPOSE 80CMD [\"node\",\"server.js\"]실행중인 컨테이너의 로그 확인하기 로그를 심어놓은 부분.app.post('/store-goal', (req, res) =&gt; { const enteredGoal = req.body.goal; console.log(enteredGoal); // 해당 부분. userGoal = enteredGoal; res.redirect('/');}); 위와 같이 이미지를 빌드하였을때 도대체 어디서 로그를 확인할 수 있는걸까? 도커는 연결모드(Attached)와 분리모드(Detached)모드를 지원한다. docker run 모드인 경우 기본적으로 연결모드 지원 docker start 모드인 경우 기본적으로 분리모드 지원 연결모드, 분리모드 연결 모드 컨테이너의 출력결과를 수신할 수 있게 해주는 모드 이미지를 빌드할때 첫 항상 연결모드로 실행 분리 모드 컨테이너의 출력결과를 연결해서 보지않겠다는 모드 docker run에서 해당 설정을 분리모드로 변경하려면 -d 명령어를 붙이면 된다 docker run -p [local:container] -d [image_name] 이미 실행된 컨테이너를 attached모드로 보고 싶다면 실행된 컨테이너를 attach하면된 docker attach [container_name] 컨테이너의 로그 보기 컨테이너 실행동안 출력된 과거 로그 메세지들을 확인하려면 docker logs [container_name] 명령어 사용 logs -f 다음과 같이 logs명령어 뒤에 -f를 붙이면 로그 출력후 attached 모드로 작업 가능. " }, { "title": "Docker(2)", "url": "/posts/docker(2)/", "categories": "Docker", "tags": "docker, Dockerfile", "date": "2024-03-01 22:00:00 +0900", "snippet": "Docker(1) 간단한 node project image로 찍어내기 Dockerfile FROM node:14.9.0 # 1WORKDIR /app # 2 COPY . /app # 3RUN npm install # 4EXPOSE 80 # 5CMD [\"node\",\"server.js\"] # 6 #1 : 해당 프로젝트를 구동 시키는데 필요한 이...", "content": "Docker(1) 간단한 node project image로 찍어내기 Dockerfile FROM node:14.9.0 # 1WORKDIR /app # 2 COPY . /app # 3RUN npm install # 4EXPOSE 80 # 5CMD [\"node\",\"server.js\"] # 6 #1 : 해당 프로젝트를 구동 시키는데 필요한 이미지를 가져온다. 여기에서는 node 14.9.0 버전을 사용하였음 #2 : 도커 컨테이너의 작업 폴더를 설정한다 /app 도커 컨테이너 안의 프로젝트 경로를 해당 루트로 잡는다고 생각하면 될거같다. #3 : 어떤 프로젝트를 이미지로 만들것인지 설정한다 COPY 뒤에 2개의 경로를 설정할 수 있다. 첫번째 경로 : 내가 이미지화 시킬 폴더의 경로응 Dockerfile위치를 기준으로 설정한다 두번째 경로 : 도커 컨테이너 안에 /app 폴더안에 첫번째 경로에 있는 파일을 복사한다고 생각하면 될거같다. #4 : 이미지 구성이 끝나고 추가적으로 실행되어야할 스크립트를 작성한다. 여러개의 이미지가 빌드될때 한번만 실행되어야할 스크립트를 작성한다. #5 : 컨테이너 내부에서 사용할 포트를 설정한다. -public 포트 뒤에 붙는 경로를 설정할 수 있게 해주는 부분 docker run -p [local-port]:[container-port] [image-name] 이런 식으로 설정하면 local-port로 접근할시 도커 내부 포트로 연결되게 설정된다. #6 : #5[RUN]은 이미지를 run할때 실행되는 스크립트라고 한다면 CMD는 컨테이너가 실행될때 실행하는 스크립트이다 여기에서는 컨테이너가 띄워질때 노드 서버도 같이 실행을 시켜야 하기 때문에 설정 docker build . 설정한 도커파일 설정으로 image를 만드는 명령어 docker build 뒤에 붙는 .는 도커 파일의 위치를 나타낸다 여기에서는 현위치에 있는 도커 파일을 가르킨다. REPOSITORY TAG IMAGE ID CREATED SIZE &lt;none&gt; &lt;none&gt; 72e5231de146 2 hours ago 949MB 이미지 컨테이너에 올리기 이렇게 작성된 이미지를 컨테이너에 올리면 구성이 완료된다. docker run imagename 이런식으로 올린후 접속을 하게되면 아래와 같은 현상이 발생한다. 그 이유는 local에서 접속할 포트 설정을 안해줬기때문 Dockerfile 에서 EXPOSE 설정은 컨테이너 포트임 해당 포트에 연결할 로컬 포트를 run할때 설정해 줘야 한다. docker run -p 3000:80 imagename 이런식으로 설정하면 3000포트로 접속이 가능해짐 " }, { "title": "Docker(1)", "url": "/posts/docker(1)/", "categories": "Docker", "tags": "docker, images, containers", "date": "2024-03-01 19:00:00 +0900", "snippet": " Images Container를 위한 템플릿과 프레임 Container를 실행시킬때 필요한것들을 포함한다. 마치 자바의 클래스와 같음 직접 Image를 구성해서 사용할수도 있고 구성된 이미지를 가져다 사용할 수 있음. Containers Images 클래스를 인스턴스 하는것과 같은 느낌 실제로 실행시키는 주체가된다. 하나의 이미지로 여...", "content": " Images Container를 위한 템플릿과 프레임 Container를 실행시킬때 필요한것들을 포함한다. 마치 자바의 클래스와 같음 직접 Image를 구성해서 사용할수도 있고 구성된 이미지를 가져다 사용할 수 있음. Containers Images 클래스를 인스턴스 하는것과 같은 느낌 실제로 실행시키는 주체가된다. 하나의 이미지로 여러개의 인스턴스를 생성할 수 있는것도 위와 같은 개념에 포함. node 도커에 올려보기 이미지 찾기 : docker search node 이미지 다운로드 : docker pull node docker pull node xxx : xxx 부분에 버전을 명시할 수 있음 명시하지 않을시 최신 버전으로 땡겨옴 이미지 찾기 : docker images 내가 가지고 있는 모든 이미지를 가져올 수 있음REPOSITORY TAG IMAGE ID CREATED SIZEnode latest 1b9d5f3b36bf 2 weeks ago 1.1GBmysql latest 56b21e040954 6 weeks ago 632MBredis alpine 287766fc4fcf 7 weeks ago 41MB 이미지 컨테이너로 올리기 : docker run node 컨테이너 목록 가져오기 : docker ps -a 컨테이너 실행시키기 : docker start [container-name] 이렇게 실행시키면 컨테이너가 올라갔다가 바로 종료됨. 그 이유는 컨테이너가 격리되어 실행되기 때문. 컨테이너에 의해 사용자에게 대화형 셀을 노출할 수 있도록 설정해야함 대화형 쉘 노출 시키기 : -it, 이미지를 띄울때 명령어 추가 : docker run -it node 해당 명령어로 대화형 셀이 실행중일때에 컨테이너가 활성화가 되는걸 볼 수 있음. " }, { "title": "Spring, Openfeign(2)", "url": "/posts/spring_openfeign(2)/", "categories": "Spring, Openfeign", "tags": "back-end, spring, open feign", "date": "2024-03-01 16:40:00 +0900", "snippet": " openfeign 테스트를 하기 위한 response-server과 request-server 생성 response-server : 요청시 다양한 형태의 응답을 주는 end-point들을 생성 request-server : 다양한 요청 방식으로 response-server에 end-point를 호출하는 gateway 서비스...", "content": " openfeign 테스트를 하기 위한 response-server과 request-server 생성 response-server : 요청시 다양한 형태의 응답을 주는 end-point들을 생성 request-server : 다양한 요청 방식으로 response-server에 end-point를 호출하는 gateway 서비스 생성 모든 요청과 응답은 restful 하게 진행 Response request-server에서 호출시 response-server에서 리턴해주는 메세지 뿐만 아니라 모든response 값들은 어떻게 받을 수 있을까? status request reason headers body protocolVersion 등등… Response : 이런것들을 한번에 가져올 수 있도록 openfeign에서 지원해주는 객체 아래와 같은 정보들을 담아서 던져준다. public final class Response implements Closeable { private final int status; private final String reason; private final Map&lt;String, Collection&lt;String&gt;&gt; headers; private final Body body; private final Request request; private final ProtocolVersion protocolVersion; private Response(Builder builder) { checkState(builder.request != null, \"original request is required\"); this.status = builder.status; this.request = builder.request; this.reason = builder.reason; // nullable this.headers = caseInsensitiveCopyOf(builder.headers); this.body = builder.body; // nullable this.protocolVersion = builder.protocolVersion; } // ..} 테스트 일단 테스트를 하기전에 response-server에서 응답해주는 컨트롤러 확인. CommonHelperService : 리턴해주는 값에 아무것도 없으면 허전하니 뭐라도 담아서 보내줄 수 있게 구성한 서비스 별 의미는 없다. @Slf4j@RestController@RequiredArgsConstructor@RequestMapping(path = \"/api/v1/openfeign\")public class ResponseController { private final CommonHelperService commonHelperService; @PostMapping(path = \"/ok/users\") public ResponseEntity&lt;List&lt;UserDto&gt;&gt; getUsersOk() { return new ResponseEntity&lt;&gt;(commonHelperService.generatedFakerUsers(10), HttpStatus.OK); } @PostMapping(path = \"/bad-request/users\") public ResponseEntity&lt;MapContainer&gt; getUsersBadRequest(HttpServletRequest httpServletRequest) { MapContainer mapContainer = new MapContainer(); mapContainer.setDataMap( Map.of( \"request-status\", \"400\", \"request-uri\", httpServletRequest.getRequestURI() ) ); return new ResponseEntity&lt;&gt;(mapContainer, HttpStatus.BAD_REQUEST); } @Setter @Getter @NoArgsConstructor public static class MapContainer { private Map&lt;String, String&gt; dataMap; }} gateway 에서 리턴 타입을 String으로 했을 경우@FeignClient(name = \"response-v1-gateway\", url = \"${gateway.v1.response}\")public interface ResponseV1Gateway { @PostMapping(path = \"/ok/users\") String getUsers(); // ..}@Slf4j@SpringBootTestpublic class OpenFeignTest { @Autowired private ResponseV1Gateway responseV1Gateway; @Test void response_v1_gateway_get_body() { String users = responseV1Gateway.getUsers(); log.info(\"users = {}\", users); } // ..}users = [{\"username\":\"Charlotte Brown\",\"password\":\"$2a$10$6n.vNgN6eWwn4wd7woKS.OHaNWoszePpu7y8shTVT2B2PqvPJ8fA2\"},{\"username\":\"Alexander Jones\",\"password\":\"$2a$10$v0rcQ.gx.lSAZsxWsCagfuo9lVLZJfzjjdOwRNwEg3.RL26.HP13u\"},{\"username\":\"Isabella Harris\",\"password\":\"$2a$10$5fqa64jV8fY8Gg5Bm9ZRAeNBzbPRqHTz0hoWUmpJy8vcf1sG0KSsi\"},{\"username\":\"Ava Anderson\",\"password\":\"$2a$10$PbFqeuCRfkW3UUAaCEr2g.0W6Mq2SEpwtHH2wWKje39EIaLMjEkxi\"},{\"username\":\"Emma Jackson\",\"password\":\"$2a$10$Anay/vW4dbefCc8xrj4L0usAeCKvOazyd3Derdt0Gv8sDzh5/cPE6\"},{\"username\":\"Henry Taylor\",\"password\":\"$2a$10$fNRv1Q9loXZvJN6IT0OK0.l6hh5Aji7e7vgZ9LgxoB7Olcy0LV1yq\"},{\"username\":\"William Jackson\",\"password\":\"$2a$10$aZ624FtOtyfAjISx4afNoO3pBqiFFReGlhGVG25iB6lGCMMR4TqwC\"},{\"username\":\"James Johnson\",\"password\":\"$2a$10$0WEKxW8jKxZ//Zz9GyvjP.lRVkZGrQJKt4FtApiaoV6UWDDk7a/Ay\"},{\"username\":\"Mia Taylor\",\"password\":\"$2a$10$b3lmq6oQR.Kz1MQ1Z3lZFOayc1B3IUlyGUt45zfO8HPW4B7.R4jrm\"},{\"username\":\"Ava Smith\",\"password\":\"$2a$10$NF2MC0xO3yGr897zxBxvhOHIS6NXRTrGboofoSL8kTTUvu2l6hlOK\"}] gateway 에서 리턴 타입을 Response로 했을 경우@FeignClient(name = \"response-v1-gateway\", url = \"${gateway.v1.response}\")public interface ResponseV1Gateway { // .. @PostMapping(path = \"/ok/users\") Response getResponse();}@Slf4j@SpringBootTestpublic class OpenFeignTest { @Autowired private ResponseV1Gateway responseV1Gateway; // .. @Test void response_v1_gateway_get_response() throws IOException { Response response = responseV1Gateway.getResponse(); log.info(\"response = {}\", response); InputStream inputStream = response.body().asInputStream(); BufferedReader br = new BufferedReader(new InputStreamReader(inputStream)); String nextLine; while ((nextLine = br.readLine()) != null) { log.info(nextLine); } }}response = HTTP/1.1 200connection: keep-alivecontent-type: application/jsondate: Fri, 01 Mar 2024 07:36:32 GMTkeep-alive: timeout=60transfer-encoding: chunkedfeign.Response$InputStreamBody@294ebe11[{\"username\":\"James Anderson\",\"password\":\"$2a$10$Sst8BG0al1jmu.sa1LE1pOj2ery9zfYrtKFbCPXm5B695IeT57vjq\"},{\"username\":\"Olivia Wilson\",\"password\":\"$2a$10$A3RXAjxIAmEtlH5KW8lTi.P3r3o6icXucVGyHP4fTCk.P4iUI2IEe\"},{\"username\":\"Olivia Williams\",\"password\":\"$2a$10$uJiYxMBb.IcwCO3Q6ZEk1uyZqJHHizrLGisXBePpojR61gxGtw.ua\"},{\"username\":\"James Anderson\",\"password\":\"$2a$10$6aFQXT3DSRUSCZCn4LfxreIJ1T66975BR.fw5e7QXYwIPKik.Z1t.\"},{\"username\":\"James Brown\",\"password\":\"$2a$10$wxzXnVttrJgcK0Jg2U4fR./xC4n56awxBi2b0SKEHg1Cw7MdZwHPq\"},{\"username\":\"William Jackson\",\"password\":\"$2a$10$8ThUwpcZsfwLK723AkLE1OAvDIw7MqFjRarvQtgw7npqFRpD2LaKG\"},{\"username\":\"Michael Johnson\",\"password\":\"$2a$10$QBeY7Y5QrNUfKNE7JHcpN.nG1A.ktBzBUaJ7PkHTG54WDLKr897/e\"},{\"username\":\"Amelia Jones\",\"password\":\"$2a$10$e1WKvrdXlyRy0btSigjpW.jYqyAgB/k9gvIAM3RXx8wzIsQOYpBXa\"},{\"username\":\"Mia Moore\",\"password\":\"$2a$10$TYvWK.ftOaN6NURAKGx7KO7.DelHMnJyOgFK09Me/LKAIiAeecTTi\"},{\"username\":\"David Harris\",\"password\":\"$2a$10$psvd9v4yOfFel4BXeBXe2uNeG1tU/MUWQyK5yY5dgtVeGUmEQbm6a\"}]ToDO 해당 값을 어떤식으로 사용할지 생각해보기, configuration 설정 알아보기" }, { "title": "Spring Security, OAuth2 GitHub Login(2)", "url": "/posts/OAuth2(2)/", "categories": "Spring, Security", "tags": "back-end, spring, security, oauth2", "date": "2024-03-01 00:20:00 +0900", "snippet": " GitHub를 이용한 OAuth2 클라이언트 구현 권한 부여 서버 : GitHub GitHub계정이 있는 사람은 모두 이용할 수 있게 구성. GibHub OAuth2 인증기 생성 setting ⇒ developer settings ⇒ OAuth Apps ⇒ new oauth app 생성후 상세 페...", "content": " GitHub를 이용한 OAuth2 클라이언트 구현 권한 부여 서버 : GitHub GitHub계정이 있는 사람은 모두 이용할 수 있게 구성. GibHub OAuth2 인증기 생성 setting ⇒ developer settings ⇒ OAuth Apps ⇒ new oauth app 생성후 상세 페이지에서 client_id와 client_secret 를 발급 받을 수 있다.(security configuration 구성에 사용됨) build.gradle plugins { id 'java' id 'org.springframework.boot' version '2.7.18' id 'io.spring.dependency-management' version '1.1.4'}group = 'org.spring.oauth2'version = '0.0.1-SNAPSHOT'java { sourceCompatibility = '11'}configurations { compileOnly { extendsFrom annotationProcessor }}repositories { mavenCentral()}dependencies { implementation 'org.springframework.boot:spring-boot-starter-oauth2-client' implementation 'org.springframework.boot:spring-boot-starter-security' implementation 'org.springframework.boot:spring-boot-starter-web' compileOnly 'org.projectlombok:lombok' annotationProcessor 'org.projectlombok:lombok' testImplementation 'org.springframework.boot:spring-boot-starter-test' testImplementation 'org.springframework.security:spring-security-test'}tasks.named('test') { useJUnitPlatform()} security configuration @Configurationpublic class ProjectConfig extends WebSecurityConfigurerAdapter { @Value(\"${oauth2.github.id}\") private String id; @Value(\"${oauth2.github.secret}\") private String secret; @Override protected void configure(HttpSecurity http) throws Exception { // OAuth2 사용 설정 http .oauth2Login(client -&gt; client .clientRegistrationRepository(clientRegistrationRepository()) ); // 모든 end-point 인증 설정 http .authorizeHttpRequests() .anyRequest() .authenticated(); } private ClientRegistrationRepository clientRegistrationRepository() { ClientRegistration clientRegistration = clientRegistration(); return new InMemoryClientRegistrationRepository(clientRegistration); } private ClientRegistration clientRegistration() { return CommonOAuth2Provider.GITHUB .getBuilder(\"github\") .clientId(id) .clientSecret(secret) .build(); }} 코드 설명 clientRegistration() : 인증 공급자 설정을 위한 설정 clientId(id),clientSecret(secret) : GitHub OAuth2에서 발급받은 id와 secret private ClientRegistration clientRegistration() { return CommonOAuth2Provider.GITHUB .getBuilder(\"github\") .clientId(id) .clientSecret(secret) .build(); } clientRegistrationRepository() : 기존에 UserDetailsService와 비슷한 역할 ClientRegistrationRepository객체는 등록 ID로 ClientRegistration를 찾는다 private ClientRegistrationRepository clientRegistrationRepository() { ClientRegistration clientRegistration = clientRegistration(); return new InMemoryClientRegistrationRepository(clientRegistration); } http.oauth2Login(client-&gt;{...}) : oauth2인증 공급자를 설정해주는 코드@Overrideprotected void configure(HttpSecurity http) throws Exception { // OAuth2 사용 설정 http .oauth2Login(client -&gt; client .clientRegistrationRepository(clientRegistrationRepository()) ); // 모든 end-point 인증 설정 http .authorizeHttpRequests() .anyRequest() .authenticated();} 페이지 접근 결과 리디렉션하는 url 정보 http://localhost:8080/login/oauth2/code/github?code=…&amp;state=… OAuth2AuthenticationToken OAuth2AuthenticationToken : GitHub에서 제공해주는 유저 정보response info = Name: [86225268],Granted Authorities: [[ROLE_USER, SCOPE_read:user]],User Attributes: [{...}]" }, { "title": "Spring Security, OAuth2(1)", "url": "/posts/OAuth2(1)/", "categories": "Spring, Security", "tags": "back-end, spring, security, oauth2", "date": "2024-02-29 22:30:00 +0900", "snippet": " HTTP Basic인증 방식의 문제 네트워크를 통해 자격 증명이 자주 공유된다. 클라이언트가 자격 증명을 저장해 자격 증명을 서버로 보낼 수 있게됨. 여러 애플리케이션을 구성해야 할 경우 각 애플리케이션 별로 자격증명을 관리 해야함. OAuth2 기존 인증 방식의 문제를 해결하기 위한 권한 부여 ...", "content": " HTTP Basic인증 방식의 문제 네트워크를 통해 자격 증명이 자주 공유된다. 클라이언트가 자격 증명을 저장해 자격 증명을 서버로 보낼 수 있게됨. 여러 애플리케이션을 구성해야 할 경우 각 애플리케이션 별로 자격증명을 관리 해야함. OAuth2 기존 인증 방식의 문제를 해결하기 위한 권한 부여 프레임워크,권한 부여 프로토콜 OAuth2의 구성요소 리소스 서버 : 사용자가 소유한 리소스를 호스팅하는 서버. 리소스는 사용자의 데이터나 사용자가 수행할 작업등이 될 수 있음. 사용자(리소스 소유자) : 리소스 서버가 노출하는 리소스를 소유하는 개인. 사용자 이름과 암호로 신원 인증. 클라이언트 : 사용자를 대신해 접근하는 어플리케이션. 클라이언트는 클라이언트 ID와 클라이언트 secret을 이용해 신원을 증명. 여기서 말하는 자격 증명은 사용자 자격증명과 다름, 클라이언트의 자격을 증명하는 자체 증명이 필요 권한 부여 서버 : 클라이언트가 리소스 서버가 노출하는 사용자의 리소스에 접근할 권한을 부여하는 어플리케이션클라이언트의 접근 권한이 있다고 판단되면 토큰을 발급, 클라이언트는 해당 토큰을 이용해 리소스 서버에 증명최종적으로 클라이언트가 유효한 토큰이 있으면 해당 리소스에 접근 허용 OAuth2를 사용한다는건 토큰을 이용하겠다는것. 해당 토큰을 GRANT라고 한다. GRANT 유형 승인 코드 암호 갱신 토큰 클라이언트 자격 증명 승인 코드 GRANT 구현 가장 보편적인 유형 인증 요청을한다. ⇒ 엑세스 토큰을 얻는다. ⇒ 보호된 리소스를 호출한다. 1단계 클라이언트는 사용자가 인증해야 하는 권한부여 서버의 엔드포인트로 사용자를 리디렉션. 세부정보를 포함된요청 쿼리로 엔드 포인트 호출 response_type : 클라이언트가 코드를 기대한다는 것을 권한 부여 서버에 알리는 code값 필요 client_id : 애플리케이션 자체를 식별하는 클라이언트 id값 redirect_uri : 인증 성공 후 사용자를 리디렉션 할 위치를 담는다. scope : 허가된 권한 state : csrf보호를 위한 토큰 정의. 보호된 리소스에 접근해야 함으로 권한부여 서버의 로그인 양식 페이지를 연다. 인증에 성공하면 리디렉션 uri로 클라이언트 호출 후 코드와 상태 값을 제공. 코드를 이용해 2단계로 엑세스 토큰을 얻는다. 2단계 클라이언트는 토큰을 얻기 위해 코드를 이용해 권한 부여 서버를 호출한다. 권한 부여 서버를 호출할때 필요한 세부 정보 code : 1단계에서 받은 승인코드, 인증받은 사용자임을 증명 client_id 및 client_secret : 클라이언트 자격 증명 redirect_rui : 리디렉션될 uri grant_type : 인증 흐름 식별authorization_code값을 가진다. 클라이언트가 리소스 서버에서 노출하는 리소스를 호출하는데 필요한 access_token값을 반환 받음. 3단계 2단계에서 발급받은 토큰으로 보호된 리소스 호출 " }, { "title": "Spring Security, Spring Security Otp(3)", "url": "/posts/security_otp(3)/", "categories": "Spring, Security", "tags": "back-end, spring, security, spring security otp", "date": "2024-02-29 21:00:00 +0900", "snippet": "otp_part_2 인증필터, JWT 필터 구현 인증필터 기능 : 요청을 가로채고 인증 논리를 적용 1 ] 인증 서버가 수행하는 인증을 처리할 필터 구현 2 ] JWT기반 인증 필터 구현 InitialAuthenticationFiler 첫번째 인증단계 처리 필터 인증 책임을 ...", "content": "otp_part_2 인증필터, JWT 필터 구현 인증필터 기능 : 요청을 가로채고 인증 논리를 적용 1 ] 인증 서버가 수행하는 인증을 처리할 필터 구현 2 ] JWT기반 인증 필터 구현 InitialAuthenticationFiler 첫번째 인증단계 처리 필터 인증 책임을 위임할 AuthenticationManager 주입 해당 주입 부분을 spring security 6.x.x 버전에서 구현하다가 포기하고 5.x.x로 구현(TODO 항목으로 남겨둠) shouldNotFilter() 해당 재정의를 통해 특정 경로에 따른 필터 분기 설정 해당 필터에서는 /login경로에 대해서만 모든 요청을 실행 @Componentpublic class InitialAuthenticationFilter extends OncePerRequestFilter { private final AuthenticationManager manager; public InitialAuthenticationFilter(AuthenticationManager manager) { this.manager = manager; } @Value(\"${jwt.signing.key}\") private String signingKey; @Override protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException { String username = request.getHeader(\"username\"); String password = request.getHeader(\"password\"); String code = request.getHeader(\"code\"); if (code == null) { Authentication a = new UsernamePasswordAuthentication(username, password); manager.authenticate(a); } else { Authentication a = new OtpAuthentication(username, code); manager.authenticate(a); SecretKey key = Keys.hmacShaKeyFor(signingKey.getBytes(StandardCharsets.UTF_8)); String jwt = Jwts.builder() .setClaims(Map.of(\"username\", username)) .signWith(key) .compact(); response.setHeader(\"Authorization\", jwt); } } @Override protected boolean shouldNotFilter(HttpServletRequest request) { return !request.getServletPath().equals(\"/login\"); }} 코드 분석 HTTP 요청에 OTP가 없으면 사용자 이름과 암호로 인증후 AuthenticationManager호출 if (code == null) { Authentication a = new UsernamePasswordAuthentication(username, password); manager.authenticate(a); } OTP코드가 null이 아닌 경우 분기를 추가, 이때, 인증 서버가 OTP를 보냈다고 가정한후.OtpAuthentication로 AuthenticationManager 호출 } else { Authentication a = new OtpAuthentication(username, code); manager.authenticate(a); // .. } JWT를 구축하고 헤더에 추가하는 코드 } else { // .. SecretKey key = Keys.hmacShaKeyFor(signingKey.getBytes(StandardCharsets.UTF_8)); String jwt = Jwts.builder() .setClaims(Map.of(\"username\", username)) .signWith(key) .compact(); response.setHeader(\"Authorization\", jwt); } JwtAuthenticationFilter /login외에 다른 모든 경로에 대한 요청을 처리하는 필터 추가 해당 필터는 엔드포인트에 대한 접근 권한을 헤더에 담긴 JWT 토큰을 통해 검증한다. @Componentpublic class JwtAuthenticationFilter extends OncePerRequestFilter { @Value(\"${jwt.signing.key}\") private String signingKey; @Override protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException { String jwt = request.getHeader(\"Authorization\"); SecretKey key = Keys.hmacShaKeyFor(signingKey.getBytes(StandardCharsets.UTF_8)); Claims claims = Jwts.parserBuilder() .setSigningKey(key) .build() .parseClaimsJws(jwt) .getBody(); String username = String.valueOf(claims.get(\"username\")); GrantedAuthority a = new SimpleGrantedAuthority(\"user\"); var auth = new UsernamePasswordAuthentication(username, null, List.of(a)); SecurityContextHolder.getContext().setAuthentication(auth); filterChain.doFilter(request, response); } @Override protected boolean shouldNotFilter(HttpServletRequest request) { return request.getServletPath().equals(\"/login\"); }} SecurityConfig Filter,Provider 주입 및 설정 구성@Configurationpublic class SecurityConfig extends WebSecurityConfigurerAdapter { @Autowired private InitialAuthenticationFilter initialAuthenticationFilter; @Autowired private JwtAuthenticationFilter jwtAuthenticationFilter; @Autowired private OtpAuthenticationProvider otpAuthenticationProvider; @Autowired private UsernamePasswordAuthenticationProvider usernamePasswordAuthenticationProvider; @Override protected void configure(AuthenticationManagerBuilder auth) { auth.authenticationProvider(otpAuthenticationProvider) .authenticationProvider(usernamePasswordAuthenticationProvider); } @Override protected void configure(HttpSecurity http) throws Exception { http.csrf().disable(); http.addFilterAt( initialAuthenticationFilter, BasicAuthenticationFilter.class) .addFilterAfter( jwtAuthenticationFilter, BasicAuthenticationFilter.class ); http.authorizeRequests() .anyRequest().authenticated(); } @Override @Bean protected AuthenticationManager authenticationManager() throws Exception { return super.authenticationManager(); }} 테스트 @SpringBootTest@AutoConfigureMockMvcpublic class MainTests { @Autowired private MockMvc mvc; @MockBean private MockBean restTemplate; @MockBean private AuthenticationServerProxy authenticationServerProxy; @Test @DisplayName(\"Test /login with username and password\") public void testLoginWithUsernameAndPassword() throws Exception { mvc.perform(get(\"/login\").servletPath(\"/login\") .header(\"username\", \"bill\") .header(\"password\", \"12345\") ) .andExpect(status().isOk()); verify(authenticationServerProxy) .sendAuth(\"bill\", \"12345\"); } @Test @DisplayName(\"Test /login with username and otp\") public void testLoginWithUsernameAndOtp() throws Exception { when(authenticationServerProxy.sendOTP(\"bill\", \"5555\")) .thenReturn(true); mvc.perform(get(\"/login\").servletPath(\"/login\") .header(\"username\", \"bill\") .header(\"code\", \"5555\") ) .andExpect(header().exists(\"Authorization\")) .andExpect(status().isOk()); } @Test @DisplayName(\"Test /test with Authorization header\") public void testRequestWithAuthorizationHeader() throws Exception { when(authenticationServerProxy.sendOTP(\"bill\", \"5555\")) .thenReturn(true); var authorizationHeaderValue = mvc.perform(get(\"/login\").servletPath(\"/login\") .header(\"username\", \"bill\") .header(\"code\", \"5555\") ) .andReturn().getResponse().getHeader(\"Authorization\"); mvc.perform(get(\"/test\") .header(\"Authorization\", authorizationHeaderValue)) .andExpect(status().isOk()); }} oAuth2 인증으로 넘어간 후 못다룬 부분을 자세히 알아볼 예정." }, { "title": "Spring Security, Spring Security Otp(2)", "url": "/posts/security_otp(2)/", "categories": "Spring, Security", "tags": "back-end, spring, security, spring security otp, open feign", "date": "2024-02-27 23:00:00 +0900", "snippet": "otp_part_1 비지니스 인증 서버 구현 OTP를 받기 위한 사용자 이름과 암호 인증 사용자 ⇒ 클라이언트 ⇒ 비지니스 논리 서버 ⇒ 인증서버 ⇒ 사용자 사용자 ⇒ 클라이언트 : /login username:password 클라이언트 ⇒ 비지니스 논리 서버 : /login usern...", "content": "otp_part_1 비지니스 인증 서버 구현 OTP를 받기 위한 사용자 이름과 암호 인증 사용자 ⇒ 클라이언트 ⇒ 비지니스 논리 서버 ⇒ 인증서버 ⇒ 사용자 사용자 ⇒ 클라이언트 : /login username:password 클라이언트 ⇒ 비지니스 논리 서버 : /login username:password 비지니스 논리 서버 ⇒ 인증 서버 : /user/auth username:password 인증서버 ⇒ 사용자 : SMS 메세지로 OTP 발송 TOKEN을 받기 위한 OTP로 인증 사용자 ⇒ 클라이언트 ⇒ 비지니스 논리 서버 ⇒ 인증서버 ⇒ 사용자 사용자 ⇒ 클라이언트 : /login username:otp 클라이언트 ⇒ 비지니스 논리 서버 : /login username:otp 비지니스 논리 서버 ⇒ 인증 서버 : /otp/check username:otp 인증 서버 ⇒ 비지니스 논리 서버 : JWT 토큰을 발급 비지니스 논리 서버 ⇒ 클라이언트 : 토큰을 헤더에 저장. end-point접근을 위한 토큰 인증 비지니스 논리 서버 ⇒ 클라이언트 : /test Authentication:TOKEN 클라이언트 ⇒ 비지니스 논리 서버 : 검증 결과에 따라 response 반환 구현 아키텍쳐 요청 ⇒ InitialAuthenticationFilter ⇒ 요청 ⇒ JwtAuthenticationFilter ⇒ 응답 ⇒ InitialAuthenticationFilter ⇒ AuthenticationProvider ⇒ InitialAuthenticationFilter ⇒ 응답 InitialAuthenticationFilter : /login에 대한 요청에 대해서만 활성화, 사용자 이름/암호, 사용자 이름/OTP 인증 단계 처리 JwtAuthenticationFilter : /login을 제외한 모든 경로에 적용 end-point를 호출할 수 있도록 JWT 검증 AuthenticationProvider : 사용자 이름/암호, 사용자 이름/OTP 에 대한 인증 논리를 구현 AuthenticationProvider UsernamePasswordAuthenticationProvider,OtpAuthenticationProvider 두가지 인증 공급자 객체 필요. AuthenticationProvider 구현을 위한 Authentication 생성 매개 변수가 2개인 생성자를 호출하면 인증 인스턴스가 인증 안된 상태로 유지 매개 변수가 3개인 생성자를 호출하면 인증 인스턴스가 인증된 상태 UsernamePasswordAuthenticationpublic class UsernamePasswordAuthentication extends UsernamePasswordAuthenticationToken { public UsernamePasswordAuthentication(Object principal, Object credentials, Collection&lt;? extends GrantedAuthority&gt; authorities) { super(principal, credentials, authorities); } public UsernamePasswordAuthentication(Object principal, Object credentials) { super(principal, credentials); }} OtpAuthenticationpublic class OtpAuthentication extends UsernamePasswordAuthenticationToken { public OtpAuthentication(Object principal, Object credentials, Collection&lt;? extends GrantedAuthority&gt; authorities) { super(principal, credentials, authorities); } public OtpAuthentication(Object principal, Object credentials) { super(principal, credentials); }} 인증 서버 end-point 호출 RestTemplate 사용, ToDO openfeign으로 변경 인증 서버 에 구성된 end-point 연결 @Componentpublic class AuthenticationServerProxy { private final RestTemplate rest; public AuthenticationServerProxy(RestTemplate rest) { this.rest = rest; } @Value(\"${auth.server.base.url}\") private String baseUrl; public void sendAuth(String username, String password) { String url = baseUrl + \"/user/auth\"; var body = new User(); body.setUsername(username); body.setPassword(password); var request = new HttpEntity&lt;&gt;(body); rest.postForEntity(url, request, Void.class); } public boolean sendOTP(String username, String code) { String url = baseUrl + \"/otp/check\"; var body = new User(); body.setUsername(username); body.setCode(code); var request = new HttpEntity&lt;&gt;(body); var response = rest.postForEntity(url, request, Void.class); return response.getStatusCode().equals(HttpStatus.OK); }} AuthenticationProvider UsernamePasswordAuthenticationProvider@Componentpublic class UsernamePasswordAuthenticationProvider implements AuthenticationProvider { private final AuthenticationServerProxy proxy; public UsernamePasswordAuthenticationProvider(AuthenticationServerProxy proxy) { this.proxy = proxy; } @Override public Authentication authenticate(Authentication authentication) throws AuthenticationException { String username = authentication.getName(); String password = String.valueOf(authentication.getCredentials()); proxy.sendAuth(username, password); return new UsernamePasswordAuthenticationToken(username, password); } @Override public boolean supports(Class&lt;?&gt; aClass) { return UsernamePasswordAuthentication.class.isAssignableFrom(aClass); }} OtpAuthenticationProvider@Componentpublic class OtpAuthenticationProvider implements AuthenticationProvider { private final AuthenticationServerProxy proxy; public OtpAuthenticationProvider(AuthenticationServerProxy proxy) { this.proxy = proxy; } @Override public Authentication authenticate(Authentication authentication) throws AuthenticationException { String username = authentication.getName(); String code = String.valueOf(authentication.getCredentials()); boolean result = proxy.sendOTP(username, code); if (result) { return new OtpAuthentication(username, code); } else { throw new BadCredentialsException(\"Bad credentials.\"); } } @Override public boolean supports(Class&lt;?&gt; aClass) { return OtpAuthentication.class.isAssignableFrom(aClass); }} TO-DO 인증필터, JWT 필터 구현" }, { "title": "Spring, Openfeign(1)", "url": "/posts/spring_openfeign(1)/", "categories": "Spring, Openfeign", "tags": "back-end, spring, open feign", "date": "2024-02-27 23:00:00 +0900", "snippet": "otp_part_1 open feign openfeign : netflix에서 개발한 서버끼리 rest api를 할때 사용 더 편하게 호출할 수 있게해줌. 해당 서비스를 가지고 인증 서버에 요청을 보내는 서비스 구현 openfeign implements implements로 org.springframework.cloud:...", "content": "otp_part_1 open feign openfeign : netflix에서 개발한 서버끼리 rest api를 할때 사용 더 편하게 호출할 수 있게해줌. 해당 서비스를 가지고 인증 서버에 요청을 보내는 서비스 구현 openfeign implements implements로 org.springframework.cloud:spring-cloud-starter-openfeign 해당 의존성을 땡겨오면 안됨 추가적으로 ext{} 부분과 dependencyManagement 부분을 같이 떙겨 와야함. openfeign라이브러리 자체가 spring cloud 에 붙어있는 기술이라 해당 라이브러리만 땡겨오기 위한 설정으로 추정 plugins { id 'java' id 'org.springframework.boot' version '3.2.3' id 'io.spring.dependency-management' version '1.1.4'}group = 'org.spring.example'version = '0.0.1-SNAPSHOT'java { sourceCompatibility = '17'}configurations { compileOnly { extendsFrom annotationProcessor }}repositories { mavenCentral()}ext { set('springCloudVersion', \"2023.0.0\")}dependencies { // ... implementation 'org.springframework.cloud:spring-cloud-starter-openfeign' // ...}dependencyManagement { imports { mavenBom \"org.springframework.cloud:spring-cloud-dependencies:${springCloudVersion}\" }}tasks.named('test') { // ...} open feign로 gateway 서비스를 구성하려면 @FeignClient 구성 필요. configuration을 따로 설정할 수 있으나 해당 프로젝트에서는 불필요함으로 패스 OtpAuthenticationGateWay @FeignClient name 설정은 중요치 않고 url은 호출할 대상이 되는 호스트 url 해당 서비스 에서는 otp인증을 관리하는 서버 @FeignClient(name = \"otp\", url = \"${auth.otp}\")public interface OtpAuthenticationGateWay { @PostMapping(path = \"/user/add\") void userAdd(User.OtpUser otpUser); @PostMapping(path = \"/user/auth\") String userAuth(User.OtpUser otpUser); @PostMapping(path = \"/otp/check\") void otpCheck(User.Otp otp);} OtpFeignClientService gateway를 직접 호출하는건 위험하다 판단되어 서비스로 만들어서 사용 인증 서버에서 호출할 end point 마다 서비스 구성 service public interface OtpFeignClientService { boolean userAdd(User user); String userAuth(User user); boolean otpCheck(User user);} implements@Slf4j@Service@RequiredArgsConstructorpublic class OtpFeignClientServiceImpl implements OtpFeignClientService { private final OtpAuthenticationGateWay gateWay; @Override public boolean userAdd(User user) { try { gateWay.userAdd(user.toOtpUser()); return true; } catch (HttpClientErrorException | HttpServerErrorException e) { log.error(\"Failed to get resource = \", e); return false; } } @Override public String userAuth(User user) { try { return gateWay.userAuth(user.toOtpUser()); } catch (HttpClientErrorException | HttpServerErrorException e) { log.error(\"Failed to get resource = \", e); throw e; } } @Override public boolean otpCheck(User user) { try { gateWay.otpCheck(user.toOtp()); return true; } catch (HttpClientErrorException | HttpServerErrorException e) { log.error(\"Failed to get resource = \", e); return false; } }} EnableFeignClients service implements 부분을 보면 어디에서도 gateway기능을 @Bean등록을 해주는게 없음 해당 문제를 해결하기 위한 설정 필요 진입 entry point에 @EnableFeignClients 설정을 해주면 자동으로 빈주입을 해준다. @EnableFeignClients@SpringBootApplication // 요녀석이 붙어있는 클래스를 entry point 라고 한다.public class SpringSecurityBusinessApplication { public static void main(String[] args) { SpringApplication.run(SpringSecurityBusinessApplication.class, args); }} 테스트 테스트 방식 로컬에 인증 서버를 띄워놓음. 비지니스 서버에서 테스트 진행 User 객체 안에 요청을 보낼 수 있는 req로 변환해주는 코드 작성@Setter@Getter@NoArgsConstructorpublic class User { private String username; private String password; private String code; @Builder public User(String username, String password, String code) { this.username = username; this.password = password; this.code = code; } public OtpUser toOtpUser() { return OtpUser.builder() .username(username) .password(password) .build(); } public Otp toOtp() { return Otp.builder() .username(username) .code(code) .build(); } @Setter @Getter @NoArgsConstructor public static class OtpUser { private String username; private String password; @Builder public OtpUser(String username, String password) { this.username = username; this.password = password; } } @Setter @Getter @NoArgsConstructor public static class Otp { private String username; private String code; @Builder public Otp(String username, String code) { this.username = username; this.code = code; } }} 1 ] 비지니스 서버에서 사용되는 user 전역으로 선언 해당 객체는 테스트 클래스가 종료 될때까지 유지된다. 2 ] userAdd() 검증 3 ] userAuth() 검증 및 user객체에 otp code설정 4 ] otpAuth() 메소드를 실행해서 해당 otp가 유효 한지 검증@SpringBootTest@AutoConfigureMockMvc@TestMethodOrder(MethodOrderer.OrderAnnotation.class)public class OtpAuthenticationTest { @Autowired private OtpFeignClientService otpFeignClientService; private static User user; @BeforeAll static void setup() { user = User.builder() .username(\"first_tester\") .password(\"1q2w3e4r!\") .code(\"\") .build(); } @Test @Order(1) void otp_feign_client_service_user_add_test() { boolean b = otpFeignClientService.userAdd(user); Assertions.assertTrue(b); } @Test @Order(2) void otp_feign_client_service_user_auth_test() { String code = otpFeignClientService.userAuth(user); Assertions.assertNotNull(code); user.setCode(code); } @Test @Order(3) void otp_feign_client_service_otp_auth_test() { boolean b = otpFeignClientService.otpCheck(user); Assertions.assertTrue(b); }} 실행 결과 인증 서버 콘솔 확인" }, { "title": "Spring Security, Spring Security Otp(1)", "url": "/posts/security_otp(1)/", "categories": "Spring, Security", "tags": "back-end, spring, security, spring security otp", "date": "2024-02-27 16:40:00 +0900", "snippet": " Spring Security 를 이용한 OTP 인증 구현. 구성 클라이언트 : 백엔드 서버에 요청을 보내는 주체 (테스트 코드로 대체 한다.) 인증서버 : 사용자 자격을 증명하고 인증 토큰을 DB에서 조회(추후 SNS 서비스로 확장 가능) 비지니스 논리 서버 : 노출될 ...", "content": " Spring Security 를 이용한 OTP 인증 구현. 구성 클라이언트 : 백엔드 서버에 요청을 보내는 주체 (테스트 코드로 대체 한다.) 인증서버 : 사용자 자격을 증명하고 인증 토큰을 DB에서 조회(추후 SNS 서비스로 확장 가능) 비지니스 논리 서버 : 노출될 API를 제공하는 애플리케이션 서버 JWT : Json Web Token 으로 토큰을 구성한다. 클라이언트 ⇒ 비지니스 논리 서버 ⇒ 인증서버 ⇒ Database 나중에는 인증 서버가 클라이언트에 SNS 메세지를 보내고 해당 메세지를 통해 비지니스 서버에서 인증 처리유효한 OTP정보면 클라이언트에 TOKEN을 발급한다. 인증 서버 Entity User Entity@Entity@Getter@NoArgsConstructor(access = AccessLevel.PROTECTED)public class User { @Id @Column(name = \"username\") private String username; @Setter @Column(name = \"password\") private String password; @Builder public User(String username, String password) { this.username = username; this.password = password; }} Otp Entity@Entity@Getter@NoArgsConstructor(access = AccessLevel.PROTECTED)public class Otp { @Id @Column(name = \"username\") private String username; @Setter @Column(name = \"code\") private String code; @Builder public Otp(String username, String code) { this.username = username; this.code = code; }} 인증 서버 Repository public interface UserRepository extends JpaRepository&lt;User, String&gt; { Optional&lt;User&gt; findUserByUsername(String username);}public interface OtpRepository extends JpaRepository&lt;Otp, String&gt; { Optional&lt;Otp&gt; findOtpByUsername(String username);} 인증 서버 Service Servicepublic interface UserService { void addUser(User user); String auth(User user); boolean check(Otp otpToValidate);} ServiceImpl@Slf4j@Service@Transactional@RequiredArgsConstructorpublic class UserServiceImpl implements UserService { private final OtpRepository otpRepository; private final UserRepository userRepository; private final PasswordEncoder passwordEncoder; @Override public void addUser(User user) { user.setPassword(passwordEncoded(user)); userRepository.save(user); } @Override public String auth(User user) { User findUser = userRepository.findUserByUsername(user.getUsername()).orElseThrow(() -&gt; badCredentials().get()); log.info(\"findUser = {}\", findUser.getUsername()); log.info(\"findUser = {}\", findUser.getPassword()); if (passwordEncoder.matches(user.getPassword(), findUser.getPassword())) { return renewOtp(findUser); } else {// throw badCredentials().get(); return null; } } @Override public boolean check(Otp otpToValidate) { Optional&lt;Otp&gt; findOtp = otpRepository.findOtpByUsername(otpToValidate.getUsername()); if (findOtp.isPresent()) { Otp otp = findOtp.get(); return otpToValidate.getCode().equals(otp.getCode()); } return false; } private Supplier&lt;BadCredentialsException&gt; badCredentials() { throw new BadCredentialsException(\"not found user. checked username or password\"); } private String passwordEncoded(User user) { return passwordEncoder.encode(user.getPassword()); } private String renewOtp(User findUser) { String code = GenerateCodeUtil.generateCode(); Optional&lt;Otp&gt; findOtp = otpRepository.findOtpByUsername(findUser.getUsername()); if (findOtp.isPresent()) { Otp otp = findOtp.get(); otp.setCode(code); } else { Otp otp = Otp.builder() .username(findUser.getUsername()) .code(code) .build(); otpRepository.save(otp); } return code; } private static final class GenerateCodeUtil { public GenerateCodeUtil() { } private static String generateCode() { String code = null; try { SecureRandom random = SecureRandom.getInstanceStrong(); // 난수 생성 방식이 예측하기 어려워서 보안적으로 유리하다. int c = random.nextInt(9000) + 1000; code = String.valueOf(c); } catch (NoSuchAlgorithmException noSuchAlgorithmException) { log.error(\"noSuchAlgorithmException = \", noSuchAlgorithmException); } return code; } }} 인증 서버 Controller @Slf4j@RestController@RequiredArgsConstructorpublic class AuthController { private final UserService userService; @PostMapping(path = \"/user/add\") public ResponseEntity&lt;Void&gt; addUser(@RequestBody User user) { userService.addUser(user); return new ResponseEntity&lt;&gt;(HttpStatus.OK); } @PostMapping(path = \"/user/auth\") public String auth(@RequestBody User user) { String otpCode = userService.auth(user); log.info(\"otp code = {}\", otpCode); return otpCode; } // ToDO otp code 를 response 한다. @PostMapping(path = \"/otp/check\") public ResponseEntity&lt;Void&gt; check(@RequestBody Otp otp) { if (userService.check(otp)) { return new ResponseEntity&lt;&gt;(HttpStatus.OK); } else { return new ResponseEntity&lt;&gt;(HttpStatus.FORBIDDEN); } } @Getter @Setter @NoArgsConstructor public static class RequestBodyContainer&lt;T&gt; { private T requestBodyData; public RequestBodyContainer(T requestBodyData) { this.requestBodyData = requestBodyData; } }} 인증 서버 Security Configuration @Slf4j@Configuration@RequiredArgsConstructorpublic class ProjectConfig { @Bean public SecurityFilterChain defaultSecurityFilterChain(HttpSecurity http) throws Exception { http .cors(AbstractHttpConfigurer::disable) .csrf(AbstractHttpConfigurer::disable) .authorizeHttpRequests((requests) -&gt; requests .anyRequest().permitAll() ); return http.build(); } @Bean public PasswordEncoder passwordEncoder() { return new BCryptPasswordEncoder(); }} 인증 서버 테스트 코드 테스트를 진행할때 전체 흐름을 확인해야 함으로 @Rollback(value = false) 설정 데이터 초기화를 schema.sql를 통한 초기화 진행 application.yaml spring.sql.init.mode= always : 해당 부분을 설정하면 resources 폴더 아래에 schema.sql파일을 프로젝트 실행할때 먼저 실행한다. spring: datasource: url: jdbc:mysql://127.0.0.1:3306/otp_auth driver-class-name: com.mysql.cj.jdbc.Driver username: root password: root jpa: hibernate: ddl-auto: none show-sql: true open-in-view: false sql: init: mode: alwaysserver: port: 8522 schema.sqlCREATE DATABASE IF NOT EXISTS `otp_auth`; #CREATE TABLE IF NOT EXISTS `user`( `password` varchar(255) DEFAULT NULL, `username` varchar(255) NOT NULL, PRIMARY KEY (`username`));CREATE TABLE IF NOT EXISTS `otp`( `code` varchar(255) DEFAULT NULL, `username` varchar(255) NOT NULL, PRIMARY KEY (`username`));DELETEFROM `otp_auth`.`user`;DELETEFROM `otp_auth`.`otp`; 테스트 코드@SpringBootTest@AutoConfigureMockMvc@Rollback(value = false)@TestMethodOrder(MethodOrderer.OrderAnnotation.class)public class ControllerTest { @Autowired private MockMvc mockMvc; @Autowired private ObjectMapper objectMapper; @Autowired private OtpRepository otpRepository; private User user; @BeforeEach void setup(WebApplicationContext wac) { mockMvc = MockMvcBuilders.webAppContextSetup(wac).apply(springSecurity()).build(); user = User.builder() .username(\"first_tester\") .password(\"1q2w3e4r!\") .build(); } @Test @Order(1) void addUser() throws Exception { mockMvc.perform( post(\"/user/add\") .contentType(MediaType.APPLICATION_JSON) .content(objectMapper.writeValueAsString(user)) ) .andExpect(status().isOk()) .andDo(print()); } @Test @Order(2) void auth() throws Exception { mockMvc.perform( post(\"/user/auth\") .contentType(MediaType.APPLICATION_JSON) .content(objectMapper.writeValueAsString(user)) ) .andExpect(status().isOk()) .andDo(print()); } @Test @Order(3) void check_validate_happy() throws Exception { Otp otp = findOtpHelper(); ResultActions perform = mockMvc.perform( post(\"/otp/check\") .contentType(MediaType.APPLICATION_JSON) .content(objectMapper.writeValueAsString(otp)) ); perform.andExpect(status().isOk()); } @Test @Order(4) void check_validate_sad() throws Exception { Otp otp = findOtpHelper(); otp.setCode(\"FAIL_CODE\"); ResultActions perform = mockMvc.perform( post(\"/otp/check\") .contentType(MediaType.APPLICATION_JSON) .content(objectMapper.writeValueAsString(otp)) ); perform.andExpect(status().isForbidden()); } private Otp findOtpHelper() { Optional&lt;Otp&gt; findOtp = otpRepository.findOtpByUsername(user.getUsername()); Assertions.assertNotEquals(Optional.empty(), findOtp); return findOtp.orElse(null); }} ToDo : 비니지스 논리 서버 구현" }, { "title": "Spring Security, Security Context Holder", "url": "/posts/security_context_holder(1)/", "categories": "Spring, Security", "tags": "back-end, spring, security, security context holder", "date": "2024-02-26 19:40:00 +0900", "snippet": " SecurityContextHolder 인증된 사용자의 정보를 세션에 저장해놓는 객체 getContext() 메소드를 통해 Authentication 정보를 가져올 수 있다. Authentication : 사용자 인증 정보를 가지고 있는 객체 get...", "content": " SecurityContextHolder 인증된 사용자의 정보를 세션에 저장해놓는 객체 getContext() 메소드를 통해 Authentication 정보를 가져올 수 있다. Authentication : 사용자 인증 정보를 가지고 있는 객체 getPrincipal() : 접근 요청을 하는 사용자 정보를 가져온다. getCredentials() : 인증에 사용된 암호 반환. getDetails() : 요청 세션이름, IP 주소를 가져온다. isAuthenticated() : 인증 종료 후 true반환 진행중이면 false 반환 getAuthorities() : 허가된 권한 컬렉션 반환 저장 시점 AuthenticationProvider에서 인증이 완료되면 Authentication 객체를 반환함 @Override @Transactional public Authentication authenticate(Authentication authentication) throws AuthenticationException { String email = authentication.getName(); String password = authentication.getCredentials().toString(); UserDetails userDetails = jpaUserDetailsService.loadUserByUsername(email); boolean passwordValidate = passwordEncoder.matches(password, userDetails.getPassword()); if (passwordValidate) { return new UsernamePasswordAuthenticationToken( userDetails, // principal userDetails.getPassword(), // password userDetails.getAuthorities() // authority ); } else { throw new BadCredentialsException(\"Something went wrong!\"); } } UsernamePasswordAuthenticationToken UsernamePasswordAuthenticationToken 해당 클래스는 어떤 값들을 인자로 받는걸까?\tpublic UsernamePasswordAuthenticationToken(Object principal, Object credentials,\t\t\tCollection&lt;? extends GrantedAuthority&gt; authorities) {\t\tsuper(authorities);\t\tthis.principal = principal;\t\tthis.credentials = credentials;\t\tsuper.setAuthenticated(true); // must use super, as we override\t} this.principal = principal : 사용자 정보를 저장. this.credentials = credentials : 사용자 인증 정보를 저장(해당 프로젝트에서는 password) super(authorities) : 사용자 권한 목록 super.setAuthenticated(true) : 인증 여부를 true로 한다 인증 후 Session 확인 인증이 정상적으로 이루어지고 Authentication 객체를 올바르게 리턴을 하였을 때 2가지 세션이 설정됨 SPRING_SECURITY_CONTEXT : 주요 컨텍스트 저장. SPRING_SECURITY_SAVED_REQUEST : 보호된 리소스에 접근하여 요청이 반려 되었을 떄 요청을 저장하고 리다이렉션 할때 사용 컨트롤러에서 확인 컨트롤러 코드package org.spring.example.jpa.controller;import lombok.extern.slf4j.Slf4j;import org.springframework.security.core.Authentication;import org.springframework.security.core.GrantedAuthority;import org.springframework.security.core.userdetails.UserDetails;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestMapping;@Slf4j@Controller@RequestMapping(path = \"/main\")public class MainController { @GetMapping public String defaultMain(Authentication authentication, Model model) { Object details = authentication.getPrincipal(); if (null != details) { if (details instanceof UserDetails) { UserDetails userDetails = (UserDetails) details; log.info(authentication.getDetails().toString()); log.info(\"user name = {}\", userDetails.getUsername()); log.info(\"user password = {}\", userDetails.getPassword()); for (GrantedAuthority authority : userDetails.getAuthorities()) { log.info(\"user authority = {}\", authority.getAuthority()); } } } return \"/main/form\"; }} 로그WebAuthenticationDetails [RemoteIpAddress=0:0:0:0:0:0:0:1, SessionId=A469EB58A5D624FF68AAC28788F450DB]user name = admin@gmail.comuser password = $2a$10$NoQLGfkiyQx9hXil85YBvuk92dL9WIzUTzofthDvQdxOUi2nO20XCuser authority = admin_enter" }, { "title": "Spring Security, 401 403", "url": "/posts/forbidden_unauthorized(1)/", "categories": "Spring, Security", "tags": "back-end, spring, security, 401 403 exception handler", "date": "2024-02-26 19:40:00 +0900", "snippet": " 401, 403 에러가 발생했을 때 핸들링할 필터가 필요 SecurityFilterChain exceptionHandling : 각 발생 에러는 리다이렉트 시킬때 modal창을 띄우기 위한 url parameter을 가진다. authenticationEntryPoint : 401 에...", "content": " 401, 403 에러가 발생했을 때 핸들링할 필터가 필요 SecurityFilterChain exceptionHandling : 각 발생 에러는 리다이렉트 시킬때 modal창을 띄우기 위한 url parameter을 가진다. authenticationEntryPoint : 401 에러 핸들링 accessDiniedHandler : 403 에러 핸들링 @Slf4j@Configuration@RequiredArgsConstructorpublic class AngrySecurityConfiguration { // ... private final CustomAuthenticationEntryPoint authenticationEntryPoint; private final CustomAccessDeniedHandler accessDeniedHandler; // ... @Bean public SecurityFilterChain defaultSecurityFilterChain(HttpSecurity http) throws Exception { corsAndCsrfSetting(http) .exceptionHandling(exception -&gt; exception .authenticationEntryPoint(authenticationEntryPoint) .accessDeniedHandler(accessDeniedHandler) ) .authorizeHttpRequests( // ... ) .formLogin(formLogin -&gt; formLogin // ... ); return http.build(); } private HttpSecurity xssProtecting(HttpSecurity http) throws Exception { // ... } private HttpSecurity corsAndCsrfSetting(HttpSecurity http) throws Exception { // ... } @Bean public PasswordEncoder passwordEncoder() { return new BCryptPasswordEncoder(); }} AuthenticationEntryPoint : 401 인증이 안되었을 때 발생하는 에러 핸들링 로그인이 안되어 있는 상태이거나, 외부 cors, csrf 관련 인증이 안된 상태일 때 /login-form 으로 리다이렉트 시켜 로그인을 유도한다. @Slf4j@Component@RequiredArgsConstructorpublic class CustomAuthenticationEntryPoint implements AuthenticationEntryPoint { private final HttpServletRequestService httpServletRequestService; @Override public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException) throws IOException, ServletException { log.info(\"authentication entrypoint = {}\", authException.getMessage()); RequestInformation requestInformation = httpServletRequestService.requestInfo(request); response.setStatus(HttpServletResponse.SC_UNAUTHORIZED); response.sendRedirect(\"/login-form?error=authorization\"); }} AccessDeniedHandler : 403 인증은 되었지만 권한이 없을 때 발생하는 에러 핸들링, 로그인은 하였으나 해당 기능에 접근할 수 있는 권한이 없을 때 authorizeHttpRequests 에 deny가 된 앤드 포인트로 접근할 때 발생 모두가 접근 가능한 메인 페이지로 리다이렉트 시킨다. @Slf4j@Component@RequiredArgsConstructorpublic class CustomAccessDeniedHandler implements AccessDeniedHandler { private final HttpServletRequestService httpServletRequestService; @Override public void handle(HttpServletRequest request, HttpServletResponse response, AccessDeniedException accessDeniedException) throws IOException, ServletException { RequestInformation requestInformation = httpServletRequestService.requestInfo(request); String header = request.getHeader(\"referer\"); log.info(\"header = {}\", header); log.info(\"access denied handler = {}\", accessDeniedException.getMessage()); response.setStatus(HttpServletResponse.SC_FORBIDDEN); response.sendRedirect(\"/main?error=authorization\"); }}" }, { "title": "Spring Security, Custom Form Login", "url": "/posts/custom_login_page(1)/", "categories": "Spring, Security", "tags": "back-end, spring, security, custom form login", "date": "2024-02-25 21:00:00 +0900", "snippet": " defaultSecurityFilterChain defaultSecurityFilterChain : 메소드 안에 form login 설정 loginPage() : 커스텀한 view를 반환하는 end-point usernameParameter() : view 에서 form 에 담은 username에 해당하는 파라미터 설정 ...", "content": " defaultSecurityFilterChain defaultSecurityFilterChain : 메소드 안에 form login 설정 loginPage() : 커스텀한 view를 반환하는 end-point usernameParameter() : view 에서 form 에 담은 username에 해당하는 파라미터 설정 시큐리티에서는 아이디를 username으로 사용하고 있지만 해당 서비스 에서는 아이디를 email로 사용하기 떄문에 추가 설정 필요 passwordParameter() : usernameParameter() 설명과 동일. .loginProcessingUrl(\"/login\") : 중요 기존에 인증 공급자의 기능을 그대로 설정하는 옵션. successHandler(), failureHandler() : 인증 성공, 실패 시 다음 동작을 하게하는 핸들러 permitAll() : 해당 페이지는 누구나 접근 가능하게 설정. @Beanpublic SecurityFilterChain defaultSecurityFilterChain(HttpSecurity http) throws Exception { httpSecurity(http) .authorizeHttpRequests( (requests) -&gt; requests // ... ) .formLogin(formLogin -&gt; formLogin .loginPage(\"/login-form\") .usernameParameter(\"email\") .passwordParameter(\"password\") .loginProcessingUrl(\"/login\") .successHandler(authenticationSuccessHandler) .failureHandler(authenticationFailureHandler) .permitAll() ); return http.build();} Controller @Controller@RequestMapping(path = \"/login-form\")public class LoginFormController { @GetMapping public String loginForm() { return \"/login/form\"; } @GetMapping(\"/fail\") public String loginFailForm() { return \"/login/fail-form\"; }} view &lt;!doctype html&gt;&lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Example&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"/static/css/main.css\" th:href=\"@{/css/main.css}\"&gt; &lt;link rel=\"stylesheet\" href=\"/static/css/login/form.css\" th:href=\"@{/css/login/form.css}\"&gt; &lt;script type=\"text/javascript\" src=\"/static/js/login/login.js\" th:src=\"@{/js/login/login.js}\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;header class=\"login-form-header\"&gt; &lt;strong&gt;Spring Security + HTML + CSS Challenge &lt;br&gt; #1 : Sign Login Form&lt;/strong&gt;&lt;/header&gt;&lt;form id=\"login-form\" method=\"POST\" action=\"/login-form/login\" th:method=\"POST\" th:action=\"@{/login}\"&gt; &lt;div class=\"login-form-flex-box\"&gt; &lt;div class=\"input-flex-box\"&gt; &lt;label for=\"email\"&gt;email : &lt;/label&gt; &lt;input id=\"email\" name=\"email\" type=\"email\" placeholder=\"email\"/&gt; &lt;/div&gt; &lt;div class=\"input-flex-box\"&gt; &lt;label for=\"password\"&gt;password : &lt;/label&gt; &lt;input id=\"password\" class=\"password\" name=\"password\" type=\"password\" placeholder=\"password\"/&gt; &lt;/div&gt; &lt;button&gt;Login In&lt;/button&gt; &lt;/div&gt;&lt;/form&gt;&lt;footer&gt;&lt;/footer&gt;&lt;/body&gt;&lt;/html&gt;CustomAuthenticationFailureHandler@Slf4j@Componentpublic class CustomAuthenticationFailureHandler implements AuthenticationFailureHandler { @Override public void onAuthenticationFailure(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception) throws IOException, ServletException { log.error(\"exception = {}\", exception.getMessage()); log.info(\"CustomAuthenticationFailureHandler\"); response.sendRedirect(\"/login-form/fail\"); }}CustomAuthenticationSuccessHandler@Slf4j@Componentpublic class CustomAuthenticationSuccessHandler implements AuthenticationSuccessHandler { @Override public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException { log.info(\"CustomAuthenticationSuccessHandler\"); response.sendRedirect(\"/main\"); }}" }, { "title": "Spring Security, Authentication Success handler", "url": "/posts/login_success_handler(1)/", "categories": "Spring, Security", "tags": "back-end, spring, security, authentication success handler", "date": "2024-02-24 22:30:00 +0900", "snippet": " AuthenticationSuccessHandler 인증에 성공했을 때 어떤 동작을 취할것인지 설정하는 핸들러 CustomSuccessHandler @Slf4j@Componentpublic class CustomAuthenticationSuccessHandler implements AuthenticationSuccessHandler { @Ove...", "content": " AuthenticationSuccessHandler 인증에 성공했을 때 어떤 동작을 취할것인지 설정하는 핸들러 CustomSuccessHandler @Slf4j@Componentpublic class CustomAuthenticationSuccessHandler implements AuthenticationSuccessHandler { @Override public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException { response.sendRedirect(\"/main\"); }} SecurityConfiguration @Slf4j@Configuration@RequiredArgsConstructorpublic class AngrySecurityConfiguration { // ... @Bean public SecurityFilterChain defaultSecurityFilterChain(HttpSecurity http) throws Exception { httpSecurity(http) .authorizeHttpRequests( // ... ) .formLogin(formLogin -&gt; formLogin .successHandler(customAuthenticationSuccessHandler) ) .httpBasic(withDefaults()); return http.build(); } private HttpSecurity httpSecurity(HttpSecurity http) throws Exception { // ... } @Bean public PasswordEncoder passwordEncoder() { // ... }} MainController @Slf4j@Controller@RequestMapping(path = \"/main\")public class MainController { @GetMapping public String defaultMain(Authentication authentication, Model model) { authenticationPrintHelper(authentication); String name = authentication.getName(); String greeting = String.format(\"%s님 반갑습니다\", name); model.addAttribute(\"greeting\", greeting); return \"/main/index\"; } private void authenticationPrintHelper(Authentication authentication) { String name = authentication.getName(); log.info(\"name = {}\", name); }} /main/index.html &lt;!doctype html&gt;&lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;header&gt; &lt;p th:text=\"${greeting}\"&gt;&lt;/p&gt;&lt;/header&gt;&lt;/body&gt;&lt;/html&gt; 테스트 @SpringBootTest@AutoConfigureMockMvcpublic class MainControllerTest { @Autowired private MockMvc mockMvc; @Test void main_greeting_test() throws Exception { MvcResult mvcResult = mockMvc.perform( get(\"/main\") .with(httpBasic(\"guest@gmail.com\", \"1q2w3e4r!\")) ) .andExpect(status().isOk()) .andReturn(); ModelAndView modelAndView = mvcResult.getModelAndView(); Assertions.assertNotNull(modelAndView); String viewName = modelAndView.getViewName(); Assertions.assertEquals(\"/main/index\", viewName); Map&lt;String, Object&gt; model = modelAndView.getModel(); Assertions.assertNotNull(model.get(\"greeting\")); }}" }, { "title": "Spring Security, Password Encoder", "url": "/posts/password_encoder(1)/", "categories": "Spring, Security", "tags": "back-end, spring, security, password encoder", "date": "2024-02-24 21:00:00 +0900", "snippet": " Password Encoder 실제 사용자의 password 정보는 암호화되어 저장되기 때문에 추가적인 검증 필요. AuthenticationProvider : UserDetailsService와 PasswordEncoder로 구성되어 있음. UserDetailsService : 사용자 세부 정보 서비스 ...", "content": " Password Encoder 실제 사용자의 password 정보는 암호화되어 저장되기 때문에 추가적인 검증 필요. AuthenticationProvider : UserDetailsService와 PasswordEncoder로 구성되어 있음. UserDetailsService : 사용자 세부 정보 서비스 PasswordEncoder : 사용자 암호를 검증 BCryptPasswordEncoder 사용. PasswordEncoder 의존성 추가@Slf4j@Configuration@RequiredArgsConstructorpublic class AngrySecurityConfiguration { private final CustomCorsConfig customCorsConfig; private final CsrfTokenLoggerFilter csrfTokenLoggerFilter; private final CsrfTokenValidFilter csrfTokenValidFilter; @Value(\"${spring.profiles.active}\") private String ACTIVE; @Bean public SecurityFilterChain defaultSecurityFilterChain(HttpSecurity http) throws Exception { // ... } private HttpSecurity httpSecurity(HttpSecurity http) throws Exception { // ... } @Bean public PasswordEncoder passwordEncoder() { return new BCryptPasswordEncoder(); }} AuthenticationProvider @Slf4j@Service@RequiredArgsConstructorpublic class AuthenticationProviderService implements AuthenticationProvider { private final PasswordEncoder passwordEncoder; private final JpaUserDetailsService jpaUserDetailsService; @Override @Transactional public Authentication authenticate(Authentication authentication) throws AuthenticationException { String email = authentication.getName(); String password = authentication.getCredentials().toString(); UserDetails userDetails = jpaUserDetailsService.loadUserByUsername(email); boolean passwordValidate = passwordEncoder.matches(password, userDetails.getPassword()); if (passwordValidate) { return new UsernamePasswordAuthenticationToken( userDetails.getUsername(), userDetails.getPassword(), userDetails.getAuthorities() ); } else { throw new BadCredentialsException(\"Something went wrong!\"); } } @Override public boolean supports(Class&lt;?&gt; authentication) { return UsernamePasswordAuthenticationToken.class.isAssignableFrom(authentication); }} 테스트 @TestMethodOrder(MethodOrderer.OrderAnnotation.class)public class SecurityAccessLimitTest extends SecuritySetup { @Nested @Order(1) @DisplayName(\"admin test\") class AdminTest { @Test @Order(1) void admin_get_pass() throws Exception { accessLimitTestHelper(\"/admin\", admin, HttpMethod.GET).andExpect(status().isOk()); } @Test @Order(2) void user_get_fail() throws Exception { accessLimitTestHelper(\"/user\", admin, HttpMethod.POST).andExpect(status().isForbidden()); } @Test @Order(3) void guest_get_fail() throws Exception { accessLimitTestHelper(\"/guest\", admin, HttpMethod.PATCH).andExpect(status().isForbidden()); } @Test @Order(4) void basic_get_pass() throws Exception { accessLimitTestHelper(\"/basic\", admin, HttpMethod.PUT).andExpect(status().isOk()); } } @Nested @Order(2) @DisplayName(\"user test\") class UserTest { @Test @Order(1) void admin_get_fail() throws Exception { accessLimitTestHelper(\"/admin\", user, HttpMethod.GET).andExpect(status().isForbidden()); } @Test @Order(2) void user_get_pass() throws Exception { accessLimitTestHelper(\"/user\", user, HttpMethod.POST).andExpect(status().isOk()); } @Test @Order(3) void guest_get_fail() throws Exception { accessLimitTestHelper(\"/guest\", user, HttpMethod.PATCH).andExpect(status().isForbidden()); } @Test @Order(4) void basic_get_fail() throws Exception { accessLimitTestHelper(\"/basic\", user, HttpMethod.PUT).andExpect(status().isOk()); } } @Nested @Order(3) @DisplayName(\"guest test\") class GuestTest { @Test @Order(1) void admin_get_fail() throws Exception { accessLimitTestHelper(\"/admin\", guest, HttpMethod.GET).andExpect(status().isForbidden()); } @Test @Order(2) void user_get_fail() throws Exception { accessLimitTestHelper(\"/user\", guest, HttpMethod.POST).andExpect(status().isForbidden()); } @Test @Order(3) void guest_get_pass() throws Exception { accessLimitTestHelper(\"/guest\", guest, HttpMethod.PATCH).andExpect(status().isOk()); } @Test @Order(4) void basic_get_pass() throws Exception { accessLimitTestHelper(\"/basic\", guest, HttpMethod.PUT).andExpect(status().isOk()); } }}" }, { "title": "Spring Security, Access Limit", "url": "/posts/security_access_limit(1)/", "categories": "Spring, Security", "tags": "back-end, spring, security, access limit", "date": "2024-02-23 17:40:00 +0900", "snippet": " authorizeHttpRequests 사용자 데이터Entity_구성 사용자의 접근 제한을 하는부분 Spring Security에서 설정한 cors, csrf 설정이 테스트에서 예상밖으로 작동해서httpSecurity()메소드를 생성하고 운영, 테스트에 따른 설정을 다르게함 @Slf4j@Configuration@Requir...", "content": " authorizeHttpRequests 사용자 데이터Entity_구성 사용자의 접근 제한을 하는부분 Spring Security에서 설정한 cors, csrf 설정이 테스트에서 예상밖으로 작동해서httpSecurity()메소드를 생성하고 운영, 테스트에 따른 설정을 다르게함 @Slf4j@Configuration@RequiredArgsConstructorpublic class AngrySecurityConfiguration { private final CustomCorsConfig customCorsConfig; private final CsrfTokenLoggerFilter csrfTokenLoggerFilter; private final CsrfTokenValidFilter csrfTokenValidFilter; @Value(\"${spring.profiles.active}\") private String ACTIVE; @Bean public SecurityFilterChain defaultSecurityFilterChain(HttpSecurity http) throws Exception { httpSecurity(http) .authorizeHttpRequests( (requests) -&gt; requests .requestMatchers(\"/basic\").permitAll() .requestMatchers(\"/admin\").hasAuthority(\"admin_enter\") .requestMatchers(\"/user\").hasAuthority(\"user_enter\") .requestMatchers(\"/guest\").hasAuthority(\"guest_enter\") ) .formLogin(withDefaults()) .httpBasic(withDefaults()); return http.build(); } private HttpSecurity httpSecurity(HttpSecurity http) throws Exception { if (ACTIVE.equals(\"dev\")) { return http .cors(AbstractHttpConfigurer::disable) .csrf(AbstractHttpConfigurer::disable); } else { CsrfTokenRequestAttributeHandler requestHandler = new CsrfTokenRequestAttributeHandler(); requestHandler.setCsrfRequestAttributeName(\"_csrf\"); return http .addFilterAfter(csrfTokenLoggerFilter, BasicAuthenticationFilter.class) .addFilterAfter(csrfTokenValidFilter, BasicAuthenticationFilter.class) .cors((cors) -&gt; cors.configurationSource(customCorsConfig)) .csrf((csrf) -&gt; csrf .csrfTokenRequestHandler(requestHandler) .csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse()) ) .addFilterAfter(new CsrfCookieFilter(), BasicAuthenticationFilter.class); } } @Bean public PasswordEncoder passwordEncoder() { return NoOpPasswordEncoder.getInstance(); // ToBE bcrypt }} .requestMatchers(\"/basic\").denyAll() : /basic 요청에 대한 모든 접근을 불허한다. .requestMatchers(\"/basic\").permitAll() : /basic 요청에 대한 모든 접근을 허용한다. .requestMatchers(\"/admin\").hasAuthority(\"admin_enter\") : /admin요청에 대한 모든 접근을 admin_enter권한을 갖은 사용자에게만 허용한다. .requestMatchers(HttpMethod.GET,\"/admin\") : 다음과 같이 메소드 레벨로도 설정 가능. test setup @SpringBootTestpublic abstract class SecuritySetup { protected MockMvc mockMvc; protected AccessUser admin; protected AccessUser user; protected AccessUser guest; @BeforeEach public void setup(WebApplicationContext wac) { mockMvc = MockMvcBuilders .webAppContextSetup(wac) .apply(springSecurity()) .build(); admin = AccessUser.builder() .email(\"admin@gmail.com\") .password(\"1q2w3e4r!\") .build(); user = AccessUser.builder() .email(\"user@gmail.com\") .password(\"1q2w3e4r!\") .build(); guest = AccessUser.builder() .email(\"guest@gmail.com\") .password(\"1q2w3e4r!\") .build(); } protected ResultActions accessLimitTestHelper(String endPoint, AccessUser accessUser, HttpMethod httpMethod) throws Exception { Assertions.assertNotNull(endPoint); Assertions.assertNotNull(accessUser); Assertions.assertNotNull(httpMethod); MockHttpServletRequestBuilder requestBuilder = null; switch (httpMethod.name()) { case \"GET\": requestBuilder = get(endPoint); break; case \"POST\": requestBuilder = post(endPoint); break; case \"PATCH\": requestBuilder = patch(endPoint); break; case \"PUT\": requestBuilder = put(endPoint); break; case \"DELETE\": requestBuilder = delete(endPoint); break; default: throw new IllegalArgumentException(\"지원되지 않는 HTTP 메소드입니다.\"); } // HTTP 기본 인증 및 헤더 추가 requestBuilder .with(httpBasic(accessUser.getEmail(), accessUser.getPassword())); return mockMvc.perform(requestBuilder); } @Getter @Setter @Builder @AllArgsConstructor public static class AccessUser { private String email; private String password; }} 테스트 코드 @TestMethodOrder(MethodOrderer.OrderAnnotation.class)public class SecurityAccessLimitTest extends SecuritySetup { @Nested @Order(1) @DisplayName(\"admin test\") class AdminTest { @Test @Order(1) void admin_get_pass() throws Exception { accessLimitTestHelper(\"/admin\", admin, HttpMethod.GET).andExpect(status().isOk()); } @Test @Order(2) void user_get_fail() throws Exception { accessLimitTestHelper(\"/user\", admin, HttpMethod.POST).andExpect(status().isForbidden()); } @Test @Order(3) void guest_get_fail() throws Exception { accessLimitTestHelper(\"/guest\", admin, HttpMethod.PATCH).andExpect(status().isForbidden()); } @Test @Order(4) void basic_get_pass() throws Exception { accessLimitTestHelper(\"/basic\", admin, HttpMethod.PUT).andExpect(status().isOk()); } } @Nested @Order(2) @DisplayName(\"user test\") class UserTest { @Test @Order(1) void admin_get_fail() throws Exception { accessLimitTestHelper(\"/admin\", user, HttpMethod.GET).andExpect(status().isForbidden()); } @Test @Order(2) void user_get_pass() throws Exception { accessLimitTestHelper(\"/user\", user, HttpMethod.POST).andExpect(status().isOk()); } @Test @Order(3) void guest_get_fail() throws Exception { accessLimitTestHelper(\"/guest\", user, HttpMethod.PATCH).andExpect(status().isForbidden()); } @Test @Order(4) void basic_get_fail() throws Exception { accessLimitTestHelper(\"/basic\", user, HttpMethod.PUT).andExpect(status().isOk()); } } @Nested @Order(3) @DisplayName(\"guest test\") class GuestTest { @Test @Order(1) void admin_get_fail() throws Exception { accessLimitTestHelper(\"/admin\", guest, HttpMethod.GET).andExpect(status().isForbidden()); } @Test @Order(2) void user_get_fail() throws Exception { accessLimitTestHelper(\"/user\", guest, HttpMethod.POST).andExpect(status().isForbidden()); } @Test @Order(3) void guest_get_pass() throws Exception { accessLimitTestHelper(\"/guest\", guest, HttpMethod.PATCH).andExpect(status().isOk()); } @Test @Order(4) void basic_get_pass() throws Exception { accessLimitTestHelper(\"/basic\", guest, HttpMethod.PUT).andExpect(status().isOk()); } }}" }, { "title": "Spring Security, User Authentication", "url": "/posts/user_details_service(1)/", "categories": "Spring, Security", "tags": "back-end, spring, security, user authentication", "date": "2024-02-23 13:00:00 +0900", "snippet": " 사용자 인증 구현ENTITY_설계CustomUserDetails getAuthorities() : 접근한 사용자의 권한들을 가져오는 메소드.@Getter@RequiredArgsConstructorpublic class CustomUserDetails implements UserDetails { private final User user; @O...", "content": " 사용자 인증 구현ENTITY_설계CustomUserDetails getAuthorities() : 접근한 사용자의 권한들을 가져오는 메소드.@Getter@RequiredArgsConstructorpublic class CustomUserDetails implements UserDetails { private final User user; @Override public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() { return user.getRole().getRoleAuths().stream() .map(a -&gt; new SimpleGrantedAuthority( a.getAuth().getName() )).collect(Collectors.toList()); } @Override public String getUsername() { return user.getEmail(); } @Override public String getPassword() { return user.getPassword(); } @Override public boolean isAccountNonExpired() { return true; } @Override public boolean isAccountNonLocked() { return true; } @Override public boolean isCredentialsNonExpired() { return true; } @Override public boolean isEnabled() { return true; }}JpaUserDetailsService SimpleGrantedAuthority : Spring security 가 기본 제공. 애플리케이션 사용자의 이름에 해당하는 사용자를 찾으면 위에서 만들었던 CustomUserDetails에 user인스턴스를 래핑해서 반환 UsernameNotFoundException : 사용자를 못찾으면 반환하는 에러. @Slf4j@Service@RequiredArgsConstructorpublic class JpaUserDetailsService implements UserDetailsService { private final UserRepository userRepository; @Override public UserDetails loadUserByUsername(String email) throws UsernameNotFoundException { Supplier&lt;UsernameNotFoundException&gt; usernameNotFoundExceptionSupplier = () -&gt; new UsernameNotFoundException(\"problem during authentication!\"); User user = userRepository.findUserByEmail(email).orElseThrow(usernameNotFoundExceptionSupplier); log.info(\"JpaUserDetailsService user = {}\", user); return new CustomUserDetails(user); }}AuthenticationProvider authenticate() 실제 인증이 진행하고 유저 토큰을 리턴@Slf4j@Service@RequiredArgsConstructorpublic class AuthenticationProviderService implements AuthenticationProvider { private final JpaUserDetailsService jpaUserDetailsService; @Override public Authentication authenticate(Authentication authentication) throws AuthenticationException { String email = authentication.getName(); UserDetails userDetails = jpaUserDetailsService.loadUserByUsername(email); log.info(\"authentication provider service userDetails = {}\", userDetails.getUsername()); log.info(\"authentication provider service userDetails = {}\", userDetails.getPassword()); log.info(\"authentication provider service userDetails = {}\", userDetails.getAuthorities()); return new UsernamePasswordAuthenticationToken( userDetails.getUsername(), userDetails.getPassword(), userDetails.getAuthorities() ); } @Override public boolean supports(Class&lt;?&gt; authentication) { return UsernamePasswordAuthenticationToken.class.isAssignableFrom(authentication); }} JpaUserDetailsService해당 서비스를 이미 @Bean으로 등록하고 있기 때문에 SecurityConfiguration에 추가설정 불필요.Exception 이미 저장되어 있는 유저 정보로 로그인 시도 ⇒ 공포의 no_session 예외 발생 영속성 유지를 위해 AuthenticationProviderService클래스의 authenticate 메소드에 @Transaction 설정역할, 권한에 따른 접근 제한은 나중에…." }, { "title": "Spring Security, Csrf", "url": "/posts/security_csrf(2)/", "categories": "Spring, Security", "tags": "back-end, spring, security, csrf", "date": "2024-02-23 10:50:00 +0900", "snippet": "- Csrf(cross site request forgery) A 사이트에 로그인, 사용자 권한 획득 사용자가 웹 어플레케이션에 로그인 했다고 가정하며 사용자는 공격자에게 속아서직업중인 같은 어플리케이션에서 작업을 실행하는 스크립트가 포함된 페이지가 열리면서 공격 Spring Security에서는 해당 공격을 막기 위한 옵션이 자동으로...", "content": "- Csrf(cross site request forgery) A 사이트에 로그인, 사용자 권한 획득 사용자가 웹 어플레케이션에 로그인 했다고 가정하며 사용자는 공격자에게 속아서직업중인 같은 어플리케이션에서 작업을 실행하는 스크립트가 포함된 페이지가 열리면서 공격 Spring Security에서는 해당 공격을 막기 위한 옵션이 자동으로 설정되어있음. 서버쪽에 토큰값을 Cookie 형태로 저장. 해당 구성을 확인하기 위한 Filter 추가. CsrfTokenRepository를 직접 구현하여 설정을 바꿀 수 있음. CsrfTokenLoggerFilter Spring Security 가 자동으로 생성해주는 csrf 토큰 확인.@Slf4j@Componentpublic class CsrfTokenLoggerFilter implements Filter { @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain filterChain) throws IOException, ServletException { Object o = request.getAttribute(\"_csrf\"); CsrfToken csrfToken = (CsrfToken) o; log.info(\"csrfToken.getParameterName = {}\", csrfToken.getParameterName()); log.info(\"csrfToken.getHeaderName = {}\", csrfToken.getHeaderName()); log.info(\"csrfToken.getToken = {}\", csrfToken.getToken()); filterChain.doFilter(request, response); }}CsrfTokenLoggerFilter defaultSecurityFilterChain 해당 메소드안에 .addFilterAfter()로 추가.@Slf4j@Configuration@RequiredArgsConstructorpublic class AngrySecurityConfiguration { private final CustomCorsConfig customCorsConfig; private final CsrfTokenLoggerFilter csrfTokenLoggerFilter; @Bean public SecurityFilterChain defaultSecurityFilterChain(HttpSecurity http) throws Exception { CsrfTokenRequestAttributeHandler requestHandler = new CsrfTokenRequestAttributeHandler(); requestHandler.setCsrfRequestAttributeName(\"_csrf\"); http .addFilterAfter(csrfTokenLoggerFilter, BasicAuthenticationFilter.class) // .cors((cors) -&gt; cors.configurationSource(customCorsConfig)) .authorizeHttpRequests( (requests) -&gt; requests.anyRequest().authenticated() ) .formLogin(withDefaults()) .httpBasic(withDefaults()); return http.build(); } @Bean public InMemoryUserDetailsManager inMemoryUserDetailsManager() { UserDetails admin = org.springframework.security.core.userdetails.User.withUsername(\"admin\").password(\"12345\").roles(\"admin\").build(); UserDetails user = org.springframework.security.core.userdetails.User.withUsername(\"user\").password(\"12345\").roles(\"user\").build(); UserDetails guest = org.springframework.security.core.userdetails.User.withUsername(\"guest\").password(\"12345\").roles(\"guest\").build(); return new InMemoryUserDetailsManager(admin, user, guest); } @Bean public PasswordEncoder passwordEncoder() { return NoOpPasswordEncoder.getInstance(); // ToBE bcrypt }}로그 확인 실제로 로그인 인증이 완료된 후에 값이 저장되는지 확인 csrf옵션을 활성화한다. HttpServletRequest를 이용해 쿠키값을 확인해본다. CsrfTokenValidFilter@Slf4j@Componentpublic class CsrfTokenValidFilter implements Filter { @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain filterChain) throws IOException, ServletException { HttpServletRequest httpServletRequest = (HttpServletRequest) request; Cookie[] cookies = ((HttpServletRequest) request).getCookies(); Cookie _XSRF_TOKEN = null; if (cookies != null) { for (Cookie cookie : cookies) { if (\"XSRF-TOKEN\".equals(cookie.getName())) { _XSRF_TOKEN = cookie; } } } if (_XSRF_TOKEN != null) { log.info(\"XSRF-TOKEN = {}\", _XSRF_TOKEN); log.info(\"XSRF-TOKEN.getName() = {}\", _XSRF_TOKEN.getName()); log.info(\"XSRF-TOKEN.getValue() = {}\", _XSRF_TOKEN.getValue()); } HttpSession session = httpServletRequest.getSession(); Enumeration&lt;String&gt; attributeNames = session.getAttributeNames(); while (attributeNames.hasMoreElements()) { String name = attributeNames.nextElement(); Object attribute = session.getAttribute(name); log.info(\"attribute = {}\", attribute); } filterChain.doFilter(request, response); }} csrfTokenLoggerFilter를 추가한것과 마찬가지로 필터 추가 http .addFilterAfter(csrfTokenLoggerFilter, BasicAuthenticationFilter.class) // .addFilterAfter(csrfTokenValidFilter, BasicAuthenticationFilter.class) .cors((cors) -&gt; cors.configurationSource(customCorsConfig)) .csrf((csrf)-&gt; csrf.csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse())) .authorizeHttpRequests( (requests) -&gt; requests.anyRequest().authenticated() ) .formLogin(withDefaults()) .httpBasic(withDefaults()); CsrfToken 설명 public interface CsrfToken extends Serializable { /** * Gets the HTTP header that the CSRF is populated on the response and can be placed * on requests instead of the parameter. Cannot be null. * @return the HTTP header that the CSRF is populated on the response and can be * placed on requests instead of the parameter */ String getHeaderName(); /** * Gets the HTTP parameter name that should contain the token. Cannot be null. * @return the HTTP parameter name that should contain the token. */ String getParameterName(); /** * Gets the token value. Cannot be null. * @return the token value */ String getToken();}" }, { "title": "Spring Security, Csrf 검증 필터", "url": "/posts/security_csrf(2)/", "categories": "Exception, Security", "tags": "back-end, spring, security, csrf", "date": "2024-02-22 21:40:00 +0900", "snippet": " Spring Security Csrf 설정중 생긴 문제 Csrf 공격 모방을 실제로 하기 힘들어 csrf test 코드 작성중 생긴 문제 perform 메소드 에서 인자로 with(csrf().asHeader().userInvalidToken())을 넘길시 상태 코드가 200으로 넘어오는 문제 테스트에...", "content": " Spring Security Csrf 설정중 생긴 문제 Csrf 공격 모방을 실제로 하기 힘들어 csrf test 코드 작성중 생긴 문제 perform 메소드 에서 인자로 with(csrf().asHeader().userInvalidToken())을 넘길시 상태 코드가 200으로 넘어오는 문제 테스트에 사용한 코드 @SpringBootTestpublic abstract class SecuritySetup { @Autowired private WebApplicationContext wac; @Autowired protected CustomCorsConfig customCorsConfig; protected CorsConfiguration corsConfiguration; protected MockHttpServletRequest httpServletRequest = new MockHttpServletRequest(); protected MockMvc mockMvc; @BeforeEach public void setup() { mockMvc = MockMvcBuilders .webAppContextSetup(wac) .apply(springSecurity()) .build(); corsConfiguration = customCorsConfig.getCorsConfiguration(httpServletRequest); }}public class SecurityCsrfTest extends SecuritySetup { @Test void get_basic_get_pass() throws Exception { mockMvc.perform(options(\"/basic\") .with(csrf().asHeader().useInvalidToken()) .header(\"Origin\", corsConfiguration.getAllowedOrigins()) .header(\"Access-Control-Request-Method\", \"GET\") ) .andExpect(status().isForbidden()) .andDo(print()); }} SecurityConfiguration @Slf4j@Configuration@RequiredArgsConstructorpublic class AngrySecurityConfiguration { private final CsrfCookieFilter csrfCookieFilter; private final CustomCorsConfig customCorsConfig; @Bean public SecurityFilterChain defaultSecurityFilterChain(HttpSecurity http) throws Exception { CsrfTokenRequestAttributeHandler requestHandler = new CsrfTokenRequestAttributeHandler(); requestHandler.setCsrfRequestAttributeName(\"_csrf\"); http .cors((cors) -&gt; cors.configurationSource(customCorsConfig)) .csrf((csrf) -&gt; csrf. csrfTokenRequestHandler(requestHandler) // csrf .csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse())) .addFilterAfter(csrfCookieFilter, BasicAuthenticationFilter.class) .authorizeHttpRequests( (requests) -&gt; requests.anyRequest().permitAll() ) .formLogin(withDefaults()) .httpBasic(withDefaults()); return http.build(); } @Bean public InMemoryUserDetailsManager inMemoryUserDetailsManager() { UserDetails admin = org.springframework.security.core.userdetails.User.withUsername(\"admin\").password(\"12345\").roles(\"admin\").build(); UserDetails user = org.springframework.security.core.userdetails.User.withUsername(\"user\").password(\"12345\").roles(\"user\").build(); UserDetails guest = org.springframework.security.core.userdetails.User.withUsername(\"guest\").password(\"12345\").roles(\"guest\").build(); return new InMemoryUserDetailsManager(admin, user, guest); } @Bean public PasswordEncoder passwordEncoder() { return NoOpPasswordEncoder.getInstance(); // ToBE bcrypt }} CsrfCookieFilter @Componentpublic class CsrfCookieFilter extends OncePerRequestFilter { // OncePerRequestFilter : HttpServletRequest 에 대해 한번만 필터가 실행되는것을 보장함. @Override protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException { CsrfToken csrfToken = (CsrfToken) request.getAttribute(CsrfToken.class.getName()); if (null != csrfToken.getHeaderName()) { response.setHeader(csrfToken.getHeaderName(), csrfToken.getToken()); } filterChain.doFilter(request, response); }} 의심 되는 부분을 디버깅 해본 결과 CsrfCookieFilter 해당 필터를 안거치는 문제 확인." }, { "title": "Spring Security, CorsConfiguration", "url": "/posts/security_cors(1)/", "categories": "Spring, Security", "tags": "back-end, spring, security, cors", "date": "2024-02-21 15:15:00 +0900", "snippet": " User, Role, Auth 아래 참조.참조 CorsConfigurer cors 공격을 막기 위해 CorsConfigurer 를 구현하여 적용시켜야함. cors가 뭘까? cors http headers를 이용하여 요청을 제한하는것. 요청을 제한하지 않고 모두 허용한다면 copy 사이트를 만들어 사용자의 로그인을 유도...", "content": " User, Role, Auth 아래 참조.참조 CorsConfigurer cors 공격을 막기 위해 CorsConfigurer 를 구현하여 적용시켜야함. cors가 뭘까? cors http headers를 이용하여 요청을 제한하는것. 요청을 제한하지 않고 모두 허용한다면 copy 사이트를 만들어 사용자의 로그인을 유도 악용할 수 있음. Access-Control-Allow-Origin: 요청이 허용되는 출처를 나타내는 헤더 Access-Control-Allow-Methods: 허용되는 HTTP 메서드를 지정하는 헤더 Access-Control-Allow-Headers: 허용되는 HTTP 헤더를 지정하는 헤더 Access-Control-Allow-Credentials: 인증된 요청의 허용 여부를 나타내는 헤더 Access-Control-Expose-Headers: 브라우저에 노출할 헤더를 지정하는 헤더 구현 코드 Security 6.x.x 버전으로 올라오면서 설정 방식이 많이 바뀌었음으로 버전 확인 필요 Spring Boot Version : 3.2.2 Java Version : 17 Spring Security Version : 6.2.1 CustomCorsConfig@Componentpublic class CustomCorsConfig implements CorsConfigurationSource { @Override public CorsConfiguration getCorsConfiguration(HttpServletRequest request) { CorsConfiguration corsConfiguration = new CorsConfiguration(); corsConfiguration.setAllowedOrigins(Collections.singletonList(\"http://localhost:18231\")); corsConfiguration.setAllowedMethods(Collections.singletonList(\"*\")); corsConfiguration.setAllowCredentials(true); corsConfiguration.setAllowedHeaders(Collections.singletonList(\"*\")); corsConfiguration.setMaxAge(3600L); return corsConfiguration; }} SecurityFilterChain에 적용@Slf4j@Configuration@RequiredArgsConstructorpublic class AngrySecurityConfiguration { private final CustomCorsConfig customCorsConfig; @Bean public SecurityFilterChain defaultSecurityFilterChain(HttpSecurity http) throws Exception { http .cors((cors) -&gt; cors.configurationSource(customCorsConfig)) .authorizeHttpRequests( (requests) -&gt; requests.anyRequest().permitAll() ) .formLogin(withDefaults()) .httpBasic(withDefaults()); return http.build(); } @Bean public InMemoryUserDetailsManager inMemoryUserDetailsManager() { UserDetails admin = org.springframework.security.core.userdetails.User.withUsername(\"admin\").password(\"12345\").roles(\"admin\").build(); UserDetails user = org.springframework.security.core.userdetails.User.withUsername(\"user\").password(\"12345\").roles(\"user\").build(); UserDetails guest = org.springframework.security.core.userdetails.User.withUsername(\"guest\").password(\"12345\").roles(\"guest\").build(); return new InMemoryUserDetailsManager(admin, user, guest); } @Bean public PasswordEncoder passwordEncoder() { return NoOpPasswordEncoder.getInstance(); // ToBE bcrypt }} 테스트 코드 작성 MockMvc의 추가 설정을 통해 test 코드에서 security 테스트 진행 가능. security test 코드 기본 설정 @SpringBootTestpublic abstract class SecuritySetup { @Autowired private WebApplicationContext wac; @Autowired protected CustomCorsConfig customCorsConfig; protected CorsConfiguration corsConfiguration; protected MockHttpServletRequest httpServletRequest = new MockHttpServletRequest(); protected MockMvc mockMvc; @BeforeEach public void setup() { mockMvc = MockMvcBuilders .webAppContextSetup(wac) .apply(springSecurity()) .build(); corsConfiguration = customCorsConfig.getCorsConfiguration(httpServletRequest); }} WebApplicationContext : MockMvc 추가 설정을 위해 필요. CustomCorsConfig : 내가 구성한 Cors 구성 정보를 로드하는데 필요. CorsConfiguration : 내가 구성한 Cors 구성 정보를 로드하는데 필요. MockHttpServletRequest : 내가 구성한 Cors 구성 정보를 로드하는데 필요. 왜 그런지는 모르겠으나 MockMvc 에서 perform 메소드를 이용하여 cors 테스트를 할시 작동이 예상과 다르게됨. 찾아보니 options를 이용하여 테스트를 해야 한다고함.그래서 header 에 Access-Control-Request-Method 추가. Access-Control-Request-Method : 브라우저가 서버로 보내는 사전 요청에서, 어떤 메서드를 사용할 것인지 서버에게 알리기 위해 사용 설정한 Cors 에서는 localhost:18231 에서 들어온 모든 요청을 요청 메소드 상관없이 허용 다른 호스트에서 요청할시 403 에러가 발생해야함.public class SecurityCorsTest extends SecuritySetup { @Test void get_basic_get_pass() throws Exception { mockMvc.perform(options(\"/basic\") .header(\"Origin\", corsConfiguration.getAllowedOrigins()) .header(\"Access-Control-Request-Method\", \"GET\") ) .andExpect(status().isOk()) .andDo(print()); } @Test void get_basic_post_pass() throws Exception { mockMvc.perform(options(\"/basic\") .header(\"Origin\", corsConfiguration.getAllowedOrigins()) .header(\"Access-Control-Request-Method\", \"POST\") ) .andExpect(status().isOk()) .andDo(print()); } @Test void get_basic_get_fail() throws Exception { mockMvc.perform(options(\"/basic\") .header(\"Origin\", \"https://www.google.com\") .header(\"Access-Control-Request-Method\", \"GET\") ) .andExpect(status().is4xxClientError()) .andDo(print()); } @Test void get_basic_post_fail() throws Exception { mockMvc.perform(options(\"/basic\") .header(\"Origin\", \"https://www.google.com\") .header(\"Access-Control-Request-Method\", \"POST\") ) .andExpect(status().is4xxClientError()) .andDo(print()); }}" }, { "title": "one to many(1)", "url": "/posts/one_to_many(1)/", "categories": "Spring, Jpa", "tags": "back-end, spring, jpa, hibernate, one to many", "date": "2024-02-21 03:40:00 +0900", "snippet": " 일대다 양방향 연관관계 매핑 Customer : OrderHeader Customer Entity, Customer Dto Customer Entity@Entity@Getter@Table(name = \"customer\")@NoArgsConstructor(access = AccessLevel.PROTECTED)publi...", "content": " 일대다 양방향 연관관계 매핑 Customer : OrderHeader Customer Entity, Customer Dto Customer Entity@Entity@Getter@Table(name = \"customer\")@NoArgsConstructor(access = AccessLevel.PROTECTED)public class Customer { @Id @Column(name = \"id\", nullable = false, updatable = false, unique = true) @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @Column(name = \"customer_email\", nullable = false, updatable = false, unique = true) private String customerEmail; @Column(name = \"first_name\", nullable = false) private String firstName; @Column(name = \"last_name\", nullable = false) private String lastName; @Column(name = \"address\", nullable = false) private String address; @Setter @Column(name = \"phone\", nullable = false) private String phone; @OneToMany(mappedBy = \"customer\") private List&lt;OrderHeader&gt; orderHeaders = new ArrayList&lt;&gt;(); @Builder public Customer(String customerEmail, String firstName, String lastName, String address, String phone) { this.customerEmail = customerEmail; this.firstName = firstName; this.lastName = lastName; this.address = address; this.phone = phone; } public CustomerDto toDto() { return CustomerDto.builder() .customerEmail(customerEmail) .firstName(firstName) .lastName(lastName) .address(address) .phone(phone) .build(); }} Customer Dto@Getter@Setter@Builder@ToString@NoArgsConstructor@AllArgsConstructorpublic class CustomerDto { @NotEmpty @NotNullEmail @IdDuplicateCheck(tableName = \"customer\", columnName = \"customer_email\") private String customerEmail; @NotBlank private String firstName; @NotBlank private String lastName; @NotBlank private String address; @NotBlank private String phone; public Customer toEntity() { return Customer.builder() .customerEmail(customerEmail) .firstName(firstName) .lastName(lastName) .address(address) .phone(phone) .build(); }} OrderHeader Entity, OrderHeader Dto OrderHeader Entity@Entity@Getter@Table(name = \"order_header\")@NoArgsConstructor(access = AccessLevel.PROTECTED)public class OrderHeader { @Id @Column(name = \"id\", nullable = false, updatable = false, unique = true) @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @Column(name = \"order_date\", nullable = false, updatable = false) private LocalDateTime orderDate; @ManyToOne @JoinColumn(name = \"customer_id\", updatable = false) private Customer customer; @PrePersist private void prePersist() { orderDate = LocalDateTime.now(); } // entity 가 영구 저장되기 전에 생성되어서 insert 된다. @Builder public OrderHeader(Customer customer) { this.customer = customer; } public OrderHeaderDto toDto() { return OrderHeaderDto.builder() .customer(customer) .orderDate(orderDate) .build(); }} OrderHeader Dto@Getter@Setter@ToString@NoArgsConstructorpublic class OrderHeaderDto { private Customer customer; private LocalDateTime orderDate; @Builder public OrderHeaderDto(Customer customer, LocalDateTime orderDate) { this.customer = customer; this.orderDate = orderDate; } public OrderHeader toEntity() { return OrderHeader.builder() .customer(customer) .build(); }} 테스트 코드 RepositorySetup : 저장소 테스트 기본 설정 클래스 RepositoryTest : 실제로 테스트가 실행되는 클래스 RepositorySetup@DataJpaTest@TestMethodOrder(MethodOrderer.OrderAnnotation.class)@AutoConfigureTestDatabase(replace = AutoConfigureTestDatabase.Replace.NONE)public abstract class RepositorySetup { @Autowired protected CustomerRepository customerRepository; @Autowired protected OrderHeaderRepository orderHeaderRepository; protected CustomerDto customerDto; @BeforeEach void beforeEach() { customerDto = CustomerDto.builder() .customerEmail(\"johnDoe@gmail.com\") .firstName(\"john\") .lastName(\"doe\") .address(\"동작대로 xx길 xxx xx\") .phone(\"555-0101\") .build(); } @AfterEach void afterEach() { customerDto = CustomerDto.builder() .customerEmail(\"johnDoe@gmail.com\") .firstName(\"john\") .lastName(\"doe\") .address(\"동작대로 xx길 xxx xx\") .phone(\"555-0101\") .build(); }} RepositoryTest@Slf4jpublic class RepositoryTest extends RepositorySetup { @Test @Order(1) void initializer() { } @Test @Order(2) void customer_save_OK() { Customer saveCustomer = customer_save(customerDto.toEntity()); Assertions.assertEquals(customerDto.getCustomerEmail(), saveCustomer.getCustomerEmail()); Assertions.assertEquals(customerDto.getFirstName(), saveCustomer.getFirstName()); Assertions.assertEquals(customerDto.getLastName(), saveCustomer.getLastName()); Assertions.assertEquals(customerDto.getAddress(), saveCustomer.getAddress()); Assertions.assertEquals(customerDto.getPhone(), saveCustomer.getPhone()); } @Test @Order(3) void order_header_save_OK() { Customer saveCustomer = customer_save(customerDto.toEntity()); OrderHeader saveOrderHeader = orderHeaderRepository.save(order_header_dto(saveCustomer).toEntity()); Assertions.assertEquals(saveCustomer.getCustomerEmail(), saveOrderHeader.getCustomer().getCustomerEmail()); Assertions.assertEquals(saveCustomer.getFirstName(), saveOrderHeader.getCustomer().getFirstName()); Assertions.assertEquals(saveCustomer.getLastName(), saveOrderHeader.getCustomer().getLastName()); Assertions.assertEquals(saveCustomer.getAddress(), saveOrderHeader.getCustomer().getAddress()); Assertions.assertEquals(saveCustomer.getPhone(), saveOrderHeader.getCustomer().getPhone()); } private Customer customer_save(Customer customer) { Customer save = customerRepository.save(customer); Assertions.assertNotNull(save); return save; } private OrderHeaderDto order_header_dto(Customer customer) { return OrderHeaderDto.builder() .customer(customer) .build(); }}" }, { "title": "Custom Method Argument Not Valid Exception", "url": "/posts/valid_request_body(1)/", "categories": "Spring, Validation", "tags": "back-end, spring, method argument not valid exception, controller advice", "date": "2024-02-20 17:30:00 +0900", "snippet": " Bean Validation 이용중 request body를 이용하여 요청 파라미터를 검증 할때에 에러 메세지를 field : error message 형태의 json 문자열로 리턴해주기 위한 설정이 필요 했음. 검증 대상이 될 Dto @Getter@Setter@Builder@ToString@NoArgsConstructor@A...", "content": " Bean Validation 이용중 request body를 이용하여 요청 파라미터를 검증 할때에 에러 메세지를 field : error message 형태의 json 문자열로 리턴해주기 위한 설정이 필요 했음. 검증 대상이 될 Dto @Getter@Setter@Builder@ToString@NoArgsConstructor@AllArgsConstructorpublic class CustomerDto { @NotNullEmail @IdDuplicateCheck(tableName = \"customer\", columnName = \"customer_id\") private String customerId; @NotBlank private String firstName; @NotBlank private String lastName; @NotBlank private String address; @NotBlank private String phone;} 테스트 컨트롤러 @Slf4j@RestController@RequiredArgsConstructor@RequestMapping(path = \"/test\")public class TestController { private final CustomerService customerService; @PostMapping(\"/customer-dto-validator\") public ResponseEntity&lt;String&gt; customDtoValidator(@Valid @RequestBody CustomerDto customerDto) { customerService.save(customerDto); log.info(\"customerDto = {}\", customerDto); return ResponseEntity.ok(\"valid pass\"); }} RequestBody 여기서 customerId는 이미 등록되어있는 id{ \"customerId\":\"johnDoe@gmail.com\", \"firstName\":\"john\", \"lastName\":\"doe\", \"address\":\"동작대로 xx길 xxx xx\", \"phone\":\"555-0101\"} 위와 같은 코드를 실행 시키면 customerId에서 아이디 중복이나기 때문에 BindingResult 의 값이 JSON 형태로 반환되어야함 아이디 중복 체크 포스팅 : 아이디 중복 체크 반환 텍스트{ \"timestamp\": \"2024-02-20T08:05:13.575+00:00\", \"status\": 400, \"error\": \"Bad Request\", \"trace\": \"...\", \"message\": \"Validation failed for object='customerDto'. Error count: 1\", \"errors\": [ { \"codes\": [ \"IdDuplicateCheck.customerDto.customerId\", \"IdDuplicateCheck.customerId\", \"IdDuplicateCheck.java.lang.String\", \"IdDuplicateCheck\" ], \"arguments\": [ { \"codes\": [ \"customerDto.customerId\", \"customerId\" ], \"arguments\": null, \"defaultMessage\": \"customerId\", \"code\": \"customerId\" }, { \"arguments\": null, \"defaultMessage\": \"customer_id\", \"codes\": [ \"customer_id\" ] }, { \"arguments\": null, \"defaultMessage\": \"customer\", \"codes\": [ \"customer\" ] } ], \"defaultMessage\": \"존재하는 아이디 입니다.\", \"objectName\": \"customerDto\", \"field\": \"customerId\", \"rejectedValue\": \"johnDoe@gmail.com\", \"bindingFailure\": false, \"code\": \"IdDuplicateCheck\" } ], \"path\": \"/test/customer-dto-validator\"} 반환된 데이터에는 쓸만한 데이터가 모두 있지만 너무 많은게 탈이다. 원하는 메세지만 사용자화 시켜 사용할 수 있어야함. 순서 1 ] BindingResult 를 인자로 받는CustomArgumentNotValidException 생성 2 ] @RestControllerAdvice 생성 3 ] @ExceptionHandler(CustomArgumentNotValidException.class) 생성 4 ] CustomArgumentNotValidException 의 BindingResult 로 부터 메세지 바인딩 후 리턴 5 ] 해당 기능을 사용할 컨트롤러에서 해당 예외를 터트려줘야함 CustomArgumentNotValidException RuntimeException 을 상속 받은후 컨트롤러에서 BindingResult 객체를 인자로 받아서 예외틑 터트린다.@Getterpublic class CustomArgumentNotValidException extends RuntimeException { private final BindingResult bindingResult; public CustomArgumentNotValidException(BindingResult bindingResult) { this.bindingResult = bindingResult; }} @RestControllerAdvice 예외를 프로젝트 내에서 전적으로 처리하여 예외 처리를 공통화@Slf4j@RestControllerAdvicepublic class GlobalControllerAdvice {} @ExceptionHandler(CustomArgumentNotValidException.class) @RestControllerAdvice 에 예외 핸들러 추가 이제 CustomArgumentNotValidException 발생시 해당 처리기를 통해 예외가 처리된다. @Slf4j@RestControllerAdvicepublic class GlobalControllerAdvice { @ResponseStatus(HttpStatus.BAD_REQUEST) @ExceptionHandler(CustomArgumentNotValidException.class) public void handleCustomArgumentNotValidExceptions(CustomArgumentNotValidException ex) { }} CustomArgumentNotValidException 바인딩 예외가 발생하고 해당 예외가 포함하고 있는 BindingResult를 통해 에러 메세지를 커스텀화 한다. 간단하게 여기에서는 Map 형태로 key = field, value = error message 설정. @Slf4j@RestControllerAdvicepublic class GlobalControllerAdvice { @ResponseStatus(HttpStatus.BAD_REQUEST) @ExceptionHandler(CustomArgumentNotValidException.class) public Map&lt;String, String&gt; handleCustomArgumentNotValidExceptions(CustomArgumentNotValidException ex) { Map&lt;String, String&gt; errors = new HashMap&lt;&gt;(); List&lt;FieldError&gt; fieldErrors = ex.getBindingResult().getFieldErrors(); for (FieldError fieldError : fieldErrors) { errors.put(fieldError.getField(), fieldError.getDefaultMessage()); } log.info(\"errors = {}\", errors); return errors; }} 테스트 컨트롤러 글 맨 처음에 설명했던 테스트 컨트롤러를 이용해서 값을 검증할 때 BindingResult 처리부분 추가. 수정된 컨트롤러 BindingResult 를 인자로 받고, 에러 검증을 하는 코드, 예외를 발생시키는 코드가 추가됨. @Slf4j@RestController@RequiredArgsConstructor@RequestMapping(path = \"/test\")public class TestController { private final CustomerService customerService; @PostMapping(\"/customer-dto-validator\") public ResponseEntity&lt;String&gt; customDtoValidator(@Valid @RequestBody CustomerDto customerDto, BindingResult bindingResult) { if (bindingResult.hasErrors()) { throw new CustomArgumentNotValidException(bindingResult); } else { customerService.save(customerDto); log.info(\"customerDto = {}\", customerDto); return ResponseEntity.ok(\"valid pass\"); } }}요청 결과 테스트 코드 설명 생략@Transactional@SpringBootTest@AutoConfigureMockMvc@TestMethodOrder(MethodOrderer.OrderAnnotation.class)public class ValidatorTest { @Autowired private MockMvc mockMvc; @Autowired private ObjectMapper objectMapper; @Autowired private MessageSource messageSource; @Autowired private CustomerRepository customerRepository; @Autowired private CustomerService customerService; @Autowired private LocalValidatorFactoryBean validator; private CustomerDto customerDto; @BeforeEach void beforeEach() { customerDto = CustomerDto.builder() .customerId(\"johnDoe@gmail.com\") .firstName(\"john\") .lastName(\"doe\") .address(\"동작대로 xx길 xxx xx\") .phone(\"555-0101\") .build(); } @BeforeEach void afterEach() { customerDto = CustomerDto.builder() .customerId(\"johnDoe@gmail.com\") .firstName(\"john\") .lastName(\"doe\") .address(\"동작대로 xx길 xxx xx\") .phone(\"555-0101\") .build(); customerRepository.deleteCustomerByCustomerId(customerDto.getCustomerId()); } @Test @Order(1) void id_duplicated_validator() { Set&lt;ConstraintViolation&lt;CustomerDto&gt;&gt; validated = validator.validate(customerDto); Assertions.assertEquals(0, validated.size()); customerService.save(customerDto); validated = validator.validate(customerDto); Assertions.assertEquals(1, validated.size()); ConstraintViolation&lt;CustomerDto&gt; violation = validated.iterator().next(); String errorMessage = violation.getMessage(); Assertions.assertEquals(messageSource.getMessage(\"validation.duplicated.id\", null, Locale.KOREA), errorMessage); } @Test @Order(2) void validator_integrated_test_valid_pass() throws Exception { ResultActions resultActions = customerDtoValidatorRequest(customerDto); resultActions.andExpect(MockMvcResultMatchers.status().isOk()); String responseBody = resultActions.andReturn().getResponse().getContentAsString(); Assertions.assertEquals(\"valid pass\", responseBody); } @Test @Order(3) void validator_integrated_test_valid_fail_case1_emptyId() throws Exception { String notNullEmail = messageSource.getMessage(\"validation.not.null.email\", null, Locale.getDefault()); customerDto.setCustomerId(\"\"); ResultActions resultActions = customerDtoValidatorRequest(customerDto); resultActions.andExpect(MockMvcResultMatchers.status().isBadRequest()); resultActions.andExpect(MockMvcResultMatchers.jsonPath(\"$.customerId\", Is.is(notNullEmail))); } @Test @Order(4) void validator_integrated_test_valid_fail_case2_duplicateId() throws Exception { CustomerDto save = customerService.save(customerDto); Assertions.assertNotNull(save); String duplicateId = messageSource.getMessage(\"validation.duplicated.id\", null, Locale.getDefault()); ResultActions resultActions = customerDtoValidatorRequest(customerDto); resultActions.andExpect(MockMvcResultMatchers.status().isBadRequest()); resultActions.andExpect(MockMvcResultMatchers.jsonPath(\"$.customerId\", Is.is(duplicateId))); } private ResultActions customerDtoValidatorRequest(CustomerDto customerDto) throws Exception { String req = objectMapper.writeValueAsString(customerDto); return mockMvc.perform( MockMvcRequestBuilders .post(\"/test/customer-dto-validator\") .content(req) .contentType(MediaType.APPLICATION_JSON_VALUE) ).andDo(MockMvcResultHandlers.print()); }} 결과 " }, { "title": "아이디 중복 체크와 bean validation", "url": "/posts/id_duplicate_check/", "categories": "Spring, Validation", "tags": "back-end, spring, id duplicate check, controller advice", "date": "2024-02-20 09:30:00 +0900", "snippet": " 과거에 작성한 코드를 보다 보니 테이블에서 pk에 해당하는 데이터가 존재 하는지 판단해야하는 검증 로직들이 항상 서비스 코드마다 들어가 있음.예를 들면 아래와 같은 코드들임@Overridepublic MemberDto getMemberDetail(Long id){ return memberRepository .findById(id) .orEls...", "content": " 과거에 작성한 코드를 보다 보니 테이블에서 pk에 해당하는 데이터가 존재 하는지 판단해야하는 검증 로직들이 항상 서비스 코드마다 들어가 있음.예를 들면 아래와 같은 코드들임@Overridepublic MemberDto getMemberDetail(Long id){ return memberRepository .findById(id) .orElseThrow(()-&gt;new ResourceNotFoundException(\"Member\",\"id\",id)) .toDto(); }해당 코드를 더 자세히 파헤쳐보면 아래와 같이 @ControllerAdvice 를 통해 예외 메세지를 반환하고 있음.@ControllerAdvicepublic class GlobalExceptionHandler { @ExceptionHandler(ResourceNotFoundException.class) public ResponseEntity&lt;ErrorDetails&gt; handlerResourceNotFoundException( ResourceNotFoundException exception, WebRequest webRequest ) { return new ResponseEntity&lt;&gt;( ErrorDetails.builder() .timeStamp(THIS_LOCAL_DATE_TIME) .message(exception.getMessage()) .details(webRequest.getDescription(false)) // 에러 발생지를 알려준다. .build() , HttpStatus.NOT_FOUND); } // 해당 리소스가 없을때 예외를 반환한다. ex) detail 페이지 등등....}그러다 문득 Bean Validation 을 사용 하여 요청 파라미터에 대한 검증을 실시할 때 DB에 직접 접근 해서 해당 처리도 같이 할 수 없을지 굼긍 해졌음.아이디어는 @IdDuplicateCheck 와 같은 어노테이션을 만들고 어노테이션 파라미터로 tableName, columnName, field value 를받아서 검증기를 만들고 해당 검증기에서 JdbcTemplate 를 이용해서 카운팅을 통한 처리를 하는것임. 생성 목록 @IdDuplicateCheck IdDuplicateCheckValidator @IdDuplicateCheck 기존에 Spring bean validation 에서 사용 되고 있는 validation관련 어노테이션중 중 적당한 클래스를 copy, modify@Target({METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE})@Retention(RUNTIME)@Repeatable(List.class)@Documented@Constraint(validatedBy = {IdDuplicateCheckValidator.class})public @interface IdDuplicateCheck { String message() default \"{validation.duplicated.id}\"; Class&lt;? extends Payload&gt;[] payload() default {}; Class&lt;?&gt;[] groups() default {}; String tableName(); String columnName(); @Target({METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE}) @Retention(RUNTIME) @Documented @interface List { IdDuplicateCheck[] value(); }} 중요 설정 @Constraint(validatedBy = {IdDuplicateCheckValidator.class}) 해당 어노테이션이 선언 되었을떄 어떤 검증기를 통해 검증을 할것인지 선언해주는 부분 String tableName(), String columnName() 어노테이션 파라미터로 전달받을 값 선언. String message() default \"{validation.duplicated.id}\" default 검증 실패 메세지 설정 IdDuplicateCheckValidator 실제로 어노테이션을 통한 검증을 진행할 검증기.@Slf4j@Component@RequiredArgsConstructorpublic class IdDuplicateCheckValidator implements ConstraintValidator&lt;IdDuplicateCheck, CharSequence&gt; { private final JdbcTemplate jdbcTemplate; private String tableName; private String columnName; @Override public void initialize(IdDuplicateCheck parameters) { tableName = parameters.tableName(); columnName = parameters.columnName(); validateParameters(); } @Override public boolean isValid(CharSequence charSequence, ConstraintValidatorContext context) { String sql = String.format(\"select count(*) from %s where %s = ?\", tableName, columnName); Integer value = jdbcTemplate.queryForObject(sql, Integer.class, charSequence.toString()); if (value == null) throw new NullPointerException(\"jdbcTemplate.queryForObject(sql, Integer.class) is null\"); return value == 0; } private void validateParameters() { if (validate(tableName) || validate(columnName)) { throw new RuntimeException(\"ToDO\"); } } private boolean validate(String value) { return value == null || value.isEmpty(); }} public void initialize(IdDuplicateCheck parameters) 어노테이션에서 전달받은 인자값을 검증해주는부분. private void validateParameters(), private boolean validate(String value) 간단한 테이블과 컬럼 검증 로직을 실행 시켜주는 부분 public boolean isValid(CharSequence charSequence, ConstraintValidatorContext context) 전달받은 인자값들에 이상이 없을 경우 실질적인 중복 체크 로직을 실행 시켜주는 부분 테스트 코드 실제로 등록된 검증기를 실행시켜야 하기 떄문에 @SpringBootTest 선언 @SpringBootTestpublic class ValidatorTest { @Autowired private CustomerService customerService; @Autowired private LocalValidatorFactoryBean validator; @Autowired private MessageSource messageSource; private CustomerDto customerDto; @BeforeEach void beforeEach() { customerDto = CustomerDto.builder() .customerId(\"johnDoe@gmail.com\") .firstName(\"john\") .lastName(\"doe\") .address(\"동작대로 xx길 xxx xx\") .phone(\"555-0101\") .build(); } @Test void id_duplicated_validator() { Set&lt;ConstraintViolation&lt;CustomerDto&gt;&gt; validated = validator.validate(customerDto); Assertions.assertEquals(0, validated.size()); customerService.save(customerDto); validated = validator.validate(customerDto); Assertions.assertEquals(1, validated.size()); ConstraintViolation&lt;CustomerDto&gt; violation = validated.iterator().next(); String errorMessage = violation.getMessage(); Assertions.assertEquals(messageSource.getMessage(\"validation.duplicated.id\", null, Locale.KOREA), errorMessage); }} CustomerService : 실제로 save 로직을 태운후 에러 메세지가 리턴 되는지 확인하기 위한 주입 LocalValidatorFactoryBean : 검증기에 직접 Object 를 넣어서 예외 처리가 잘 되는지 확인을 위한 주입 테스트 방법 1 ] 가입이 안된 id를 검증기에 태우고 검즘 메세지가 출력되는지 확인. 예상대로 출력이 안되면 save 실행 2 ] 다시 같은 id로 가입을 시도, 이후 검증기를 태우고 검증 메세지가 출력 되는지 확인 예상대로 출력되면 검증 메세지 확인 성공" }, { "title": "Service Layer 테스트 코드", "url": "/posts/service_layer(1)/", "categories": "Spring, Test Code", "tags": "back-end, spring, test code, mockito, service layer, stubbing", "date": "2024-02-20 05:00:00 +0900", "snippet": " 서비스 계층 테스트 서비스 계층 테스트가 유용한 이유. 서비스 레이어에서는 직접적으로 Spring 에 접근하여 테스트할 필요 없이 코드의 비지니스 로직만을 테스트 할 수 있게 해야 하기 때문에 @SpringBootTest나 @DataJpaTest와 같은 테스트 실행시 build 에 시간이 오래 소요되는 작업을 스킵할 수 있음. ...", "content": " 서비스 계층 테스트 서비스 계층 테스트가 유용한 이유. 서비스 레이어에서는 직접적으로 Spring 에 접근하여 테스트할 필요 없이 코드의 비지니스 로직만을 테스트 할 수 있게 해야 하기 때문에 @SpringBootTest나 @DataJpaTest와 같은 테스트 실행시 build 에 시간이 오래 소요되는 작업을 스킵할 수 있음. 수행되는 속도가 빠름으로 내가 만든 로직을 만들어가면서 계속 테스트할 수 있음. 유지보수성, 테스트 용이성, 확장성을 증가 시킬 수 있음. @ExtendWith(MockitoExtension.class) Mockito를 테스트 클래스에서 사용하게 해줌. Mock, Stub 객체를 생성할 수 있게 해줌 @Mock 가짜 구현체를 선언하게 해줌 가짜 구현체를 통해 특정 행위를 Stubbing 하고 값을 return 받는것처럼 꾸며줌 테스트의 대상이 되는 객체의 의존성 주입을 위한 선언 예를 들어 AService 가 의존하고 있는 ARepository 가 있다고 할때 ARepository 를 @Mock 한다. @InjectMocks 가짜 구현체를 선언하게 해줌 테스트의 대상이 되는 객체 선언 예를 들어 AService 가 의존하고 있는 ARepository 가 있다고 할때 AService 를 @InjectMocks 한다. @BeforeEach 각각의 테스트가 실행되기 전 항상 실행되게 하는 어노테이션, 테스트 오브젝트간 독립성 유지를 위해 사용한다. @AfterEach도 있다. when().thenReturn(); when(customerRepository.save(any(Customer.class))).thenReturn(customerDto.toEntity()) 위의 코드는 when(...) 이 일어나면 thenReturn(...)를 반환한다는 선언 이걸 stubbing 라고 한다. 테스트 예시가될 Service 코드와 메소드 진짜로 서비스 코드의 로직을 실행시키는지 테스트를 하기 위해 로직이 실행된 후 phone 값을 임의로 변경.@Slf4j@Service@RequiredArgsConstructorpublic class CustomerServiceImpl implements CustomerService { private final CustomerRepository customerRepository; @Override public CustomerDto save(CustomerDto customerDto) { Customer save = customerRepository.save(customerDto.toEntity()); log.info(\"save entity = {}\", save); save.setPhone(\"mock test!!!\"); return save.toDto(); }} 테스트 코드 import lombok.extern.slf4j.Slf4j;import org.junit.jupiter.api.Assertions;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.Test;import org.junit.jupiter.api.extension.ExtendWith;import org.mockito.InjectMocks;import org.mockito.Mock;import org.mockito.junit.jupiter.MockitoExtension;import org.spring.example.jpa.dto.CustomerDto;import org.spring.example.jpa.entity.Customer;import org.spring.example.jpa.service.CustomerServiceImpl;import static org.mockito.ArgumentMatchers.any;import static org.mockito.Mockito.when;@Slf4j@ExtendWith(MockitoExtension.class)public class RepositoryTest { @Mock private CustomerRepository customerRepository; @InjectMocks private CustomerServiceImpl customerService; private CustomerDto customerDto; @BeforeEach void setUp() { customerDto = CustomerDto.builder() .customerId(\"johnDoe@gmail.com\") .firstName(\"john\") .lastName(\"doe\") .address(\"동작대로 xx길 xxx xx\") .phone(\"555-0101\") .build(); } @Test void customer_save_ok_1() { when(customerRepository.save(any(Customer.class))).thenReturn(customerDto.toEntity()); CustomerDto save = customerService.save(new CustomerDto()); Assertions.assertNotNull(save); Assertions.assertNotEquals(customerDto.getPhone(), save.getPhone()); Assertions.assertEquals(save.getPhone(), \"mock test!!!\"); }} 첫번째 필드 : 실제로 테스트의 대상이 되는 Service에 필요한 의존성을 @Mock 한다.@Mockprivate CustomerRepository customerRepository; 두번째 필드 : 실제로 테스트의 대상이 되는 Service를 설정한다.@InjectMocksprivate CustomerServiceImpl customerService; 세번째 필드 : subbing 될 객체를 전역 변수로 빼놓는다.(테스트 하기 쉽게 하기 위함.)private CustomerDto customerDto; void setUp() : 테스트 실행전 초기화 작업을 위해 설정, 해당 값을 stubbing에 사용할 예정.@BeforeEachvoid setUp() { customerDto = CustomerDto.builder() .customerId(\"johnDoe@gmail.com\") .firstName(\"john\") .lastName(\"doe\") .address(\"동작대로 xx길 xxx xx\") .phone(\"555-0101\") .build(); // public Customer toEntity() { // return Customer.builder() // .customerId(customerId) // .firstName(firstName) // .lastName(lastName) // .address(address) // .phone(phone) // .build(); // }} void customer_save_ok_1() : 실제 테스트가 될 코드 when(customerRepository.save(any(Customer.class))).thenReturn(customerDto.toEntity()) when 인자 값으로 customerRepository.save(any(Customer.class))가 실행되면 thenReturn 인자 값을 선언된 객체를 반환한다. 해당 테스트에서는 Customer 반환. any(Class&lt;T&gt; type) : 인자값으로 받을 클래스 타입 설정. 타입만 맞으면 thenReturn 을 보장하겠다는 표현. CustomerDto save = customerService.save(new CustomerDto()); when에 설정한 대로 클래스 타입만 맞춘 후 thenReturn 되는 stubbing 객체를 반환받음. 기타 검증을 위한 코드 Assertions.assertNotNull(save); 객체가 잘 리턴 되었는지 확인 Assertions.assertNotEquals(customerDto.getPhone(), save.getPhone()); 실제 서비스로직을 작동 시켰는지 확인, save 메소드 안에서 phone 값을 바꾸엇음으로 해당 검증은 통과되어야한다. Assertions.assertEquals(save.getPhone(),\"mock test!!!\"); 값이 바뀐것만으로는 못 믿겠으니까 실제 값을 비교 테스트 결과 Spring boot 안에 설정된 서비스를 실행시키는 테스트지만 실행 시간이 2.3초정도로 매우 짧다. 콘솔을 확인해보면 Spring Bean 들을 전혀 안긁어옴. 테스트 통과. " }, { "title": "Custom Email Validator", "url": "/posts/custom_email_validator/", "categories": "Spring, Validation", "tags": "back-end, spring, email validation", "date": "2024-02-20 00:30:00 +0900", "snippet": " @Email 기존 @Email 의 문제 해당 검증기를 구현하고있는 EmailValidator.class안에 isValid 부분에서 if(value == null) return true;부분이 email이 등록 안되어 있을때에 검증기가 통과됨. 개발중인 서비스에서 사용하려는 @Email은 PK로 작용해야 하기 때문에 커스텀 필요 ...", "content": " @Email 기존 @Email 의 문제 해당 검증기를 구현하고있는 EmailValidator.class안에 isValid 부분에서 if(value == null) return true;부분이 email이 등록 안되어 있을때에 검증기가 통과됨. 개발중인 서비스에서 사용하려는 @Email은 PK로 작용해야 하기 때문에 커스텀 필요 문제가된 EmailValidator.class 코드public class EmailValidator extends AbstractEmailValidator&lt;Email&gt; { private static final Log LOG = LoggerFactory.make(MethodHandles.lookup()); private java.util.regex.Pattern pattern; @Override public void initialize(Email emailAnnotation) { super.initialize(emailAnnotation); Pattern.Flag[] flags = emailAnnotation.flags(); int intFlag = 0; for (Pattern.Flag flag : flags) { intFlag = intFlag | flag.getValue(); } // we only apply the regexp if there is one to apply if (!\".*\".equals(emailAnnotation.regexp()) || emailAnnotation.flags().length &gt; 0) { try { pattern = java.util.regex.Pattern.compile(emailAnnotation.regexp(), intFlag); } catch (PatternSyntaxException e) { throw LOG.getInvalidRegularExpressionException(e); } } } @Override public boolean isValid(CharSequence value, ConstraintValidatorContext context) { if (value == null) { // 해당 부분 return true; // 해당 부분 } // 해당 부분 boolean isValid = super.isValid(value, context); if (pattern == null || !isValid) { return isValid; } Matcher m = pattern.matcher(value); return m.matches(); }} Custom @Email @NotNullEmail 검증기를 생성 1 ] @Email : 코드를 그대로 긁어서 해당 검증 부분만 변경 2 ] 검증기 등록 3 ] 테스트용 ExceptionHandler 생성, 및 테스트 코드 작성. Custom @NotNullEmail : @interface 클래스 @Documented@Constraint(validatedBy = {NotNullEmailValidator.class})@Target({METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE})@Retention(RUNTIME)@Repeatable(List.class)public @interface NotNullEmail { String message() default \"{jakarta.validation.constraints.Email.message}\"; Class&lt;?&gt;[] groups() default {}; Class&lt;? extends Payload&gt;[] payload() default {}; String regexp() default \".*\"; Pattern.Flag[] flags() default {}; @Target({METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE}) @Retention(RUNTIME) @Documented public @interface List { NotNullEmail[] value(); }} NotNullEmailValidator @Slf4jpublic class NotNullEmailValidator extends AbstractEmailValidator&lt;NotNullEmail&gt; { private java.util.regex.Pattern pattern; @Override public void initialize(NotNullEmail emailAnnotation) { super.initialize(emailAnnotation); Pattern.Flag[] flags = emailAnnotation.flags(); int intFlag = 0; for (Pattern.Flag flag : flags) { intFlag = intFlag | flag.getValue(); } if (!\".*\".equals(emailAnnotation.regexp()) || emailAnnotation.flags().length &gt; 0) { try { pattern = java.util.regex.Pattern.compile(emailAnnotation.regexp(), intFlag); } catch (PatternSyntaxException e) { log.error(\"patternSyntaxException = \", e); } } } @Override public boolean isValid(CharSequence value, ConstraintValidatorContext context) { if (value == null || value == \"\") { return false; } boolean isValid = super.isValid(value, context); if (pattern == null || !isValid) { return isValid; } Matcher m = pattern.matcher(value); return m.matches(); }} 테스트 컨트롤러 @PostMapping(\"/validator\") : 테스트용 handler TestReq.class : 검증기 테스트용 req 생성 handleValidationExceptions() : 메세지 검증용 핸들러@RestControllerpublic class ValidatorTestController { @PostMapping(\"/validator\") public ResponseEntity&lt;String&gt; addUser(@Valid @RequestBody TestReq testReq) { return ResponseEntity.ok(\"valid ok\"); } @Getter @Setter @ToString @NoArgsConstructor @AllArgsConstructor public static class TestReq { @NotNullEmail(message = \"is not null!!\") private String email; } @ResponseStatus(HttpStatus.BAD_REQUEST) @ExceptionHandler(MethodArgumentNotValidException.class) public Map&lt;String, String&gt; handleValidationExceptions( MethodArgumentNotValidException ex) { Map&lt;String, String&gt; errors = new HashMap&lt;&gt;(); ex.getBindingResult().getAllErrors().forEach((error) -&gt; { String fieldName = ((FieldError) error).getField(); String errorMessage = error.getDefaultMessage(); errors.put(fieldName, errorMessage); }); return errors; }} 테스트 코드 isBadRequest() : HttpStatus 검증 is(\"is not null!!\") : 검증 메세지 확인@SpringBootTest@AutoConfigureMockMvcpublic class ValidatorTest { @Autowired ValidatorTestController validatorTestController; @Autowired private MockMvc mockMvc; @Autowired private ObjectMapper objectMapper; @Test public void custom_email_validator_test() throws Exception { ValidatorTestController.TestReq testReq = new ValidatorTestController.TestReq(\"\"); String req = objectMapper.writeValueAsString(testReq); mockMvc.perform(MockMvcRequestBuilders.post(\"/validator\") .content(req) .contentType(MediaType.APPLICATION_JSON_VALUE)) .andExpect(MockMvcResultMatchers.status().isBadRequest()) .andExpect(MockMvcResultMatchers.jsonPath(\"$.email\", Is.is(\"is not null!!\"))); }}" }, { "title": "NotEmpty NotBlank NotNull", "url": "/posts/NotNull_NotEmpty_NotBlank/", "categories": "Spring, Validation", "tags": "back-end, spring, not empty, not blank, not null", "date": "2024-02-20 00:30:00 +0900", "snippet": " 검증기를 통한 검증을 진행할때 마다 헷갈려서 정리   null empty space @NotNull 허용하지 않음 허용 허용 @NotEmpty 허용하지 않음 허용하지 않음 허용 ...", "content": " 검증기를 통한 검증을 진행할때 마다 헷갈려서 정리   null empty space @NotNull 허용하지 않음 허용 허용 @NotEmpty 허용하지 않음 허용하지 않음 허용 @NotBlank 허용하지 않음 허용하지 않음 허용하지 않음 null : null값을 허용 하는지 empty : \"\" empty상태를 허용 하는지 space : \" \" 다음과 같이 space를 허용 하는지참고 사이트" }, { "title": "유저, 역할, 권한 ERD 설계", "url": "/posts/user_role_auth/", "categories": "Spring, Jpa", "tags": "back-end, spring, jpa, user role auth, erd", "date": "2024-02-19 16:15:00 +0900", "snippet": " 테이블 설계 user : 유저 테이블 role : 역할 테이블, 관리자, 유저, 방문자 등으로 나눈다. role_auth : 역할에 맞는 권한을 매칭 시키는 다대다 관계를 풀어주는 중간 테이블 auth : 권한 테이블, 권한 목록 저장 user role role_auth auth ...", "content": " 테이블 설계 user : 유저 테이블 role : 역할 테이블, 관리자, 유저, 방문자 등으로 나눈다. role_auth : 역할에 맞는 권한을 매칭 시키는 다대다 관계를 풀어주는 중간 테이블 auth : 권한 테이블, 권한 목록 저장 user role role_auth auth user_id(pk) role_id(pk) role_auth_id(pk) auth_id(pk) email(unique) name auth_id(fk) name password description role_id(fk) description name     url birth       address       role_id(fk)       User Entity @Entity@Getter@Table(name = \"user\")@NoArgsConstructor(access = AccessLevel.PROTECTED)public class User { @Id @Column(name = \"user_id\") @GeneratedValue(strategy = GenerationType.IDENTITY) private Long userId; @Column(name = \"email\", unique = true, nullable = false) private String email; @Column(name = \"password\", nullable = false) private String password; @Column(name = \"birth\", nullable = false) private LocalDate localDate; @Column(name = \"address\") private String address; @ManyToOne @JoinColumn(name = \"role_id\", updatable = false) private Role role; @Builder public User(String email, String password, String address, Role role) { this.email = email; this.password = password; this.localDate = LocalDate.now(); this.address = address; this.role = role; } @Override public String toString() { return \"User{\" + \"userId=\" + userId + \", email='\" + email + '\\'' + \", password='\" + password + '\\'' + \", localDate=\" + localDate + \", address='\" + address + '\\'' + \", roleName=\" + role.getName() + '}'; }} Role Entity @Entity@Getter@Table(name = \"role\")@NoArgsConstructor(access = AccessLevel.PROTECTED)public class Role { @Id @Column(name = \"role_id\") @GeneratedValue(strategy = GenerationType.IDENTITY) private Long roleId; @Column(name = \"name\", unique = true, nullable = false) private String name; @Column(name = \"description\", nullable = false) private String description; @OneToMany(mappedBy = \"role\") private List&lt;RoleAuth&gt; roleAuths = new ArrayList&lt;&gt;(); @OneToMany(mappedBy = \"role\") private List&lt;User&gt; users = new ArrayList&lt;&gt;(); @Builder public Role(String name, String description) { this.name = name; this.description = description; }} RoleAuth Entity @Entity@Getter@Table(name = \"role_auth\")@NoArgsConstructor(access = AccessLevel.PROTECTED)public class RoleAuth { @Id @Column(name = \"role_auth_id\") @GeneratedValue(strategy = GenerationType.IDENTITY) private Long authRoleId; @ManyToOne @JoinColumn(name = \"role_id\", updatable = false) private Role role; @ManyToOne @JoinColumn(name = \"auth_id\", updatable = false) private Auth auth; @Builder public RoleAuth(Role role, Auth auth) { this.role = role; this.auth = auth; } @Override public String toString() { return \"RoleAuth{\" + \"roleName=\" + role.getName() + \", authName=\" + auth.getName() + '}'; }} Auth Entity @Entity@Getter@Table(name = \"auth\")@NoArgsConstructor(access = AccessLevel.PROTECTED)public class Auth { @Id @Column(name = \"auth_id\") @GeneratedValue(strategy = GenerationType.IDENTITY) private Long authId; @Column(name = \"name\", nullable = false) private String name; @Column(name = \"description\") private String description; @Column(name = \"url\", nullable = false) private String url; @OneToMany(mappedBy = \"auth\") private List&lt;RoleAuth&gt; roleAuths = new ArrayList&lt;&gt;(); @Builder public Auth(String name, String description, String url) { this.name = name; this.description = description; this.url = url; }}" }, { "title": "Composite Key Setting", "url": "/posts/IdClass/", "categories": "Spring, Jpa", "tags": "back-end, spring, jpa, composite jey, id class, embedded id", "date": "2024-02-19 16:15:00 +0900", "snippet": " 복합키 설정 공통 조건 복합키는 별도의 클래스 Serializable implements EqualsAndHashCode 구현 기본 생성자 클래스의 공개 범위는 public @IdClass Entity에 복합키를 매핑해줄 떄 사용하는 어노테이션 설계상 RDB...", "content": " 복합키 설정 공통 조건 복합키는 별도의 클래스 Serializable implements EqualsAndHashCode 구현 기본 생성자 클래스의 공개 범위는 public @IdClass Entity에 복합키를 매핑해줄 떄 사용하는 어노테이션 설계상 RDBS에 가깝다. @EmbeddedId Entity에 복합키를 매핑해줄 때 사용하는 어노테이션 설계상 객체지향에 가깝다. @IdClass Entity 코드@Entity@Getter@Setter@ToString@Table(name = \"author\")@IdClass(AuthorId.class)@NoArgsConstructor(access = AccessLevel.PROTECTED)public class Author { @Id private String authorId; @Id private String authorName; private String text; public Author(String authorId, String authorName, String text) { this.authorId = authorId; this.authorName = authorName; this.text = text; }} IdClass 코드@NoArgsConstructor@AllArgsConstructorpublic class AuthorId implements Serializable { private String authorId; private String authorName; @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; AuthorId givenObject = (AuthorId) o; return authorId.equals(givenObject.authorId) &amp;&amp; authorName.equals(givenObject.authorName); } @Override public int hashCode() { return Objects.hash(authorId, authorName); }} @EmbeddedId Entity 코드@Entity@Getter@Setter@ToString@Table(name = \"company\")@IdClass(CompanyId.class)@NoArgsConstructor(access = AccessLevel.PROTECTED)public class Company { @EmbeddedId private CompanyId companyId; private String text;} EmbeddedId 코드@Embeddable@EqualsAndHashCode@NoArgsConstructor@AllArgsConstructorpublic class CompanyId implements Serializable { private String companyId; private String companyName;}" }, { "title": "Custom Generator", "url": "/posts/custom_id_generator/", "categories": "Spring, Jpa", "tags": "back-end, spring, jpa, custom generator, id generator", "date": "2024-02-19 02:51:00 +0900", "snippet": " 사용자 정의 Id 생성기 Entity 코드 @Entity@Getter@Setter@Table(name = \"book\")@NoArgsConstructor(access = AccessLevel.PROTECTED)public class Book { @Id @GeneratedValue(generator = \"prod-generator\") @Gener...", "content": " 사용자 정의 Id 생성기 Entity 코드 @Entity@Getter@Setter@Table(name = \"book\")@NoArgsConstructor(access = AccessLevel.PROTECTED)public class Book { @Id @GeneratedValue(generator = \"prod-generator\") @GenericGenerator(name = \"prod-generator\", parameters = @org.hibernate.annotations.Parameter(name = \"prefix\", value = \"book\"), type = MyGenerator.class) private String isbn; private String name; private String author; public Book(String name, String author) { this.name = name; this.author = author; }} Annotation @GeneratedValue : 엔티티의 primary key값을 자동으로 생성한다는 선언. generator = “prod-generator” : 사용할 생성기의 이름을 지정 @GenericGenerator : 생성기의 구성을 설정한다. name = “prod-generator” : 생성기의 이름을 설정한다. parameters = @org.hibernate.annotations.Parameter(name = “prefix”, value = “book”) : 생성기에 파라미터를 설정한다. type = MyGenerator.class : 사용될 클래스의 타입을 지정한다. Generator 코드 @Slf4jpublic class MyGenerator implements IdentifierGenerator, Configurable { private String prefix; @Override public Serializable generate( SharedSessionContractImplementor session, Object obj) throws HibernateException { return prefix + Math.random() + \"\"; } @Override public void configure(Type type, Properties properties, ServiceRegistry serviceRegistry) throws MappingException { prefix = properties.getProperty(\"prefix\"); }} Generator 코드 설명 generate : 생성될 값을 커스텀한다. return 해주는 부분에 전달받은 prefix와 내가 정의할 값을 설정하여 custom generator id값을 설정할 수 있다.테스트 용으로 임의의 double 값 설정 configure : @GenericGenerator의 parameters 의 파라미터로 받은 값을 파싱해준다. prefix 값이 되는것은 parameters에서 설정한 @org.hibernate.annotations.Parameter(name = \"prefix\", value = \"book\") 값이 된다. 쉽게 말하면 String prefix = \"book\" 가된다고 생각하자. 적용 테스트 @Slf4j@DataJpaTest@Rollback(value = false)@AutoConfigureTestDatabase(replace = AutoConfigureTestDatabase.Replace.NONE)public class RepositoryTest { @Autowired private BookRepository bookRepository; @Test void saveBook() { Book book = new Book(\"spring in action\", \"john doe\"); Book save = bookRepository.save(book); log.info(\"save = {}\", save); }}save = Book{isbn='book0.36651499710225977', name='spring in action', author='john doe'}" }, { "title": "Spring 테스트 코드, @Commit, @Rollback", "url": "/posts/spring_test_datasource(1)/", "categories": "Spring, Test Code", "tags": "back-end, spring, test code, transaction, rollback, commit", "date": "2024-02-18 16:20:00 +0900", "snippet": " 스프링에서 테스트 코드를 작성시 @Rollback(true) 해당 옵션이 기본 설정임. 해당 설정은 메소드와 클래스 레벨에서 기본 설정으로 되어 있음. 개별 테스트가 끝난후 롤백, 전체 테스트가 끝난후 클래스 래밸에서 롤백 시킴.@TestMethodOrder(MethodOrderer.OrderAnnotation.class)public class S...", "content": " 스프링에서 테스트 코드를 작성시 @Rollback(true) 해당 옵션이 기본 설정임. 해당 설정은 메소드와 클래스 레벨에서 기본 설정으로 되어 있음. 개별 테스트가 끝난후 롤백, 전체 테스트가 끝난후 클래스 래밸에서 롤백 시킴.@TestMethodOrder(MethodOrderer.OrderAnnotation.class)public class SpringBootJpaTestSliceTest extends Common { @Autowired private BookRepository bookRepository; @Test @Order(1) void testJpaTestSlice() { long countBefore = bookRepository.count(); Assertions.assertEquals(countBefore, 0L); bookRepository.save(new Book(\"my book\", \"123210ws\", \"self\")); long countAfter = bookRepository.count(); Assertions.assertTrue(countBefore != countAfter); Assertions.assertEquals(countAfter, 1L); } @Test @Order(2) void testJpaTestSpliceTransaction() { long count = bookRepository.count(); Assertions.assertEquals(count, 1L); }} 위와 같은 코드가 있을때 첫번째 테스트는 통과하지만 두번째 테스트는 통과하지 못함. @Rollback 변경 사항을 되돌리는 어노테이션 : import org.springframework.test.annotation.Rollback @Rollback(value = false) : 롤백 기능을 off @Rollback(value = true) : 롤백 기능을 on (기본 설정) @Commit 변경 사항을 적용시키는 어노테이션 : import org.springframework.test.annotation.Commit 코드를 보면 @Rollback(false)가 되어 있는걸 볼 수 있다. @Target({ElementType.TYPE, ElementType.METHOD})@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@Rollback(false)public @interface Commit {} 수정 코드 @TestMethodOrder(MethodOrderer.OrderAnnotation.class)public class SpringBootJpaTestSliceTest extends Common { @Autowired private BookRepository bookRepository; @Test @Commit @Order(1) void testJpaTestSlice() { long countBefore = bookRepository.count(); Assertions.assertEquals(countBefore, 0L); bookRepository.save(new Book(\"my book\", \"123210ws\", \"self\")); long countAfter = bookRepository.count(); Assertions.assertTrue(countBefore != countAfter); Assertions.assertEquals(countAfter, 1L); } @Test @Order(2) void testJpaTestSpliceTransaction() { long count = bookRepository.count(); Assertions.assertEquals(count, 1L); }}" }, { "title": "내장 DB 설정 에러(feat.@DataJpaTest)", "url": "/posts/excepiton/", "categories": "Exception, Spring", "tags": "spring framework, test data source", "date": "2024-02-18 15:30:00 +0900", "snippet": " Spring boot + Spring data jpa + mysql 을 사용하여 테스트 코드 작성 중 생긴 에러 @DataJpaTest 를 선언하고 테스트를 작성할때 spring framework 안에 내장된 메모리 데이터베이스를 못찾아서 생기는 에러 문제 발생 코드 @DataJpaTestpublic class Sprin...", "content": " Spring boot + Spring data jpa + mysql 을 사용하여 테스트 코드 작성 중 생긴 에러 @DataJpaTest 를 선언하고 테스트를 작성할때 spring framework 안에 내장된 메모리 데이터베이스를 못찾아서 생기는 에러 문제 발생 코드 @DataJpaTestpublic class SpringBootJpaTestSlice { @Autowired private BookRepository bookRepository; @Test void testJpaTestSlice() { long countBefore = bookRepository.count(); bookRepository.save(new Book(\"my book\", \"123210ws\", \"self\")); long countAfter = bookRepository.count(); Assertions.assertTrue(countBefore != countAfter); }} 에러 로그 java.lang.IllegalStateException: Failed to load ApplicationContext for [MergedContextConfiguration@a92be4f testClass = org.spring.hibernatejpa.SpringBootJpaTestSlice, locations = [], classes = [org.spring.hibernatejpa.HibernatejpaApplication], contextInitializerClasses = [], activeProfiles = [], propertySourceDescriptors = [], propertySourceProperties = [\"org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTestContextBootstrapper=true\"], contextCustomizers = [[ImportsContextCustomizer@53e800f9 key = [org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration, org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration, org.springframework.boot.test.autoconfigure.orm.jpa.TestEntityManagerAutoConfiguration, org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration, org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration, org.springframework.boot.autoconfigure.sql.init.SqlInitializationAutoConfiguration, org.springframework.boot.test.autoconfigure.jdbc.TestDatabaseAutoConfiguration, org.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration, org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration, org.springframework.boot.autoconfigure.liquibase.LiquibaseAutoConfiguration, org.springframework.boot.autoconfigure.jdbc.JdbcClientAutoConfiguration, org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration, org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration]], org.springframework.boot.test.context.filter.ExcludeFilterContextCustomizer@2b30a42c, org.springframework.boot.test.json.DuplicateJsonObjectContextCustomizerFactory$DuplicateJsonObjectContextCustomizer@43df23d3, org.springframework.boot.test.mock.mockito.MockitoContextCustomizer@0, org.springframework.boot.test.autoconfigure.OverrideAutoConfigurationContextCustomizerFactory$DisableAutoConfigurationContextCustomizer@4d0d9fe7, org.springframework.boot.test.autoconfigure.actuate.observability.ObservabilityContextCustomizerFactory$DisableObservabilityContextCustomizer@1f, org.springframework.boot.test.autoconfigure.filter.TypeExcludeFiltersContextCustomizer@34be3d80, org.springframework.boot.test.autoconfigure.properties.PropertyMappingContextCustomizer@8a1859ac, org.springframework.boot.test.autoconfigure.web.servlet.WebDriverContextCustomizer@6a8658ff, org.springframework.boot.test.context.SpringBootTestAnnotation@5ddfe3f], contextLoader = org.springframework.boot.test.context.SpringBootContextLoader, parent = null]\tat org.springframework.test.context.cache.DefaultCacheAwareContextLoaderDelegate.loadContext(DefaultCacheAwareContextLoaderDelegate.java:180)\tat org.springframework.test.context.support.DefaultTestContext.getApplicationContext(DefaultTestContext.java:130)\tat org.springframework.test.context.support.DependencyInjectionTestExecutionListener.injectDependencies(DependencyInjectionTestExecutionListener.java:142)\tat org.springframework.test.context.support.DependencyInjectionTestExecutionListener.prepareTestInstance(DependencyInjectionTestExecutionListener.java:98)\tat org.springframework.test.context.TestContextManager.prepareTestInstance(TestContextManager.java:260)\tat org.springframework.test.context.junit.jupiter.SpringExtension.postProcessTestInstance(SpringExtension.java:163)\tat java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:197)\tat java.base/java.util.stream.ReferencePipeline$2$1.accept(ReferencePipeline.java:179)\tat java.base/java.util.ArrayList$ArrayListSpliterator.forEachRemaining(ArrayList.java:1625)\tat java.base/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:509)\tat java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:499)\tat java.base/java.util.stream.StreamSpliterators$WrappingSpliterator.forEachRemaining(StreamSpliterators.java:310)\tat java.base/java.util.stream.Streams$ConcatSpliterator.forEachRemaining(Streams.java:735)\tat java.base/java.util.stream.Streams$ConcatSpliterator.forEachRemaining(Streams.java:734)\tat java.base/java.util.stream.ReferencePipeline$Head.forEach(ReferencePipeline.java:762)\tat java.base/java.util.Optional.orElseGet(Optional.java:364)\tat java.base/java.util.ArrayList.forEach(ArrayList.java:1511)\tat java.base/java.util.ArrayList.forEach(ArrayList.java:1511)Caused by: org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'dataSourceScriptDatabaseInitializer' defined in class path resource [org/springframework/boot/autoconfigure/sql/init/DataSourceInitializationConfiguration.class]: Unsatisfied dependency expressed through method 'dataSourceScriptDatabaseInitializer' parameter 0: Error creating bean with name 'dataSource': Failed to replace DataSource with an embedded database for tests. If you want an embedded database please put a supported one on the classpath or tune the replace attribute of @AutoConfigureTestDatabase.\tat org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:798)\tat org.springframework.beans.factory.support.ConstructorResolver.instantiateUsingFactoryMethod(ConstructorResolver.java:542)\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.instantiateUsingFactoryMethod(AbstractAutowireCapableBeanFactory.java:1334)\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1164)\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:561)\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:521)\tat org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:325)\tat org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)\tat org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:323)\tat org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:199)\tat org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:312)\tat org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:199)\tat org.springframework.context.support.AbstractApplicationContext.getBean(AbstractApplicationContext.java:1231)\tat org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:949)\tat org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:624)\tat org.springframework.boot.SpringApplication.refresh(SpringApplication.java:754)\tat org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:456)\tat org.springframework.boot.SpringApplication.run(SpringApplication.java:334)\tat org.springframework.boot.test.context.SpringBootContextLoader.lambda$loadContext$3(SpringBootContextLoader.java:137)\tat org.springframework.util.function.ThrowingSupplier.get(ThrowingSupplier.java:58)\tat org.springframework.util.function.ThrowingSupplier.get(ThrowingSupplier.java:46)\tat org.springframework.boot.SpringApplication.withHook(SpringApplication.java:1454)\tat org.springframework.boot.test.context.SpringBootContextLoader$ContextLoaderHook.run(SpringBootContextLoader.java:552)\tat org.springframework.boot.test.context.SpringBootContextLoader.loadContext(SpringBootContextLoader.java:137)\tat org.springframework.boot.test.context.SpringBootContextLoader.loadContext(SpringBootContextLoader.java:108)\tat org.springframework.test.context.cache.DefaultCacheAwareContextLoaderDelegate.loadContextInternal(DefaultCacheAwareContextLoaderDelegate.java:225)\tat org.springframework.test.context.cache.DefaultCacheAwareContextLoaderDelegate.loadContext(DefaultCacheAwareContextLoaderDelegate.java:152)\t... 17 moreCaused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'dataSource': Failed to replace DataSource with an embedded database for tests. If you want an embedded database please put a supported one on the classpath or tune the replace attribute of @AutoConfigureTestDatabase.\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1773)\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:599)\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:521)\tat org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:325)\tat org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)\tat org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:323)\tat org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:199)\tat org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:254)\tat org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1443)\tat org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1353)\tat org.springframework.beans.factory.support.ConstructorResolver.resolveAutowiredArgument(ConstructorResolver.java:907)\tat org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:785)\t... 43 moreCaused by: java.lang.IllegalStateException: Failed to replace DataSource with an embedded database for tests. If you want an embedded database please put a supported one on the classpath or tune the replace attribute of @AutoConfigureTestDatabase.\tat org.springframework.util.Assert.state(Assert.java:76)\tat org.springframework.boot.test.autoconfigure.jdbc.TestDatabaseAutoConfiguration$EmbeddedDataSourceFactory.getEmbeddedDatabase(TestDatabaseAutoConfiguration.java:188)\tat org.springframework.boot.test.autoconfigure.jdbc.TestDatabaseAutoConfiguration$EmbeddedDataSourceFactoryBean.afterPropertiesSet(TestDatabaseAutoConfiguration.java:153)\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeInitMethods(AbstractAutowireCapableBeanFactory.java:1820)\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1769)\t... 54 more 해결법 1 테스트에 사용되는 db를 따로 분리하지 않고 사용할 경우 @AutoConfigureTestDatabase(replace = AutoConfigureTestDatabase.Replace.NONE) 해당 어노테이션을 클래스 레벨에 설정함으로써 해결 가능(테스트 환경을 내장된 데이터 베이스로 하지 않겠다는 선언).@DataJpaTest@AutoConfigureTestDatabase(replace = AutoConfigureTestDatabase.Replace.NONE)public class SpringBootJpaTestSlice { @Autowired private BookRepository bookRepository; @Test void testJpaTestSlice() { long countBefore = bookRepository.count(); bookRepository.save(new Book(\"my book\", \"123210ws\", \"self\")); long countAfter = bookRepository.count(); Assertions.assertTrue(countBefore != countAfter); }} 해결법 2 테스트에 사용되는 db를 따로 분리하여 사용하고 싶은 경우 위에서 설명한것과 같이 내장된 데이터 베이스 사용을 해제하고 바라보는 설정을 test 환경에 맞는 설정으로 바꿔주면 된다application-test.yamlspring: datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/jpa_test # 테스트용 데이터 베이스 username: root password: root jpa: hibernate: ddl-auto: create-drop open-in-view: false properties: hibernate: show_sql: true format_sql: truelogging: pattern: console: \"%boldWhite(%d{yyyy-MM-dd HH:mm:ss.SSS}) %boldMagenta([%thread]) %highlight([%-5level]) %boldGreen([%logger{100}]) - %msg %n\" level: org: hibernate: type: descriptor: sql: trace@DataJpaTest@ActiveProfiles(\"test\")@AutoConfigureTestDatabase(replace = AutoConfigureTestDatabase.Replace.NONE)public class SpringBootJpaTestSlice { @Autowired private BookRepository bookRepository; @Test void testJpaTestSlice() { long countBefore = bookRepository.count(); bookRepository.save(new Book(\"my book\", \"123210ws\", \"self\")); long countAfter = bookRepository.count(); Assertions.assertTrue(countBefore != countAfter); }} 수정 코드 해당 설정은 테스트 코드 작성시마다 선언해야 함으로 공통 코드로 분리@DataJpaTest@ActiveProfiles(\"test\")@AutoConfigureTestDatabase(replace = AutoConfigureTestDatabase.Replace.NONE)public abstract class Common {}public class SpringBootJpaTestSlice extends Common { @Autowired private BookRepository bookRepository; @Test void testJpaTestSlice() { long countBefore = bookRepository.count(); bookRepository.save(new Book(\"my book\", \"123210ws\", \"self\")); long countAfter = bookRepository.count(); Assertions.assertTrue(countBefore != countAfter); }}" }, { "title": "Prime Number(1)", "url": "/posts/primenumber(1)/", "categories": "discrete mathematics, number theory", "tags": "cs, number theory, prime number", "date": "2024-02-17 17:50:00 +0900", "snippet": " 소수와 소인수분해 소수 1보다 큰 자연수 p는 p의 양의 인수가 1과 p뿐일 때 소수 라고 한다.1보다 크면서 소수가 아닌 자연수는 합성수 라고 한다. 소인수 주어진 자연수를 나누어 떨어뜨리는 약수 중에서 소수인것 합성수를 소인수의 곱으로 표현하는 것\\(p 가 소수이고 p \\| ab 이면, p \\| a 또는 p \\| b 이다.\\)\\(p가 ...", "content": " 소수와 소인수분해 소수 1보다 큰 자연수 p는 p의 양의 인수가 1과 p뿐일 때 소수 라고 한다.1보다 크면서 소수가 아닌 자연수는 합성수 라고 한다. 소인수 주어진 자연수를 나누어 떨어뜨리는 약수 중에서 소수인것 합성수를 소인수의 곱으로 표현하는 것\\(p 가 소수이고 p \\| ab 이면, p \\| a 또는 p \\| b 이다.\\)\\(p가 소수이고 p \\| a_1a_2...a_n이면, 1 \\le k \\le n인 k에 대해 p \\| a_k 이다.\\)\\(p, q_1, q_2 .... q_n이 소수이고 p \\| q_1q_2...q_n 이라면, 1\\le k \\le n인 k에 대해 p = q_k 이다.\\) n이 2 이상의 자연수이면 n은 소수이거나 소수의 곱으로 유일하게 표현할 수 있다. 만약 n이 합성수라면, n의 소인수 중 하나는 \\(\\sqrt{n}\\) 보다 같거나 작다. 무한히 많은 소수가 존재한다. x 이하의 소수의 개수 \\(\\pi\\) x와 x/ln x 의 비율은 x가 무한히 커지면 1로 수렴한다. RSA 암호 암호학에서는 \\(b^n mod n\\)을 효율적으로 계산하는 것이 필요하며, 이떄 자주 사용 되는 페르마의 작은 정리는 다음과 같다 p가 소수이고 a가 p로 나눌 수 없는 정수이면, \\(a^{p-1} ≡ 1 (mod \\ p) 이다.\\) 또는, 모든 정수 a에 대하여 \\(a^p ≡ a(mod \\ p) 이다.\\) \\(b^n \\ mod \\ n\\)을 효과적으로 계산하는 또 다른 방법으로서 나머지 거듭제곱 알고리즘은 지수 n을 이진법으로 바뀐 뒤에 \\(b^n\\)을 2의 거듭제곱으로 형태로 만들어 계산하는 방법이다. RSA 암호 알고리즘은 두 개의 큰 소수를 곱하여 만들어진 합성수의 소인수분해를 하기 어렵다는 원리에 기반을 둔 암호방법이다.RSA암호 시스템에서 필요한 키는 공개키와 개인키, 두 가지가 있다." }, { "title": "Modulo(1)", "url": "/posts/modulo(1)/", "categories": "discrete mathematics, number theory", "tags": "cs, number theory, modulo", "date": "2024-02-16 15:30:00 +0900", "snippet": " 나머지 연산 나눗셈의 식 a = bq + r은 a를 b로 나눌 경우 몫은 q, 나머지는 r이되는 관계를 표현.\\[q(몫) = \\lfloor \\frac{a}{b} \\rfloor\\]\\[r(나머지) = a \\ mod \\ b = a - b (\\lfloor \\frac{a}{b} \\rfloor)\\]3 ≡ 31(mod 7) 3 mod 7 = 3 3...", "content": " 나머지 연산 나눗셈의 식 a = bq + r은 a를 b로 나눌 경우 몫은 q, 나머지는 r이되는 관계를 표현.\\[q(몫) = \\lfloor \\frac{a}{b} \\rfloor\\]\\[r(나머지) = a \\ mod \\ b = a - b (\\lfloor \\frac{a}{b} \\rfloor)\\]3 ≡ 31(mod 7) 3 mod 7 = 3 31 mod 7 = 3-31 ≡ 11(mod 7) -31 mod 7 = 4, -35 ~ -31 11 mod 7 = 4-15 ≡ -50(mod 7) -15 mod 7 = 6, -21 ~ -15 -50 mod 7 = 6, -56 ~ -50 a,b가 정수이고 m이 양의 정수라 하자. 그러면 a ≡ b (mod m) 은 a mod m = b mod m과 필요 충분 조건이다. 합동의 기본정리 m &gt; 1이 고정되고 a, b, c, d를 임의의 정수라 할 떄, 다음 성직이 성립한다. a ≡ a(mod m) a ≡ b(mod m)이면 b ≡ a(mod m)이다. a ≡ b(mod m)이고 b ≡ c(mod m) 이면 a ≡ c(mod b) 이다. a ≡ b(mod m)이고 c ≡ d(mod m) 이면 a + c ≡ b + d (mod m) 이고 ac ≡ bd (mod m)이다. a ≡ b(mod m)이면 a + c ≡ b + c (mod m)이고 ac ≡ bc (mod m) 이다. a ≡ b(mod m)이면 모든 양의 정수 k에 대해 ak ≡ bk(mod m)이다. 7 ≡ 2(mod 5)와 11 = 1(mod 5)가 성립할 경우, 18과 77을 5로 나누었을 때 나머지를 각각 구하시오.7 ≡ 2(mod 5), 11 ≡ 1(mod 5)* a + c ≡ b + d (mod m)18(mod 5) = ( 7 + 11 = 2 + 1( mod 5) ) = ( 18 = 3 mod 5 ) = 377(mod 5) ≡ (77 = 2(mod 5)) = 2" }, { "title": "Division(1)", "url": "/posts/division(1)/", "categories": "discrete mathematics, number theory", "tags": "cs, number theory, division", "date": "2024-02-16 15:30:00 +0900", "snippet": " 나눗셈 : division a는 정수이고 b는 양의 정수라 할 때, 다음을 만족하는 유일한 정부 q, r이 존재한다.\\[a = bq + r, 단, 0 \\le r &lt; b\\] 약수(divisor)와 배수(multiple) a,b가 정수이고 a ≠ 0 일 때, b=ac를 만족시키는 종수 c가 있다면 “a가 b를 나머지 없이 나눈다.”또는 “a...", "content": " 나눗셈 : division a는 정수이고 b는 양의 정수라 할 때, 다음을 만족하는 유일한 정부 q, r이 존재한다.\\[a = bq + r, 단, 0 \\le r &lt; b\\] 약수(divisor)와 배수(multiple) a,b가 정수이고 a ≠ 0 일 때, b=ac를 만족시키는 종수 c가 있다면 “a가 b를 나머지 없이 나눈다.”또는 “a는 b를 정제한다” 또는 “b는 a로 나누어 떨어진다” 라고한다.이 경우 a는 b의 약수 또는 인수, b는 a의 배수라고 하며, 기호 a | b로 나타낸다.만약 a가 b를 나누지 않을 때에는 기호 a ∤ b로 나타낸다. 나누어떨어짐의 성질 a를 0이 아닌 정수, b와 c를 임의의 정수라고 할 떄 a | b이고 a | c 이면, a | ( b + c ) 이다. a | b이면, a | bc 이다. a | b이고 b | c 이면, a | c 이다. 최대 공약수 : greatest common divisor 0이 아닌 두 정수 a, b에 대하여 d | a 이고 d | b 인 최대의 양의 정수 d를 a와 b의 최대 공약수라고 하고d = gcd(a, b) 로 표기한다. a, b에 대하여 1 = gcd(a, b)를 만족하면 a와 b는 서로소 라 한다. 배주의 항등식 적어도 하나는 0이 아닌 정수 a, b가 임의로 주어져 있다고 하자, 그러면 gcd(a, b) = d 라고 할 때,ax + by = d 를 만족하는 정수 x,y가 존재한다. 유클리드 호제법 a, b, q, r이 정수일 떄, a = bq + r 이면 gcd(a,b) = gcd(b,r) 이다. gcd(287, 91)1 ] gcd(287, 91) = 142 ] gcd(91, 14) = 73 ] gcd(14, 7) = 0 24m x 15m 크기의 직각 사각형 바닥에 빈자리가 없도록 타일을 깔고자 한다. 동일한 크기의 정사각형 타일만 사용한다고 할 때, 필요한 타일의 최소 개수를 구하시오.gcd(24,15)1 ] gcd(24,15) = 92 ] gcd(15,9) = 63 ] gcd(9,6) = 34 ] gcd(6,3) = 0∴ 3" }, { "title": "Algorithm", "url": "/posts/sort(1)/", "categories": "algorithm, sort", "tags": "data, cs, algorithm, sort, selection sort, bubble sort, insertion sort, shell sort", "date": "2024-02-15 14:30:00 +0900", "snippet": " 정렬 : sort 여러 개의 데이터로 구성된 리스트가 주어졌을 때, 데이터들을 값의 크기 순서대로 재배치하는 것 내부정렬 정렬할 데이터 전체를 주기억장치에 저장한 후 정렬 외부정렬 데이터의 양이 너무 많아 보조기억장치에 저장해 두고 일부...", "content": " 정렬 : sort 여러 개의 데이터로 구성된 리스트가 주어졌을 때, 데이터들을 값의 크기 순서대로 재배치하는 것 내부정렬 정렬할 데이터 전체를 주기억장치에 저장한 후 정렬 외부정렬 데이터의 양이 너무 많아 보조기억장치에 저장해 두고 일부 데이터만을 반복적으로 주기억장치로 옮겨와 정렬을 수행 안정적 정렬 리스트내에 같은 값을 가지고 있는 데이터가 존재할 경우 상대적 순서 유지가 보정이 되는 정렬 불안정적 정렬 리스트내에 같은 값을 가지고 있는 데이터가 존재할 경우 상대적 순서가 유지 되는것이 보장이 안됨. 선택 정렬 : selection sort 주어진 데이터 내에서 가장 작거나, 큰 값을 선택해 차례대로 정렬하는 방법public class SortTest { public int[] selectionSort(int[] array) { for (int i = 0; i &lt; array.length; i++) { int min = array[i]; // 미정렬 부분의 첫 번쨰 원소를 최솟값으로 지정. for (int j = i; j &lt; array.length; j++) { // 최솟값 찾기. if (min &gt; array[j]) { min = array[j]; switchingHelper(array, i, j); // 위치 교환. } } } return array; } public void switchingHelper(int[] array, int index1, int index2) { int temp = array[index1]; array[index1] = array[index2]; array[index2] = temp; }} 시간 복잡도 : O(n2) 입력 데이터의 순서에 민감하지 않다. 입력 데이터가 오름차순인지, 내림차순인지, 임의로 나열되었는지와는 무관 제자리 정렬 알고리즘이다. 입력 배열 이외에 별도의 저장 공간이 상수개를 넘지 않음. 안정적인 정렬 알고리즘이 아니다. 버블 정렬 : bubble sort 인접한 두 데이터를 차례대로 비교해서 왼쪽 데이터와 오른쪽 데이터의 자리를 바꾸는 과정을 반복.public class SortTest { public int[] bubbleSort(int[] array) { for (int i = 0; i &lt; array.length; i++) { boolean sort = true; // 최적화를 위한 변수 선언 for (int j = i; j &lt; array.length; j++) { if (array[i] &gt; array[j]) { switchingHelper(array, i, j); sort = false; } } if (sort) break; } return array; } public void switchingHelper(int[] array, int index1, int index2) { int temp = array[index1]; array[index1] = array[index2]; array[index2] = temp; }} 시간 복잡도 : O(n2) 안정적인 정렬 알고리즘이다. 제자리 정렬 알고리즘이다. 입력 데이터의 상태에 따라 성능이 달라진다. 선택 정렬에 비해 데이터의 교환이 많이 발생한다. 삽입 정렬 : insertion sort 주어진 데이터를 하나씩 뽑은 후 이미 나열된 데이터가 항상 정렬된 형태를 유지하더록 뽑은 데이터를 바른 위치에 삽입해서 나열하는 방식public class SortTest { public int[] insertionSort(int[] array) { for (int i = 1; i &lt; array.length; i++) { int temp = array[i]; for (int j = i; j &gt; 0 &amp;&amp; array[j - 1] &gt; temp; j--) { switchingHelper(array, j, j - 1); } } return array; } public void switchingHelper(int[] array, int index1, int index2) { int temp = array[index1]; array[index1] = array[index2]; array[index2] = temp; }} 시간 복잡도 : O(n2) 안정적인 정렬 알고리즘이다. 제자리 정렬 알고리즘이다. 입력 데이터의 원래 순서에 민감하다. 셸 정렬 : shell sort 삽입 정렬을 보완하기 위한 정렬 알고리즘 멀리 떨어진 데이터와의 비교, 교환으로 한번에 이동할 수 있는 거리를 늘려 처리 속도를 향상시킴 public class SortTest { public int[] shellSort(int[] array) { for (int i = array.length / 2; i &gt; 0; i /= 2) { for (int j = i; j &lt; array.length; j++) { int temp = array[j]; for (int k = j; k &gt;= i &amp;&amp; array[k - i] &gt; temp; k -= i) { switchingHelper(array, k, k - i); } } } return array; } public void switchingHelper(int[] array, int index1, int index2) { int temp = array[index1]; array[index1] = array[index2]; array[index2] = temp; }} 전체 배열을 나누는 값에 따라 성능이 달라진다. 사용하는 순열에 따라 성능이 달라진다. 안정적이지 않은 정렬 알고리즘이다. 제자리 정렬 알고리즘이다." }, { "title": "Matrix(1)", "url": "/posts/matrix(1)/", "categories": "discrete mathematics, matrix", "tags": "cs, matrix", "date": "2024-02-14 16:00:00 +0900", "snippet": " 행렬 : matrix m, n이 양의 정수일 때, m개의 행과 n개의 열로 구성된 직사각형의 배열 A를 m x n 행렬 이라 한다.\\[A =\\begin{pmatrix}a_{11} &amp; a_{12} &amp; ... &amp; a_{1n} \\\\a_{21} &amp; a_{22} &amp; ... &amp; a_{2n} \\\\... &amp; ....", "content": " 행렬 : matrix m, n이 양의 정수일 때, m개의 행과 n개의 열로 구성된 직사각형의 배열 A를 m x n 행렬 이라 한다.\\[A =\\begin{pmatrix}a_{11} &amp; a_{12} &amp; ... &amp; a_{1n} \\\\a_{21} &amp; a_{22} &amp; ... &amp; a_{2n} \\\\... &amp; ... &amp; ... &amp; ... \\\\a_{m1} &amp; a_{m2} &amp; ... &amp; a_{mn} \\\\\\end{pmatrix}\\] 영행렬 : zero matrix 모든 원소가 0인 행렬을 영행렬이라고 한다. 다양한 크기의 영행렬이 존재할 수 있다. 행렬의 곱 \\[\\sum_{k=1}^{n} a_{ik} \\times b_{kj} = a_{i1} b_{1j} + a_{i2} b_{2j} + .... + a_{in} b_{nj}\\] 정방행렬 : square matrix 행의 수와 열의 수가 같은 행렬 대각 행렬 : diagonal matrix n차 정방 행렬에서 대각원소 이외의 모든 원소가 0인 행렬 n개의 대각 원소가 모두 같은 값인 대각행렬을 스칼라 행렬 이라고 한다. 단위행렬(항등행렬) : identity matrix 주대각선의 원소가 모두 1이며 나머지 원소는 모두0인 정사각형 행렬.\\[I_n =\\begin{pmatrix}1 &amp; 0 &amp; ... &amp; 0 \\\\0 &amp; 1 &amp; ... &amp; 0 \\\\... &amp; ... &amp; ... &amp; ... \\\\0 &amp; 0 &amp; ... &amp; 1 \\\\\\end{pmatrix}\\]\\[A_{mn}I_n = I_mA_{mn} = A_{mn}\\]\\[A^o = I_n, AAAA...A\\] 대칭행렬 : symmetric matrix n차 정방행렬에서 aij = aji 인 행렬을 대칭 행렬이라고 한다.\\[\\begin{pmatrix}a_{11} &amp; a_{12} &amp; ... &amp; a_{1n} \\\\a_{22} &amp; a_{22} &amp; ... &amp; a_{2n} \\\\... &amp; ... &amp; ... &amp; ... \\\\a_{1n} &amp; a_{2n} &amp; ... &amp; a_{nn} \\\\\\end{pmatrix}\\] 역대칭행렬(교대행렬) : skew symmetric matrix n차 정방행렬에서 aij = -aji 이고 대각 원소가 모두 0인 행렬\\[\\begin{pmatrix}0 &amp; a_{12} &amp; ... &amp; a_{1n} \\\\-a_{22} &amp; 0 &amp; ... &amp; a_{2n} \\\\... &amp; ... &amp; ... &amp; ... \\\\-a_{1n} &amp; -a_{2n} &amp; ... &amp; 0 \\\\\\end{pmatrix}\\] 삼각행렬 : triangular matrix n차 정방 행렬에서 주대각선 아래에 있는 모든 원소들이 0일 경우 상삼각행렬, 주대각선 위에 있는 모든 원소들이 0일경우 하삼각행렬\\[상삼각행렬 =\\begin{pmatrix}a_{11} &amp; a_{12} &amp; ... &amp; a_{1n} \\\\0 &amp; a_{22} &amp; ... &amp; a_{2n} \\\\0 &amp; 0 &amp; ... &amp; ... \\\\0 &amp; 0 &amp; 0 &amp; a_{nn} \\\\\\end{pmatrix}하삼각행렬 =\\begin{pmatrix}a_{11} &amp; 0 &amp; 0 &amp; 0 \\\\a_{22} &amp; a_{22} &amp; 0 &amp; 0 \\\\... &amp; ... &amp; ... &amp; 0 \\\\a_{1n} &amp; a_{2n} &amp; ... &amp; a_{nn} \\\\\\end{pmatrix}\\] 역치행렬 : transposes of matrices 행렬의 행과 열을 바꾼 것\\[A =\\begin{pmatrix}2 &amp; 1 &amp; 3 \\\\4 &amp; 1 &amp; 0 \\\\\\end{pmatrix}A^t =\\begin{pmatrix}2 &amp; 4 \\\\1 &amp; 1 \\\\3 &amp; 0 \\\\\\end{pmatrix}\\] 역행렬 : inverse matrix n차 정방행렬 A, B가 주어졌을떄 AB = BA = In인 행렬 B가 존재하는 경우 행렬 A를 역가능 하다고 한다. 이때 B를 행렬 A의 역행렬 이라고 하고 A-1 이라고 한다. 부울행렬 : boolean matrix 행렬의 원소가 T, F" }, { "title": "Proof", "url": "/posts/proof(1)/", "categories": "discrete mathematics, logic and proofs", "tags": "cs, axiom, proof, theorem, kocw", "date": "2024-02-14 12:00:00 +0900", "snippet": " axiom : 공리 어떤 다른 명제들을 증명하기 위해 전제로 사용되는 가장 기본적인 가정. 별도의 증명 없이참으로 이용되는 명제를 공리라고 함. 예시 두 점이 주어졌을 때, 두 점을 통과하는 직선을 그릴 수 있다. 어떤 자연수도, 그 수의 다음 수가 존재한다. 어떤 것도 포함하지 않는 집합이 ...", "content": " axiom : 공리 어떤 다른 명제들을 증명하기 위해 전제로 사용되는 가장 기본적인 가정. 별도의 증명 없이참으로 이용되는 명제를 공리라고 함. 예시 두 점이 주어졌을 때, 두 점을 통과하는 직선을 그릴 수 있다. 어떤 자연수도, 그 수의 다음 수가 존재한다. 어떤 것도 포함하지 않는 집합이 존재한다. proof : 증명 특정한 공리들을 가정하고, 그 가정하에 제안된 명제가 참임을 입증하는 작업. theorem : 정리 공리로부터 증명된 명제를 정리라고 한다. 보조정리(lemma) : 정리를 증명하기 위한 과정 중에 사용되는 명제 따름정리(corollary) : 정리로부터 쉽게 도출되는 부가적인 명제 예시 피타고라스의 정리 : 임의의 직사격형에서 빗변 길이의 제곱은 밑변 길이의 제곱과 높이 길이의 제곱을 합한 것과 같다. 페르마의 마지막 정리 : n이 2보다 큰 자연수일 때, xn + yn = zn을 만족하는 0이 아닌 정수해(x, y, z)는 존재하지 않는다. 유클리드 정리 : 소수는 무한히 많다. 증명기법 직접증명법 : 공리와 정의, 정리를 논리적으로 직접 연결하여 증명한다. 수학적 귀납법 : 자연수 n에 대한 명제의 성질을 증명하는 데 유용한 방법, 기본단계, 귀납가정, 귀납단계를 이용 간접증명법 : 증명해야 할 명제를 증명하기 쉬운 형태로 변형하여 증명하는 방법. " }, { "title": "Set(2)", "url": "/posts/set(2)/", "categories": "discrete mathematics, set", "tags": "cs, function, kocw", "date": "2024-02-13 16:00:00 +0900", "snippet": " Function 특징 ｆ: A ⇒ B ｆ(a)=b, a = 정의역, b = 치역 모든 정의역은 모두 사용되어야 하고 반드시 하나의 치역을 가지고 있어야 한다. 정의역은 치역을 동시에 바라보고 있을 수 있다. One to One Function 특징 ∀a∀b(ｆ(a) =ｆ(b...", "content": " Function 특징 ｆ: A ⇒ B ｆ(a)=b, a = 정의역, b = 치역 모든 정의역은 모두 사용되어야 하고 반드시 하나의 치역을 가지고 있어야 한다. 정의역은 치역을 동시에 바라보고 있을 수 있다. One to One Function 특징 ∀a∀b(ｆ(a) =ｆ(b) ⇒ a=b ) 모든 정의역이 바라보는 치역이 다르다. Onto Function 특징 ∀y∃x(ｆ(x) = y ) 모든 치역이 관계에 참여하고 있다. Bijection Function 특징 Ont to Ont Function과 Onto Function 두개를 모두 만족하는 함수 역함수가 존재할 수 있다. Inverse Function 특징 ｆ-1(b) = ｆ(a) = b 예시 ｆ:Z ⇒ Z be such that ｆ(x) = x + 1 Composition of Functions : 합성 함수 특징 (f∘g)(a) = f(g(a)) 예시 f(x) = 2x + 3, g(x) = 3x + 2 (f∘g)(x) = f(g(x)) = 2(3x + 2) + 3 = 6x + 7 (g∘f)(x) = g(f(x)) = 3(2x + 3) + 2 = 6x + 11 " }, { "title": "Set(1)", "url": "/posts/set(1)/", "categories": "discrete mathematics, set", "tags": "cs, set, kocw", "date": "2024-02-13 12:00:00 +0900", "snippet": " Set : 집합 특징 순서가 없다. {1,2,3} ≡ {2,1,3} 중복을 허용하지 않는다. {1,1,2,3} ≡ {1,2,3} 중요 집합들 N = {1,2,3,4, … }, 자연수 ...", "content": " Set : 집합 특징 순서가 없다. {1,2,3} ≡ {2,1,3} 중복을 허용하지 않는다. {1,1,2,3} ≡ {1,2,3} 중요 집합들 N = {1,2,3,4, … }, 자연수 집합 Z = {…,-2,-1,0,1,2,…}, 모든 정수 집합 Z+ = {1,2,3,…}, 양의 정수 집합 Q = {p / q | p ∈ Z, q ∈ Z, and q ≠ 0}, 유리수 집합 R, 실수 집합. Subset : 부분집합 예시 {1,2} ⊆ {1,2,3} {1,2,3} ⊆ {1,2,3} 특징 모든 집합 S에 대해서 (∅ ⊆ S) 와 (S ⊆ S)를 만족한다. ∀x(x ∈ A ⇒ x ∈ B) A : subset B : superset 진부분집합 : A ⊂ B A ⊆ B 그러나 A ≠ B ∀x(x ⊆ A ⇒ x ∈ B) ∧ ∃x(x ∈ B ∧ x ∉ A) Power Set : 멱집합(부분 집합의 집합) 특징 모든 부분 집합의 집합 P(S) 예시 P({0,1}) = {∅,{0},{1},{0,1}} P(∅) = {∅} P({∅}) = {∅,{∅}} Cartesian Products : 데카르트 곱 특징 두 집합 A, B가 있을때 A x B = {(x,y) | (x ∈ A) ∧ (y ∈ B)} A1 X A2 X …. X An = {(x1,x2,…,xn) | ∀i :xi ∈ Ai} 예시 A={1,2}, B={a,b,c} A X B = {(1,a), (1,b), (1,c), (2,a), (2,b), (2,c)} Union : 합집합 특징 A ∪ B = {x | x ∈ A ∨ x ∈ B} 예시 {1,3,5} ∪ {1,2,3} = {1,2,3,5} Intersection : 교집합 특징 A ∩ B = {x | x ∈ A ∧ x ∈ B} 예시 {1,3,5} ∩ {1,2,3} = {1,3} Disjoint : 서로소 집합 특징 서로 다른 두 집합의 교집합이 ∅ 이다. A와 B 는 서로소 집합 이다. 예시 A = {1,3,5,7}, B = {2,4,6,8} A ∩ B = ∅ Difference : 차집합 특징 A - B = {x | x ∈ A ∧ x ∉ B} 빼는 대상이 되는 집합에 따라 결과가 달라진다 예시 {1,3,5} - {1,2,3} = {5} {1,2,3} - {1,3,5} = {2} Complement : 여집합 특징 전체 집합 개념이 들어간다. AC = {x | x ∉ A} or U - A, 여기서 U 는 전체 집합이다. " }, { "title": "Logic(3)", "url": "/posts/logic(3)/", "categories": "discrete mathematics, logic and proofs", "tags": "cs, truth table, kocw", "date": "2024-02-12 17:00:00 +0900", "snippet": " Predicates : 술어 x 는 3보다 크다 x : 값 3보다 크다 : P = 술어 P(x) Q(x,y) = x는 y + 3과 같다. Q(1,2) false ⇒ 1 ≠ 2 + 3 Q(3,0) true ⇒ 3 = 0 + 3 n-place predicate ...", "content": " Predicates : 술어 x 는 3보다 크다 x : 값 3보다 크다 : P = 술어 P(x) Q(x,y) = x는 y + 3과 같다. Q(1,2) false ⇒ 1 ≠ 2 + 3 Q(3,0) true ⇒ 3 = 0 + 3 n-place predicate P(x1, x2, … xn) propositional function : 명제 함수 변수의 값에 의해 참과 거짓을 구변할 수 있는 문장이나 수식 명제함수에 값을 지정하는 방법 각 변수에 특정한 값을 부여 Quantifiers를 이용해 변수의 값을 제한. 전체 한정자(∀, universal quantifier), 존재한정자(∃, existential quantifier) Quantifiers Quantifiers : 한정자(공식을 만족하는 개인의 수를 지정하는 연산자) Universal quantification : 전체 한정자 ∀xP(x) “주어진 어떠한 ~에 대해서도”, “모든 ~에 대해서” Existential quantification : 존재 한정자 ∃xP(x) 주어진 술어를 만족시키는 객체가 논의 영역에 적어도 하나 존재함. Precedence of Quantifiers : 한정자의 우선 순위 모든 논리 연산자에 대해 우선 순위를 가지고 있다. ∀xP(x) ∨ Q(x) ≡ (∀xP(x)) ∨ Q(x) 하나의 명제 함수에 여러 한정자가 사용될 경우 해석에 주의, 서로 다른 한정자가 사용된다면 순서를 지켜야 한다. 여러 한정자가 사용된 명제 한수가 부정될 경우 다양한 해석이 존재 ￢∀x ∃y ∀z P(x,y,z) ≡ ∃x ￢∃y ∀z P(x,y,z) ≡ ∃x ∀y ￢∀z P(x,y,z) ≡ ∃x ∀y ∃z￢ P(x,y,z) Logical Equivalences Involving Quantifiers 한정자 관련된 논리적 동등성 statement equivalent statement ∀x(P(x) ∧ Q(x)) (∀xP(x)) ∧ (∀xQ(x)) ￢∃xP(x) ∀x￢P(x) ￢∀xP(x) ∃x￢P(x) Nested Quantifiers ∀x∃y(x + y = 0) 모든 x에 대하여 x + y = 0 을 만족시키는 y가 존재한다. ∀xQ(x)에서 Q(x)는 ∃y(x + y = 0) true ∃y∀x(x + y = 0) 어떤 y는 모든 x에 대하여 x + y = 0를 만족시키는 y가 존재한다. ∃yQ(y) 에서 Q(y)는 ∀x(x + y = 0) false Negation nested quantifiers ￢∀x∃y(xy=1) ≡ ∃x￢∃y(xy=1) ≡ ∃x∀y￢(xy=1) ≡ ∃x∀y(xy≠1) Valid Arguments : 전제가 true 일때 결론이 반드시 true 이다. Argument 제안 순서 (P1, P2, … Pn) Pn 이 되기 위해서는 이전의 제안들이 모두 ∧ 되어야한다. P1 ∧ P2 ∧ … ∧ Pn-1 ⇒ Pn Rules of Inference : 추론의 규칙 기존에 검증된 true 를 가지고 새로운 사실을 밝혀내는것. rule of inference name p ^ (p ⇒ q) ⇒ ∴q Modus ponens ￢q ∧ (p ⇒ q) ⇒ ∴￢q Modus tollens (p ⇒ q) ∧ (q ⇒ r) ⇒ ∴p ⇒ r Hypothetical syllogism (p ∨ q) ∧ ￢p ⇒ ∴q Disjunctive syllogism p ⇒ ∴p ∨ q Addition p ∧ q ⇒ ∴ p Simplification p ∧ q ⇒ ∴p ∧ q Conjunction (p ∨ q) ∧ (￢p ∨ r) ⇒ ∴q ∧ r Resolution 추론 판별 방법 p ⇒ qq∴ p | p ⇒ q | q | ∴ p | result ||——-|—|—–|——–|| T | T | T | pass || F | F | T | pass || T | T | F | fail || T | F | F | pass | 기존에 밝혀진 p ⇒ q, q 둘다 T 일 경우 p 도 무조건 T 가 되어야 하는데 F인 케이스이 발생함으로 유효하지 않은 추론이다. Normal Forms true or false 를 가지고 얻고 싶은 모든 케이스는 and, or, not 으로 만들 수 있다. Disjunctive Normal Form (DNF) (p ⇒ q) ∧ ￢q ≡ (￢p ∧ ￢q) ∨ (q ∧ ￢q) ∧ 의 ∨ 다. Conjunctive Normal Form (CNF) (p ⇒ q) ∧ ￢q ≡ (￢p ∨ q) ∧ ￢q p q c(carry) s 1 1 1 0 1 0 0 1 0 1 0 1 0 0 0 0 c ≡ p ∧ q s ≡ p ⊕ q 하지만 normal form 에서는 ⊕ 사용 불가. 해결책 : ￢(p ⇒ q) ∨ ￢(q ⇒ p) ￢(￢p ∨ q) ≡ p ∧ ￢q ￢(￢q ∨ p) ≡ q ∧ ￢p (p ∧ ￢q) ∨ (q ∧ ￢p) p q ￢q p ∧ ￢q T T F F T F T T F T F F F F T F Principal Disjunctive Normal Form minterm 들의 or p q r result T T T p ∧ q ∧ r T T F p ∧ q ∧ ￢r T F T p ∧ ￢q ∧ r T F F p ∧ ￢q ∧ ￢r F T T ￢p ∧ q ∧ r F T F ￢p ∧ q ∧ ￢r F F T ￢p ∧ ￢q ∧ r F F F ￢p ∧ ￢q ∧ ￢r minterm 의 or 연산과 똑같은 결과를 내는 다른 개념 ex) p ⊕ q p q p ⊕ q x y x ∧ y 1 1 0 0 1 0 1 0 1 1 1 1 0 1 1 1 1 1 0 0 0 1 0 0 " }, { "title": "Logic(2)", "url": "/posts/logic(2)/", "categories": "discrete mathematics, logic and proofs", "tags": "cs, truth table, kocw", "date": "2024-02-11 14:00:00 +0900", "snippet": " Precedence of Operator : 연산자 우선순위 연산자 우선순위 (￢p) ∧ q ≡ ￢p ∧ q (p ∧ q) ≡ p ∧ q operator precedence () 0 ￢ 1 ...", "content": " Precedence of Operator : 연산자 우선순위 연산자 우선순위 (￢p) ∧ q ≡ ￢p ∧ q (p ∧ q) ≡ p ∧ q operator precedence () 0 ￢ 1 ∧ 2 ∨ 3 ⇒ 4 ⇔ 5 (p ∨ ￢q) ⇒ (p ∧ q) p q ￢q p ∨ ￢q p ∧ q (p ∨ ￢q) ⇒ (p ∧ q) T T F T T T T F T T F F F T F F F T F F T T F F Consistence of Rules : 규칙의 일관성 규칙이 일관되지 않으면 모든 규칙을 함께 만족할 수 없다. {p ∨ q, ￢p, p ⇒ q} {p ∧ q, ￢p, p ⇒ q} p q ￢p p ∨ q p ∧ q p ⇒ q (p ∨ q) ∧ ￢p ∧ (p ⇒ q) (p ∧ q) ∧ ￢p ∧ (p ⇒ q) T T F T T T (T) ∧ (F) ∧ (T) ≡ F (T) ∧ (F) ∧ (T) ≡ F T F F T F F (T) ∧ (F) ∧ (F) ≡ F (F) ∧ (F) ∧ (T) ≡ F F T T T F T (T) ∧ (T) ∧ (T) ≡ T (F) ∧ (F) ∧ (T) ≡ F F F T F F T (F) ∧ (T) ∧ (T) ≡ F (F) ∧ (F) ∧ (T) ≡ F Logic and Bit Operator : 비트 논리 연산자 Bit bit 세계에서는 오직 0,1 false, true 로 구성되어있다. operator X Y result OR 01 1011 0110 11 0001 1101 11 1011 1111 AND 01 1011 0110 11 0001 1101 01 0001 0100 XOR 01 1011 0110 11 0001 1101 10 1010 1011 Tautology and Contradiction : 동어반복과 모순 Tautology : 항상 참인 복합명제, 동어반복 Contradiction : 항상 거짓인 복합명제, 모순 Contingency : 동어반복도 모순도 아닌 복합명제, 우연성 p ￢p p ∨ ￢p p ∧ ￢p T F T ∨ F ≡ T T ∧ F ≡ F F T F ∨ T ≡ T F ∧ T ≡ F Logical Equivalences : 논리적 동등성 법칙 Equivalence name p ∧ T ≡ q, p ∨ F ≡ p Identity laws p ∨ T ≡ T, p ∧ F ≡ F Domination laws p ∨ p ≡ p, p ∧ p ≡ p Idempotent laws ￢(￢p) ≡ p Double negation law p ∨ q ≡ q ∨ p, p ∧ q ≡ q ∧ p Commutative laws (p ∨ q) ∨ r ≡ p ∨ (q ∨ r), (p ∧ q) ∧ r ≡ p ∧ (q ∧ r) Associative laws p ∨ (q ∧ r) = (p ∨ q) ∧ (p ∨ r), p ∧ (q ∨ r) ≡ (p ∧ q) ∨ (p ∧ r) Distributive laws ￢(p ∧ q) = ￢p ∨ ￢q, ￢(p ∨ q) = ￢p ∧ ￢q De Morgan’s laws * p ∨ (p ∧ q) ≡ p, p ∧ (p ∨ q) ≡ q * Absorption laws p ∨ ￢p ≡ T, p ∧ ￢p ≡ F Negation laws ￢(p ⇒ q) ≡ ￢(￢p ∨ q) : 해당 논리가 맞다는걸 증명, ( * p ⇒ q ≡ ￢p ∨ q) ￢(￢p) ∧ ￢q ≡ p ∧ ￢q (p ∧ q) ⇒ (p ∨ q) : 해당 복합 명제가 항상 참임을 증명하라, ( * p ⇒ q ≡ ￢p ∨ q) ￢(p ∧ q) ∨ (p ∨ q) (￢p ∨ ￢q) ∨ (p ∨ q) (￢p ∨ p) ∨ (￢q ∨ q) (T) ∨ (T) T 항진명제와 모순명제 : tautology, contradiction 항진명제(tautology) 항상 참(T)인 명제를 항진명제라고 한다. p ⇒ p p ∨ ￢p p ∧ q ⇒ p ∧ q 모순명제(contradiction) 항상 거짓(F)인 명제를 모순명제라고 한다. p ∧ ~p (p ∧ q) ∧ ￢p (p ⇔ q) ∧ (p ⊕ q) " }, { "title": "Logic(1)", "url": "/posts/logic(1)/", "categories": "discrete mathematics, logic and proofs", "tags": "cs, logic, kocw", "date": "2024-02-11 12:00:00 +0900", "snippet": " Propositional Variables 명제를 나타내는 변수 p, q, r, s …. Negation 부정, ￢p p ￢p T F F T Conjunction(and, ∧) : 논리곱 and 연산 ...", "content": " Propositional Variables 명제를 나타내는 변수 p, q, r, s …. Negation 부정, ￢p p ￢p T F F T Conjunction(and, ∧) : 논리곱 and 연산 p q p ∧ q T T T T F F F T F F F F Disjunction(or, ∨) : 논리합 or 연산 p q p ∨ q T T T T F T F T T F F F Exclusive disjunction(⊕) : 배타적 논리합 xor, 배타적 논리합 두개의 명제가 주어 졌을 때 둘중 하나만 (T)인 경우에 연산 결과를 T로한다. p ⊕ q ≡ (p ∧ ￢q) ∨ (￢p ∧ q) p q (p ∧ ￢q) ∨ (￢p ∧ q) p ⊕ q T T F F T F T T F T T T F F F F Condition Proposition : 조건명제 명제 p와 q가 있을 때, 명제 p가 조건의 역할을 수행하고 명제q가 결론의 역할을 수행하는 경우 p와 q의 합성명제를 조건명제라고 하고 p ⇒ q 라고 표기한다. 가정어구 : p ⇒ q if p then q : p(가정, hypothesis), q(결과, conclusion) Converse(반대) : q ⇒ p Inverse(역) : ￢p ⇒ ￢q Contrapositive(대우) : ￢q ⇒ ￢p p q p ⇒ q T T T T F F F T T F F T 필요 조건과 충분 조건 : necessary and sufficient condition p와 q가 명제일 때 “if q, then q”형식으로 표현할 수 있으면, p가 일어나면 항상 q가 일어나는 것을 보장한다는 의미에서 p를 q의 충분 조건이라고 한다. “if not p, then not q”형식으로 표현항 수 있으면, q가 일어나는 데 필요하다는 의미에서, p를 q의 필요조건이라고한다 조건 명제 p ⇒ q, 에서 p를 q의 충분조건이라고 하고, q를 p 의 필요 조건이라고 한다. BiCondition Statements : 쌍조건 명제 이중 조건문 : p ⇔ q if p and only if q (p ⇒ q) ∧ (q ⇒ p) p q p ⇒ q q ⇒ p p ⇔ q T T T T T T F F T F F T T F F F F T T T " }, { "title": "Spring Redis", "url": "/posts/spring_redis_hSet_hGetAll/", "categories": "Spring, Redis", "tags": "back-end, spring, redis, docker redis, reflection, hSet, hGetAll", "date": "2024-02-07 00:00:00 +0900", "snippet": "정리 코드 redis hash set &lt;T&gt; T hSet(String key, T t) throws ClassNotFoundException@Overridepublic &lt;T&gt; T hSet(String key, T t) throws ClassNotFoundException { long result = jedis.hset(k...", "content": "정리 코드 redis hash set &lt;T&gt; T hSet(String key, T t) throws ClassNotFoundException@Overridepublic &lt;T&gt; T hSet(String key, T t) throws ClassNotFoundException { long result = jedis.hset(key, hSetHelper(t)); // hSet을 해주는 부분. if (result &lt;= 0L) { return null; // 저장이 안되면 null 반환 } else { return t; // 저장되면 t 반환 }} redis hash get all public &lt;T&gt; T hGetAll(String key, Class&lt;T&gt; type) throws ClassNotFoundException@Overridepublic &lt;T&gt; T hGetAll(String key, Class&lt;T&gt; type) throws ClassNotFoundException { Map&lt;String, String&gt; stringStringMap = jedis.hgetAll(key); String classInfo = stringStringMap.get(CLASS_INFO); Class&lt;T&gt; aClass = (Class&lt;T&gt;) Class.forName(classInfo); T instance = null; try { Constructor&lt;?&gt;[] constructors = aClass.getDeclaredConstructors(); for (Constructor&lt;?&gt; constructor : constructors) { if (stringStringMap.size() - 1 == constructor.getParameterTypes().length) { Class&lt;?&gt;[] paramTypes = constructor.getParameterTypes(); // 생성자의 매개변수 타입을 가져와야 함 Object[] args = new Object[paramTypes.length]; int index = 0; for (String paramName : stringStringMap.keySet()) { if (!paramName.equals(CLASS_INFO)) { args[index++] = stringStringMap.get(paramName); // 매개변수 값 설정 } } instance = (T) constructor.newInstance(args); // 새로운 인스턴스 생성 break; // 적절한 생성자를 찾았으므로 루프 종료 } } if (instance == null) { return null; } for (Field field : aClass.getDeclaredFields()) { field.setAccessible(true); // 접근 제한 해제 String fieldName = field.getName(); String mapValue = stringStringMap.get(fieldName); if (mapValue != null) { field.set(instance, mapValue); } } } catch (InstantiationException | IllegalAccessException | InvocationTargetException e) { log.error(\"exception = \", e); return null; } return instance;} 도우미 메소드 private &lt;T&gt; Map&lt;String, String&gt; hSetHelper(T t) { Map&lt;String, String&gt; setMap = new HashMap&lt;&gt;(); setClassInfoToHash(t, setMap); Field[] fields = t.getClass().getDeclaredFields(); for (Field field : fields) { try { field.setAccessible(true); Object value = field.get(t); setMap.put(field.getName(), value.toString()); } catch (IllegalAccessException illegalAccessException) { log.error(\"illegalAccessError = \", illegalAccessException); } } return setMap;}// 전달받은 클래스 정보를 셋팅해주기 위한 메소드.private &lt;T&gt; void setClassInfoToHash(T t, Map&lt;String, String&gt; setMap) { setMap.put(CLASS_INFO, t.getClass().toString().replace(\"class \", \"\"));} 테스트를 위한 클래스 및 equals(Object o), hashCode() 메소드 셋팅 UserInfo class @Getter@Setter@ToStringpublic class UserInfo { private String email; private String password; private String name; public UserInfo() { } @Builder public UserInfo(String email, String password, String name) { this.email = email; this.password = password; this.name = name; } @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; UserInfo userInfo = (UserInfo) o; return Objects.equals(email, userInfo.email) &amp;&amp; Objects.equals(password, userInfo.password) &amp;&amp; Objects.equals(name, userInfo.name); } @Override public int hashCode() { return Objects.hash(email, password, name); }} TestInfo class @Getter@Setter@ToStringpublic class TestInfo { private String val1; private String val2; public TestInfo() { } @Builder public TestInfo(String val1, String val2) { this.val1 = val1; this.val2 = val2; } @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; TestInfo testInfo = (TestInfo) o; return Objects.equals(val1, testInfo.val1) &amp;&amp; Objects.equals(val2, testInfo.val2); } @Override public int hashCode() { return Objects.hash(val1, val2); }} 테스트 코드 @SpringBootTestpublic class ReflectionTest { @Autowired MyRedisService myRedisService; @Test public void jedisTest() throws ClassNotFoundException { UserInfo userInfo = UserInfo.builder() .name(\"홍길동\") .password(\"1q2w3e4r!\") .email(\"ghdrlfehd@gmail.com\") .build(); TestInfo testInfo = TestInfo.builder() .val1(\"val1\") .val2(\"val2\") .build(); UserInfo saveUserInfo = myRedisService.hSet(\"user\", userInfo); TestInfo saveTestInfo = myRedisService.hSet(\"test\", testInfo); UserInfo findUser = myRedisService.hGetAll(\"user\", UserInfo.class); TestInfo findTest = myRedisService.hGetAll(\"test\", TestInfo.class); Assertions.assertEquals(saveUserInfo,findUser); Assertions.assertEquals(saveTestInfo,findTest); }} 테스트 전 redis 상태 테스트 결과 " }, { "title": "Reflection(2)", "url": "/posts/reflection_basic(2)/", "categories": "Java, Reflection", "tags": "java, reflection, reflection constructors", "date": "2024-02-07 00:00:00 +0900", "snippet": "정리_코드 Class&lt;?&gt; clazz : 클래스의 정보를 담고있는 클래스 clazz.getDeclaredConstructors() : 선언되어 있는 모든 생성자를 가져온다. Person class public static class Person { private final Address address...", "content": "정리_코드 Class&lt;?&gt; clazz : 클래스의 정보를 담고있는 클래스 clazz.getDeclaredConstructors() : 선언되어 있는 모든 생성자를 가져온다. Person class public static class Person { private final Address address; private final String name; private final int age; public Person() { this.name = \"anonymous\"; this.age = 0; this.address = null; } public Person(String name) { this.name = name; this.age = 0; this.address = null; } public Person(String name, int age) { this.name = name; this.age = age; this.address = null; } public Person(Address address, String name, int age) { this.name = name; this.age = age; this.address = address; } @Override public String toString() { return \"Person{\" + \"address=\" + address + \", name='\" + name + '\\'' + \", age=\" + age + '}'; }} Address classpublic static class Address { private String street; private int number; public Address(String street, int number) { this.street = street; this.number = number; } @Override public String toString() { return \"Address{\" + \"street='\" + street + '\\'' + \", number=\" + number + '}'; }} 클래스의 생성자들의 정보를 가져오는 코드public static void printConstructorData(Class&lt;?&gt; clazz) { Constructor&lt;?&gt;[] constructors = clazz.getDeclaredConstructors(); // 클래스에 정의된 모든 생성자를 가져온다. System.out.printf(\"class %s has %d declared constructors%n\", clazz.getSimpleName(), constructors.length); for (int i = 0; i &lt; constructors.length; i++) { // 정의된 생성자의 수 만큼 for 문을 돌린다. Class&lt;?&gt;[] parameterTypes = constructors[i].getParameterTypes(); // 생성자에 선언된 파라미터를 가져온다. List&lt;String&gt; parameterTypeNames = Arrays.stream(parameterTypes) .map(Class::getSimpleName) .toList(); System.out.println(parameterTypeNames); }}class Person has 4 declared constructors[Address, String, int][String, int][String][] 클래스의 정보와 생성자 인수를 받아 반환해주는 메소드 public static &lt;T&gt; T createInstanceWithArguments(Class&lt;T&gt; clazz, Object... objects) throws InvocationTargetException, InstantiationException, IllegalAccessException { for (Constructor&lt;?&gt; constructor : clazz.getDeclaredConstructors()) { // 선언된 생성자를 가져온다. if (constructor.getParameterTypes().length == objects.length) { // 생성자의 필드 수와 인자의 길이를 비교해서 맞는 생성자 클래스를 반환한다, getParameterTypes(), getTypeParameters() * 주의 return (T) constructor.newInstance(objects); } } System.out.println(\"not found\"); return null; } 실행 코드 public static void main(String[] args) throws InvocationTargetException, InstantiationException, IllegalAccessException {// printConstructorData(Person.class); // 생성자 목록 확인 Person noArgumentConstructors = createInstanceWithArguments(Person.class); System.out.println(noArgumentConstructors); Address address = createInstanceWithArguments(Address.class, \"동작구\", 104); System.out.println(address); Person allArgumentConstructors = createInstanceWithArguments(Person.class, address, \"홍길동\", 20); System.out.println(allArgumentConstructors); } Person{address=null, name='anonymous', age=0} Address{street='동작구', number=104} Person{address=Address{street='동작구', number=104}, name='홍길동', age=20}" }, { "title": "Reflection(1)", "url": "/posts/reflection_basic(1)/", "categories": "Java, Reflection", "tags": "java, reflection", "date": "2024-02-07 00:00:00 +0900", "snippet": "정리_코드 Class&lt;?&gt; clazz : 클래스의 정보를 담고있는 클래스 clazz.getSimpleName() : 클래스의 이름을 가져온다 clazz.getPackageName() : 패키지의 이름을 가져온다 clazz.getInterfaces() : implements하고 있는 인터페이스 목록을 가...", "content": "정리_코드 Class&lt;?&gt; clazz : 클래스의 정보를 담고있는 클래스 clazz.getSimpleName() : 클래스의 이름을 가져온다 clazz.getPackageName() : 패키지의 이름을 가져온다 clazz.getInterfaces() : implements하고 있는 인터페이스 목록을 가져온다 clazz.isArray() : 배열인지 확인한다. clazz.isPrimitive : 원시 타입인지 확인한다. clazz.isEnum() : Enum 타입인지 확인한다. clazz.interface() : 인터페이스인지 확인한다 clazz.anonyMous() : 익명 클래스인지 확인한다. Class.forName(String className) : 클래스의 경로를 인자로 넘겨 클래스를 가져온다. nested 클래스의 경우 $ 표시를 이용해 접근할 수 있다. 예제 코드package ch1;import java.util.Collection;import java.util.HashMap;import java.util.Map;public class Main { public static void main(String[] args) throws ClassNotFoundException { Class&lt;String&gt; stringClass = String.class; Map&lt;String, Integer&gt; mapObject = new HashMap&lt;&gt;(); Class&lt;?&gt; hashMapClass = mapObject.getClass(); Class&lt;?&gt; squareClass = Class.forName(\"ch1.Main$Square\"); printClassInfo(stringClass, hashMapClass, squareClass, Collection.class, boolean.class, int[][].class, Color.class); } private static void printClassInfo(Class&lt;?&gt;... classes) { for (Class&lt;?&gt; clazz : classes) { System.out.println( String.format( \"class name : %s, class package name : %s\", clazz.getSimpleName(), // 클래스 이름 clazz.getPackageName() // 패키지 이름 ) ); Class&lt;?&gt;[] implementedInterfaces = clazz.getInterfaces(); // 인터페이스 목록 가져오기 for (Class&lt;?&gt; implementedInterface : implementedInterfaces) { System.out.println( String.format( \"class %s implements : %s\", clazz.getSimpleName(), implementedInterface.getSimpleName() // 인터페이스 이름. ) ); } // 각각 타입 체크 System.out.println(\"is array : \" + clazz.isArray()); System.out.println(\"is primitive : \" + clazz.isPrimitive()); System.out.println(\"is enum : \" + clazz.isEnum()); System.out.println(\"is interface : \" + clazz.isInterface()); System.out.println(\"is anonymous : \" + clazz.isAnonymousClass()); System.out.println(); } } public static class Square implements Drawable { @Override public int getNumberOfCorners() { return 4; } } private static interface Drawable { int getNumberOfCorners(); } private enum Color { BLUE, RED, GREEN }} 실행 결과class name : String, class package name : java.langclass String implements : Serializableclass String implements : Comparableclass String implements : CharSequenceclass String implements : Constableclass String implements : ConstantDescis array : falseis primitive : falseis enum : falseis interface : falseis anonymous : falseclass name : HashMap, class package name : java.utilclass HashMap implements : Mapclass HashMap implements : Cloneableclass HashMap implements : Serializableis array : falseis primitive : falseis enum : falseis interface : falseis anonymous : falseclass name : Square, class package name : ch1class Square implements : Drawableis array : falseis primitive : falseis enum : falseis interface : falseis anonymous : falseclass name : Collection, class package name : java.utilclass Collection implements : Iterableis array : falseis primitive : falseis enum : falseis interface : trueis anonymous : falseclass name : boolean, class package name : java.langis array : falseis primitive : trueis enum : falseis interface : falseis anonymous : falseclass name : int[][], class package name : java.langclass int[][] implements : Cloneableclass int[][] implements : Serializableis array : trueis primitive : falseis enum : falseis interface : falseis anonymous : falseclass name : Color, class package name : ch1is array : falseis primitive : falseis enum : trueis interface : falseis anonymous : false" }, { "title": "Reflection(3)", "url": "/posts/reflection_access_private/", "categories": "Java, Reflection", "tags": "java, reflection, reflection constructors, reflection accessible", "date": "2024-02-07 00:00:00 +0900", "snippet": "정리_코드 접근 제한된 생성자, 필드에 접근하는 방법 public static void initConfiguration() throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException { Constructor&lt;...", "content": "정리_코드 접근 제한된 생성자, 필드에 접근하는 방법 public static void initConfiguration() throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException { Constructor&lt;ServerConfiguration&gt; constructor = ServerConfiguration.class.getDeclaredConstructor(int.class, String.class); // 특정 클래스에서 인자로 받은 타입을 인자로 받는 생성자를 찾아서 반환한다. constructor.setAccessible(true); // 접근 제한을 전부 허용한다. constructor.newInstance(8080, \"Good Day!\"); // 새로운 인스턴스를 생성한다.} 실행 코드 : HttpServer 를 구성하고 요청을 보낸 후 응답을 받는다. public static void main(String[] args) throws InvocationTargetException, NoSuchMethodException, InstantiationException, IllegalAccessException, IOException { initConfiguration(); WebServer webServer = new WebServer(); webServer.startServer();} 구성 클래스 WebServer class public class WebServer { public void startServer() throws IOException { HttpServer httpServer = HttpServer.create(ServerConfiguration.getInstance().getServerAddress(), 0); httpServer.createContext(\"/greeting\").setHandler(exchange -&gt; { // /greeting 경로의 핸들러생성 String responseMessage = ServerConfiguration.getInstance().getGreetingMessage(); exchange.sendResponseHeaders(200, responseMessage.length()); OutputStream responseBody = exchange.getResponseBody(); responseBody.write(responseMessage.getBytes()); responseBody.flush(); responseBody.close(); }); System.out.println(String.format(\"Starting server on address %s:%d\", ServerConfiguration.getInstance().getServerAddress().getHostName(), ServerConfiguration.getInstance().getServerAddress().getPort())); httpServer.start(); }} ServerConfiguration class public class ServerConfiguration { private static ServerConfiguration serverConfigurationInstance; private final InetSocketAddress serverAddress; private final String greetingMessage; private ServerConfiguration(int port, String greetingMessage) { this.greetingMessage = greetingMessage; this.serverAddress = new InetSocketAddress(port); if (serverConfigurationInstance == null) { serverConfigurationInstance = this; } } public static ServerConfiguration getInstance() { return serverConfigurationInstance; } public InetSocketAddress getServerAddress() { return this.serverAddress; } public String getGreetingMessage() { return this.greetingMessage; }} 실행 코드 Starting server on address 0.0.0.0:8080" }, { "title": "JedisPool Bean 등록 에러", "url": "/posts/jedis_bean_exception/", "categories": "Exception, Spring Jedis", "tags": "spring framework, bean registration, jedis pool, MXbean already", "date": "2024-02-07 00:00:00 +0900", "snippet": " jedis bean 등록 이후 connection pool 설정을 하려했을때 발생한 문제 이전에 설정했던 jedis bean 문제가된 코드 문제가된 Bean : @Bean(“myJedisPool”) @Slf4j@Configurationpublic class MyRedisConfig { @Value(\"${data.redis.hos...", "content": " jedis bean 등록 이후 connection pool 설정을 하려했을때 발생한 문제 이전에 설정했던 jedis bean 문제가된 코드 문제가된 Bean : @Bean(“myJedisPool”) @Slf4j@Configurationpublic class MyRedisConfig { @Value(\"${data.redis.host}\") private String HOST; @Value(\"${data.redis.port}\") private int PORT; @Value(\"${data.redis.maxTotal}\") private int MAX_TOTAL; @Value(\"${data.redis.maxIdle}\") private int MAX_IDLE; @Value(\"${data.redis.minIdle}\") private int MIN_IDLE; @Value(\"${data.redis.maxWaitMillis}\") private long MAX_WAIT_MILLIS; @Bean(\"myJedisPool\") public JedisPool myJedisPool() { JedisPoolConfig poolConfig = new JedisPoolConfig(); poolConfig.setMaxTotal(MAX_TOTAL); poolConfig.setMaxIdle(MAX_IDLE); poolConfig.setMinIdle(MIN_IDLE); poolConfig.setMaxWaitMillis(MAX_WAIT_MILLIS); try { return new JedisPool(poolConfig, HOST, PORT); } catch (Exception e) { log.error(\"Error initializing Jedis pool\", e); return null; } } @Bean public Jedis jedis(@Qualifier(\"myJedisPool\") JedisPool jedisPool) { try ( Jedis jedis = jedisPool.getResource(); ) { return jedis; } catch (JedisException jedisException) { log.error(\"jedis bean registration fail\", jedisException); return null; } }}Caused by: javax.management.InstanceAlreadyExistsException: MXBean already registered with name org.apache.commons.pool2:type=GenericObjectPool,name=pool\tat java.management/com.sun.jmx.mbeanserver.MXBeanLookup.addReference(MXBeanLookup.java:152) ~[na:na]\tat java.management/com.sun.jmx.mbeanserver.MXBeanSupport.register(MXBeanSupport.java:160) ~[na:na]\tat java.management/com.sun.jmx.mbeanserver.MBeanSupport.preRegister2(MBeanSupport.java:173) ~[na:na]\tat java.management/com.sun.jmx.interceptor.DefaultMBeanServerInterceptor.registerDynamicMBean(DefaultMBeanServerInterceptor.java:924) ~[na:na]\tat java.management/com.sun.jmx.interceptor.DefaultMBeanServerInterceptor.registerObject(DefaultMBeanServerInterceptor.java:895) ~[na:na]\tat java.management/com.sun.jmx.interceptor.DefaultMBeanServerInterceptor.registerMBean(DefaultMBeanServerInterceptor.java:320) ~[na:na]\tat java.management/com.sun.jmx.mbeanserver.JmxMBeanServer.registerMBean(JmxMBeanServer.java:523) ~[na:na]\tat org.springframework.jmx.support.MBeanRegistrationSupport.doRegister(MBeanRegistrationSupport.java:138) ~[spring-context-6.1.3.jar:6.1.3]\tat org.springframework.jmx.export.MBeanExporter.registerBeanInstance(MBeanExporter.java:687) ~[spring-context-6.1.3.jar:6.1.3]\tat org.springframework.jmx.export.MBeanExporter.registerBeanNameOrInstance(MBeanExporter.java:631) ~[spring-context-6.1.3.jar:6.1.3]\t... 14 common frames omitted 어떤 이유인지는 몰라도 해당 부분에서 MXbean에 이미 등록되었다고 나옴실제로 디버깅을 해보니 multiname이 null 로 들어가 발생 해결 방법 : 여러 사이트를 돌아다니면서 테스트를 해보았으나 결국, JMX를 이용한 JedisPool 모니터링을 포기하고 해당 코드 추가 : poolConfig.setJmxEnabled(false);@Bean(\"myJedisPool\")public JedisPool myJedisPool() { JedisPoolConfig poolConfig = new JedisPoolConfig(); poolConfig.setJmxEnabled(false); poolConfig.setMaxTotal(MAX_TOTAL); poolConfig.setMaxIdle(MAX_IDLE); poolConfig.setMinIdle(MIN_IDLE); poolConfig.setMaxWaitMillis(MAX_WAIT_MILLIS); try { return new JedisPool(poolConfig, HOST, PORT); } catch (Exception e) { log.error(\"Error initializing Jedis pool\", e); return null; }} 실행 확인" }, { "title": "Reflection", "url": "/posts/spring_jedis/", "categories": "Java, Reflection", "tags": "java, reflection, redis, jedis, spring", "date": "2024-02-06 00:00:00 +0900", "snippet": " 런타임 시점에 구체적인 클래스 타입을 몰라도, 해당 클래스의 정보를 알 수 있는 자바 기능 Jedis를 사용하여 HSET 기능을 구현하려 할때 DTO를 직접 넣지 못하고 key : value를 직접 설정해야하는 번거러움이 있어서 해당 문제를 해결하려 학습. 구현할 interface ...", "content": " 런타임 시점에 구체적인 클래스 타입을 몰라도, 해당 클래스의 정보를 알 수 있는 자바 기능 Jedis를 사용하여 HSET 기능을 구현하려 할때 DTO를 직접 넣지 못하고 key : value를 직접 설정해야하는 번거러움이 있어서 해당 문제를 해결하려 학습. 구현할 interface 구성 public interface MyRedisService { &lt;T&gt; T hGetAll(String key); // hash 에 모든 정보를 가져온다. &lt;F&gt; F hGet(String key, String hashKey, Class&lt;F&gt; uClass); // hash 안에 특정 필드를 가져온다} 구현할 구현체 구성 @Slf4j@Component@RequiredArgsConstructorpublic class MyRedisServiceImpl implements MyRedisService { private final Jedis jedis; @Override public &lt;T&gt; T hSet(String key, T t) { return t; } @Override public &lt;T&gt; T hGetAll(String key) { return null; } @Override public &lt;F&gt; F hGet(String key, String hashKey, Class&lt;F&gt; uClass) { return null; } private &lt;T&gt; void hSetHelper(T t) { // 리플렉션으로 t의 정보를 전부 가져온다. // redis 에 insert 해준다. } private &lt;T&gt; T hGetAllHelper(String key) { // key 로 hash 정보를 가져온다. // 리플렉션을 이용해 객체를 만들어 반환한다. return null; } private &lt;F&gt; F hGetHelper(String key, String hashKey, Class&lt;F&gt; fClass) { // key값을 이용해 redis 에서 hash 정보를 가져온다 // 가져온 값중에서 field 값을 가져온다 return null; }} Jedis @Bean 구성 @Slf4j@Configurationpublic class RedisConfig { @Value(\"${data.redis.host}\") private String HOST; @Value(\"${data.redis.port}\") private int PORT; @Bean public Jedis jedis() { try ( JedisPool jedisPool = new JedisPool(HOST, PORT); Jedis jedis = jedisPool.getResource(); ) { return jedis; } catch (JedisException jedisException) { log.error(\"jedis bean registration fail\", jedisException); return null; } }}" }, { "title": "Spring Redis", "url": "/posts/spring_redis_setting/", "categories": "Spring, Redis", "tags": "back-end, spring, redis, docker redis", "date": "2024-02-04 00:00:00 +0900", "snippet": "정리 코드 Spring Redis 연동하기 개발 환경 : Spring boot 3.2.2, java17 의존성 dependencies { implementation 'org.springframework.boot:spring-boot-starter-data-redis' implementation 'org.springframework....", "content": "정리 코드 Spring Redis 연동하기 개발 환경 : Spring boot 3.2.2, java17 의존성 dependencies { implementation 'org.springframework.boot:spring-boot-starter-data-redis' implementation 'org.springframework.boot:spring-boot-starter-thymeleaf' implementation 'org.springframework.boot:spring-boot-starter-web' compileOnly 'org.projectlombok:lombok' annotationProcessor 'org.projectlombok:lombok' testImplementation 'org.springframework.boot:spring-boot-starter-test' } docker-redis 구축 : docker redis 구축 방법 Spring boot application 설정 : 추후 환경 설정을 위해 설정 프로필을 분리 설정 application.yaml 설정 spring: profiles: active: data application-data.yaml 설정 data: redis: host: 127.0.0.1 port: 6379 RedisConfig 설정@Slf4j@Configurationpublic class RedisConfig { @Value(\"${data.redis.host}\") private String HOST; @Value(\"${data.redis.port}\") private int PORT; @Bean(\"sessionRedisConnectionsFactory\") public RedisConnectionFactory sessionRedisConnectionsFactory() { return redisConnectionFactory(HOST, PORT); } @Bean(\"sessionRedisTemplate\") public RedisTemplate&lt;String, Object&gt; sessionRedisTemplate() { return returnRedisTemplate(sessionRedisConnectionsFactory()); } private RedisConnectionFactory redisConnectionFactory(final String host, final int port) { return new LettuceConnectionFactory(host, port); } private RedisTemplate&lt;String, Object&gt; returnRedisTemplate(RedisConnectionFactory redisConnectionFactory) { RedisTemplate&lt;String, Object&gt; redisTemplate = new RedisTemplate&lt;&gt;(); redisTemplate.setConnectionFactory(redisConnectionFactory); redisTemplate.setKeySerializer(new StringRedisSerializer()); redisTemplate.setValueSerializer(new Jackson2JsonRedisSerializer&lt;&gt;(Object.class)); redisTemplate.setHashKeySerializer(new StringRedisSerializer()); redisTemplate.setHashValueSerializer(new Jackson2JsonRedisSerializer&lt;&gt;(Object.class)); redisTemplate.setDefaultSerializer(new Jackson2JsonRedisSerializer&lt;&gt;(Object.class)); return redisTemplate; }} Spring Redis CrudRepository 구성 1 ] spring redis entity 2 ] spring redis repository 3 ] spring redis service 4 ] 서비스 테스트 spring redis entity @Getter@Setter@ToString@NoArgsConstructor@RedisHash(value = \"user\") // timeToLive 옵션으로 세션 타임 설정 가능public class RedisUserSession { @Id // RedisHash value 뒤에 붙는 해쉬값 private String hash; private String userId; private String password; private LocalDateTime signIn; @Builder public RedisUserSession(String userId, String password) { this.userId = userId; this.password = password; this.signIn = LocalDateTime.now(); }} spring redis repository import org.spring.redis.entity.redis.RedisUserSession;import org.springframework.data.repository.CrudRepository;public interface RedisUserSessionRepository extends CrudRepository&lt;RedisUserSession, String&gt; {} spring redis service public interface RedisUserSessionService { RedisUserSession saveRedisUserSession(RedisUserSession redisUserSession);}@Slf4j@Service@RequiredArgsConstructorpublic class RedisUserSessionServiceImpl implements RedisUserSessionService { private final RedisUserSessionRepository redisUserSessionRepository; @Override public RedisUserSession saveRedisUserSession(RedisUserSession redisUserSession) { RedisUserSession result = redisUserSessionRepository.save(redisUserSession); log.info(\"result = {}\", result); return result; }} redis service test @SpringBootTestpublic class RedisRepositoryTest { @Autowired RedisUserSessionService redisUserSessionService; @Test public void redis_user_session_set_test() { RedisUserSession redisUserSession = RedisUserSession.builder() .userId(\"홍길동\") .password(\"1q2w3e4r!\") .build(); RedisUserSession session = redisUserSessionService.saveRedisUserSession(redisUserSession); Assertions.assertNotNull(session); }} 실행 전 redis 상태 실행 후 redis 상태 redis gui 로 본 내부 상태 entity에 설정한 RedisHash value 값을 key, @Id값을 리스트로 저장하고,value:@Id 를 key, 내부 필드를 value로 하는 HASH 형태로 저장한다. ToDO : Redis로 회원가입, 로그인, 로그아웃 기능 구현. " }, { "title": "Redis(2)", "url": "/posts/Redis(2)/", "categories": "DataBase, Redis", "tags": "HSET, HGET, HGETALL, HEXISTS, HDEL", "date": "2024-02-03 00:00:00 +0900", "snippet": " HSET : Hash 저장 HSET company name 'Concrete Co' age 1915 industry materials revenue 5.3 HGET : Hash 안에 특정 요소 검색 HGET company name HGETALL : 모든 요소 가져오기 HGETALL company HEXISTS : 포함 여부 조사 H...", "content": " HSET : Hash 저장 HSET company name 'Concrete Co' age 1915 industry materials revenue 5.3 HGET : Hash 안에 특정 요소 검색 HGET company name HGETALL : 모든 요소 가져오기 HGETALL company HEXISTS : 포함 여부 조사 HEXISTS company age HDEL : Hash 요소 삭제 HDEL company name" }, { "title": "Redis(1)", "url": "/posts/Redis(1)/", "categories": "DataBase, Redis", "tags": "spring framework, cache, server architecture, in-memory database, key value store", "date": "2024-02-03 00:00:00 +0900", "snippet": " 학습 이유 실무 프로젝트 진행중 다중 인스턴스에 대한 세션을 하나의 포인트에서 관리하기 위해. 자주 쿼리되는 데이터셋을 Caching 하여 성능적으로 이득을 보기 위해. Redis의 특징 1 ] 애플리케이션 캐시나 빠른 응답 속도를 가진 데이터 베이스2 ] 인메모리에 NoSQL형태의 key/value 저장소3...", "content": " 학습 이유 실무 프로젝트 진행중 다중 인스턴스에 대한 세션을 하나의 포인트에서 관리하기 위해. 자주 쿼리되는 데이터셋을 Caching 하여 성능적으로 이득을 보기 위해. Redis의 특징 1 ] 애플리케이션 캐시나 빠른 응답 속도를 가진 데이터 베이스2 ] 인메모리에 NoSQL형태의 key/value 저장소3 ] 메모리에 데이터를 저장하기 때문에 속도, 안정성등에서 성능적으로 탁월함 (메모리를 스냅샷하여 데이터 보존 가능)4 ] 레디스만의 다양한 Collection을 지원5 ] 싱글 쓰레드로 실행됨으로 실행시간이 긴 명령을 수행하기에는 부적합 Redis 설치 1 ] docker pull redis:alpine : 이미지 다운받기2 ] docker run -d -p 6379:6379 --name=\"컨테이너 이름\" redis:alpine : 컨데이터 띄우기3 ] docker exec -it \"컨테이너 이름\" /bin/sh : redis 컨테이너 진입4 ] redis-cli : redis 관련 명령어를 실행할 수 있는 cli 콘솔 실행 3 ] https://redis.com/redis-enterprise/redis-insight/ 사이트에서 GUI 설치후 실행, 추후 CLI + 자바와 연동해서 데이터 상황을 보기 위해 다운받는다. redis-cli 에서 String set SET 한 메세지 확인 REDIS에서 제공하는 데이터 타입 종류 (type, commands : (https://redis.io/commands/)) 문법 1 ] SET [key] [value] GET : 기존에 있던 value값을 가져오고 해당 key에 value를 셋팅2 ] SET [key] [value] XX : key 가 존재하면 value 값으로 덮어 씌운다, key가 존재 하지 않으면 null 반환3 ] SET [key] [value] NX : key 가 존재하면 null 반환, key가 존재하지 않으면 value값을 저장4 ] SET [key] [value] EX [second] : 해당 값을 설정한 second만큼 동안만 기록하고있는다. * 시간과 관련된 옵션 EX | PX | EXAT | PXAT | KEEPTTL5 ] SETEX [key] [second] [value] : key 값에 second 시간 동안 value를 저장한다. 이후에 비워짐, 4] 번과 동일6 ] SETNX [key] [value] : key 값이 존재하지 않으면 value를 저장한다. 3] 번과 동일7 ] MSET [key] [value] [key] [value] ..... : key와 value를 한번에 여러개를 설정할 수 있다.8 ] MGET [key] [key] .... : 한번에 여러 key값에 대응하는 value 값을 얻는다.9 ] DEL [key] : 해당 key를 지운다.10 ] GETRANGE [key] [start index] [end index] : 해당 key에 해당하는 value값을 설정한 index를 기준으로 잘라서 가져운다11 ] SETRANGE [key] [index] [value] : key에 대응하는 value 값의 인덱스부터 value 값을 채워넣는다. " }, { "title": "234. Palindrome Linked List", "url": "/posts/recursion(5)/", "categories": "leetcode, recursion", "tags": "data, cs, algorithm, leetcode, recursion", "date": "2024-02-03 00:00:00 +0900", "snippet": "정리 코드 Recursion Function(재귀함수) : 자기 자신을 재참조, 종료 조건으로 종료 시점을 제어한다. leetcode : 234. Palindrome Linked List 조건 The number of nodes in the list is in the range [1, 105]. 0 &lt;= Node....", "content": "정리 코드 Recursion Function(재귀함수) : 자기 자신을 재참조, 종료 조건으로 종료 시점을 제어한다. leetcode : 234. Palindrome Linked List 조건 The number of nodes in the list is in the range [1, 105]. 0 &lt;= Node.val &lt;= 9 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */class Solution { private ListNode current; public boolean isPalindrome(ListNode head) { current = head; return isPalindromeHelper(head); } public boolean isPalindromeHelper(ListNode node) { if (node == null) { return true; } boolean isPalindromeTail = isPalindromeHelper(node.next); boolean isPalindromeCurrent = (current.val == node.val); current = current.next; return isPalindromeTail &amp;&amp; isPalindromeCurrent; }}" }, { "title": "231. Power of Two", "url": "/posts/recursion(4)/", "categories": "leetcode, recursion", "tags": "data, cs, algorithm, leetcode, recursion", "date": "2024-02-03 00:00:00 +0900", "snippet": "정리 코드 Recursion Function(재귀함수) : 자기 자신을 재참조, 종료 조건으로 종료 시점을 제어한다. leetcode : 231. Power of Two 조건 -231 &lt;= n &lt;= 231 - 1 class Solution { public boolean isPowerOfTwo(int n) {...", "content": "정리 코드 Recursion Function(재귀함수) : 자기 자신을 재참조, 종료 조건으로 종료 시점을 제어한다. leetcode : 231. Power of Two 조건 -231 &lt;= n &lt;= 231 - 1 class Solution { public boolean isPowerOfTwo(int n) { if (n &lt;= 0) return false; if (n == 1) return true; if (n % 2 != 0) { return false; } return isPowerOfTwo(n / 2); }}" }, { "title": "206. Reverse Linked List", "url": "/posts/recursion(3)/", "categories": "leetcode, recursion", "tags": "data, cs, algorithm, leetcode, recursion", "date": "2024-02-03 00:00:00 +0900", "snippet": "정리 코드 Recursion Function(재귀함수) : 자기 자신을 재참조, 종료 조건으로 종료 시점을 제어한다. leetcode : 206. Reverse Linked List 조건 The number of nodes in the list is the range [0, 5000]. -5000 &lt;= Node.v...", "content": "정리 코드 Recursion Function(재귀함수) : 자기 자신을 재참조, 종료 조건으로 종료 시점을 제어한다. leetcode : 206. Reverse Linked List 조건 The number of nodes in the list is the range [0, 5000]. -5000 &lt;= Node.val &lt;= 5000 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */class Solution { public ListNode reverseList(ListNode head) { if (head == null || head.next == null) { return head; } ListNode nextNode = head.next; head.next = null; ListNode current = reverseList(nextNode); nextNode.next = head; return current; }}" }, { "title": "203. Remove Linked List Elements", "url": "/posts/recursion(2)/", "categories": "leetcode, recursion", "tags": "data, cs, algorithm, leetcode, recursion", "date": "2024-02-03 00:00:00 +0900", "snippet": "정리 코드 Recursion Function(재귀함수) : 자기 자신을 재참조, 종료 조건으로 종료 시점을 제어한다. leetcode : 203. Remove Linked List Elements 조건 The number of nodes in the list is in the range [0, 104] 1 &lt;= N...", "content": "정리 코드 Recursion Function(재귀함수) : 자기 자신을 재참조, 종료 조건으로 종료 시점을 제어한다. leetcode : 203. Remove Linked List Elements 조건 The number of nodes in the list is in the range [0, 104] 1 &lt;= Node.val &lt;= 50 0 &lt;= val &lt;= 50 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */class Solution { public ListNode removeElements(ListNode head, int val) { if (head == null) { return null; } if (head.val == val) { return removeElements(head.next, val); } head.next = removeElements(head.next, val); return head; }}" }, { "title": "21. Merge Two Sorted Lists", "url": "/posts/recursion(1)/", "categories": "leetcode, recursion", "tags": "data, cs, algorithm, leetcode, recursion", "date": "2024-02-03 00:00:00 +0900", "snippet": "정리 코드 Recursion Function(재귀함수) : 자기 자신을 재참조, 종료 조건으로 종료 시점을 제어한다. leetcode : 21. Merge Two Sorted Lists 조건 The number of nodes in both lists is in the range [0, 50]. -100 &lt;= N...", "content": "정리 코드 Recursion Function(재귀함수) : 자기 자신을 재참조, 종료 조건으로 종료 시점을 제어한다. leetcode : 21. Merge Two Sorted Lists 조건 The number of nodes in both lists is in the range [0, 50]. -100 &lt;= Node.val &lt;= 100 Both list1 and list2 are sorted in non-decreasing order. /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */class Solution { public ListNode mergeTwoLists(ListNode list1, ListNode list2) { ListNode answer = new ListNode(); if (list1 == null &amp;&amp; list2 == null) return null; mergeTwoListsHelper(list1, list2, answer); return answer.next; } public void mergeTwoListsHelper(ListNode list1, ListNode list2, ListNode answer) { ListNode current = answer; while (list1 != null &amp;&amp; list2 != null) { if (list1.val &lt; list2.val) { current.next = list1; list1 = list1.next; } else { current.next = list2; list2 = list2.next; } current = current.next; } if (list1 != null) { current.next = list1; } else { current.next = list2; } }}" }, { "title": "Stack", "url": "/posts/stack/", "categories": "datasutructure, stack", "tags": "data, cs", "date": "2024-02-02 00:00:00 +0900", "snippet": "정리 코드 stack : LIFO(last in first out) 형태의 자료 구조public class Node { public Node next; public int value; public Node(int value) { this.value = value; }} stack의 기본 구성public class ...", "content": "정리 코드 stack : LIFO(last in first out) 형태의 자료 구조public class Node { public Node next; public int value; public Node(int value) { this.value = value; }} stack의 기본 구성public class Stack { private Node top; private int height;} 구현 메소드 목록 public Stack(int value) public void push(int value) public Node pop() 생성자 : stack 생성시 기본 노드를 설정한다 public Stack(int value) { this.top = new Node(value); this.height++; } void push(int value) : 요소를 추가한다. public void push(int value) { Node newNode = new Node(value); if (this.height != 0) { newNode.next = this.top; } this.top = newNode; this.height++; } Node pop() : 맨 위 요소를 가져온다. public Node pop() { if (this.height == 0) { return null; } else { Node temp = this.top; this.top = temp.next; temp.next = null; this.height--; return temp; } }" }, { "title": "Queue", "url": "/posts/queue/", "categories": "datasutructure, queue", "tags": "data, cs", "date": "2024-02-02 00:00:00 +0900", "snippet": "정리 코드 queue : FIFO(first in first out) 형태의 자료 구조public class Node { public Node next; public int value; public Node(int value) { this.value = value; } } queue의 기본 구성 publ...", "content": "정리 코드 queue : FIFO(first in first out) 형태의 자료 구조public class Node { public Node next; public int value; public Node(int value) { this.value = value; } } queue의 기본 구성 public Queue(int value) { Node node = new Node(value); this.first = node; this.last = node; this.length++; } 구현 메소드 목록 - void enqueue(int value) - Node dequeue() void enqueue(int value) public void enqueue(int value) { Node newNode = new Node(value); if (this.length == 0) { this.first = newNode; } else { newNode.next = this.last; } this.last = newNode; this.length++; } Node dequeue() public Node dequeue() { if (this.length == 0) { return null; } Node temp = this.first; this.first = this.first.next; this.length--; if (this.length == 0) { this.last = null; } return temp; }" }, { "title": "Heap", "url": "/posts/heaps/", "categories": "datasutructure, heap", "tags": "data, cs", "date": "2024-02-02 00:00:00 +0900", "snippet": "정리 코드 heap : 최소 heap, 최대 heaps 로 구성 상위 노드가 하위 노드보다 작거나 크다. heap(최대)구성public class Heap { public List&lt;Integer&gt; heaps; public Heap() { this.heaps = new ArrayList&lt;&gt;(); }} 구현 메소드 ...", "content": "정리 코드 heap : 최소 heap, 최대 heaps 로 구성 상위 노드가 하위 노드보다 작거나 크다. heap(최대)구성public class Heap { public List&lt;Integer&gt; heaps; public Heap() { this.heaps = new ArrayList&lt;&gt;(); }} 구현 메소드 void swap(int index1, int index2); int leftIndex(int index); int rightIndex(int index); int parentIndex(int index); void insert(int value); Integer remove(); void sinkDown(int index); void swap(int index1, int index2) : 노드의 순서를 바꾸는 도우미 메소드 public void swap(int index1, int index2) { int temp = heaps.get(index1); heaps.set(index1, heaps.get(index2)); heaps.set(index2, temp); } int leftIndex(int index), int rightIndex(int index), int parentIndex(int index) : 노드의 인덱스를 가져오는 도우미 메소드 public int leftIndex(int index) { return (2 * index) + 1; } public int rightIndex(int index) { return (2 * index) + 2; } public int parentIndex(int index) { return (index - 1) / 2; } void insert(int value) public void insert(int value) { heaps.add(value); int current = heaps.size() - 1; while (current &gt; 0 &amp;&amp; heaps.get(current) &gt; heaps.get(parentIndex(current))) { int temp = parentIndex(current); if (heaps.get(temp) &lt; heaps.get(current)) { swap(current, parentIndex(current)); current = parentIndex(current); } } } Integer remove() public Integer remove() { if (heaps.isEmpty()) return null; if (heaps.size() == 1) return heaps.get(0); int answer = heaps.get(0); int current = heaps.size() - 1; heaps.set(0, heaps.get(current)); // 마지막 노드와 바꾼다. heaps.remove(current); sinkDown(0); return answer; } void sinkDown(int index) : 노드 삭제후 재배열 해주는 도우미 메소드 private void sinkDown(int index) { int maxIndex = index; while (true) { int leftIndex = leftIndex(index); int rightIndex = rightIndex(index); if (leftIndex &lt; heaps.size() &amp;&amp; heaps.get(maxIndex) &lt; heaps.get(leftIndex)) { maxIndex = leftIndex; } if (leftIndex &lt; heaps.size() &amp;&amp; heaps.get(maxIndex) &lt; heaps.get(rightIndex)) { maxIndex = rightIndex; } if (maxIndex != index) { swap(maxIndex, index); index = maxIndex; } else { return; } } }" }, { "title": "LinkedList", "url": "/posts/LinkedList/", "categories": "datasutructure, list", "tags": "data, cs", "date": "2024-01-31 00:00:00 +0900", "snippet": "정리 코드 배열의 공간 낭비를 피할 수 있는 자료구조. (동적 할당,Node 사용)public class Node { public int value; public Node next; public Node(int value) { this.value = value; }} LinkedList의 기본 구성public cl...", "content": "정리 코드 배열의 공간 낭비를 피할 수 있는 자료구조. (동적 할당,Node 사용)public class Node { public int value; public Node next; public Node(int value) { this.value = value; }} LinkedList의 기본 구성public class LinkedList { private Node head; // 맨 앞의 노드를 가르킨다. private Node tail; // 맨 뒤의 노드를 가르킨다. private int size; // 리스트의 크기를 체크한다.}- 구현 메소드 목록 - public LinkedList(int value); - public void append(int value); - public Node removeFirst(); - public Node removeLast(); - public Node get(int index); - public void set(int index, int value); - public void insert(int index, int value); - public void prepend(int value); - public Node remove(int index); - public void reverse(); 생성자(Constructor) : LinkedList 생성시 기본 노드를 설정해준다. public LinkedList(int value) { Node node = new Node(value); this.head = node; this.tail = node; this.size++; } 추가(append) : 리스트의 tail에 생성된 노드를 넣고 tail을 재설정한다. public void append(int value) { Node node = new Node(value); if (this.size == 0) { this.head = node; } else { this.tail.next = node; } this.tail = node; this.size++; } head 삭제(removeFirst()) : head 요소를 삭제하고 head 를 재설정 한다. public Node removeFirst() { Node headNode = this.head; if (this.getSize() == 0) { return null; } else { this.head = headNode.next; headNode.next = null; // 참조 제거 this.size--; if (this.getSize() == 0) { this.head = null; this.tail = null; } // 삭제후 리스트의 상태 체크 } return headNode; } tail 삭제(removeLast()) : tail 요소를 삭제하고 재설정 한다. public Node removeLast() { Node temp = this.head; Node pre = this.head; if (this.size == 0) { return null; } else { while (temp.next != null) { pre = temp; temp = temp.next; } // 해당 반복을 통해 마지막 노드의 앞노드를 얻는다. this.tail = pre; this.tail.next = null; // 참조 제거 this.size--; if (this.getSize() == 0) { this.head = null; this.tail = null; } } return temp; } Node get(int index) : 특정 index에 노드를 가져온다 public Node get(int index) { if (this.getSize() &lt;= index || index &lt; 0) { return null; } else if (this.getSize() - 1 == index) { return this.tail; } else { Node temp = this.head; for (int i = 0; i &lt; index; i++) { temp = temp.next; } return temp; } } void set(int index, int value) : 특정 노드의 값을 변경한다. public void set(int index, int value) { this.get(index).value = value; } void insert(int index, int value) : 특정 index에 값을 추가한다. public void insert(int index, int value) { if (this.getSize() &lt; index || index &lt; 0) { throw new NullPointerException(\"empty\"); } if (index == 0) { this.prepend(value); } else if (this.getSize() == index) { this.append(value); } else { Node newNode = new Node(value); Node temp = this.get(index - 1); newNode.next = temp.next; temp.next = newNode; this.size++; } } void prepend(int value) : 리스트의 맨 앞에 Node를 추가한다. public void prepend(int value) { Node newNode = new Node(value); Node headNode = this.head; if (this.getSize() == 0) { this.head = newNode; this.tail = newNode; } else { this.head = newNode; newNode.next = headNode; } this.size++; } Node remove(int value) : 특정 index의 노드를 삭제한다. public Node remove(int index) { if (index &lt; 0 || index &gt;= this.getSize()) { throw new NullPointerException(EMPTY_MESSAGE); } else if (index == 0) { return this.removeFirst(); } else if (index == this.getSize() - 1) { return this.removeLast(); } else { Node prev = this.get(index - 1); Node temp = prev.next; prev.next = temp.next; temp.next = null; this.size--; return temp; } } void reverse() : 리스트를 뒤집는다. public void reverse() { Node temp = this.head; this.head = this.tail; this.tail = temp; Node after; Node before = null; for (int i = 0; i &lt; this.getSize(); i++) { after = temp.next; temp.next = before; before = temp; temp = after; } }" }, { "title": "DoublyLinkedList", "url": "/posts/DoublyLinkedList/", "categories": "datasutructure, list", "tags": "data, cs", "date": "2024-01-31 00:00:00 +0900", "snippet": "정리 코드 Node에 두개의 prev, next 포인터를 가지고 있는 리스트public class Node { public Node next; public Node prev; public int value; public Node(int value) { this.value = value; }} DoublyLin...", "content": "정리 코드 Node에 두개의 prev, next 포인터를 가지고 있는 리스트public class Node { public Node next; public Node prev; public int value; public Node(int value) { this.value = value; }} DoublyLinkedList의 기본 구성public class DoublyLinkedList { private Node head; private Node tail; private int size;} 구현 메소드 목록- 구현 메소드 목록 - public DoublyLinkedList(int value); - public void append(int value); - public Node removeLast(); - public void prepend(int value); - public Node removeFirst(); - public Node get(int index); - public void set(int index, int value); - public void insert(int index, int value); - public Node remove(int index); append(int value) public void append(int value) { Node newNode = new Node(value); if (this.getSize() == 0) { this.head = newNode; } else { this.tail.next = newNode; newNode.prev = this.tail; } this.tail = newNode; this.size++; } Node removeLast() public Node removeLast() { if (this.getSize() == 0) { throw new NullPointerException(\"empty\"); } Node temp = this.tail; if (this.getSize() == 1) { this.head = null; this.tail = null; } else { this.tail = this.tail.prev; this.tail.next = null; temp.prev = null; // 참조를 끊어낸다. } this.size--; return temp; } void prepend(int value) public void prepend(int value) { Node newNode = new Node(value); if (this.getSize() == 0) { this.head = newNode; this.tail = newNode; } else { newNode.next = this.head; this.head.prev = newNode; this.head = newNode; } this.size++; } Node removeFirst() public Node removeFirst() { Node temp = this.head; if (this.getSize() == 0) { throw new NullPointerException(\"empty\"); } else if (this.getSize() == 1) { this.head = null; this.tail = null; } else { this.head = temp.next; temp.next = null; temp.prev = null; } this.size--; return temp; } Node get(int index) public Node get(int index) { if (this.getSize() &lt;= index || index &lt; 0) { return null; } Node temp = this.head; if (index &lt; this.getSize() / 2) { for (int i = 0; i &lt; index; i++) { temp = temp.next; } } else { temp = this.tail; for (int i = this.getSize() - 1; i &gt; index; i--) { // ToDO temp = temp.prev; } } return temp; } void set(int index, int value) public void set(int index, int value) { Node node = this.get(index); node.value = value; } void insert(int index, int value) public void insert(int index, int value) { if (index == 0) { prepend(value); } else if (this.getSize() == index) { append(value); } else { Node newNode = new Node(value); Node temp = this.get(index); newNode.prev = temp.prev; temp.prev.next = newNode; newNode.next = temp; temp.prev = newNode; this.size++; } } Node remove(int index) public Node remove(int index) { Node temp = this.get(index); if (index &gt;= this.getSize() || index &lt; 0) { return null; } else if (this.getSize() - 1 == index) { removeLast(); } else if (index == 0) { removeFirst(); } else { Node before = temp.prev; Node after = temp.next; before.next = after; after.prev = before; temp.prev = null; temp.next = null; this.size--; } return temp; }" } ]
